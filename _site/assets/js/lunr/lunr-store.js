var store = [{
        "title": "성엄법사 108 자재어",
        "excerpt":"불교도가 아니어도 읽어두면 도움이 될만한 내용이 많다.   욕심을 내려놓고, 나를 돌아보기 위한 문구들이 담겨있다.   마음에 드는 문장 10     놓을 줄 알아야 잡을 수도 있다. 잡고 놓는 것이 자유로워야 비로소 자유자재한 사람이다.   순경과 역경은 모두가 은인이며,  이렇게 주어진 기회에 감사하라.   부귀와 빈천으로 성공과 실패, 얻음과 잃음을 논하지 말고, 마음과 힘을 다하여 자신을 성장시키고 남을 이롭게 하여라.   인생에 있어 굴곡은 모두 성장의 경험이다.   “정진”은 필사적으로 하자는 것이 아니라, 끊임없이 노력하자는 것이다.   생, 노, 병, 고를 초월하는 삼원칙은 : 즐겁게 살고, 건강하게 병을 맞이하고, 희망차게 늙는 것이다.   죽음을 초월하는 삼원칙은 : 죽음을 찾지 말고, 죽음을 두려워하지 말고, 죽음을 기다리지 말아라.   죽음은 경사도 아니고, 장례도 아닌, 장엄한 불사일 뿐이다.   모든 자녀는 부모의 성장을 돕는 작은 보살이다.   좋아하는 것은 점유하고자 하고, 싫어하는 것은 배척하고자 하니, 얻고 잃음에 연연해하면, 번뇌가 곧 찾아온다.   마음에 드는 문장 20     도리는 자신을 다스릴 때 쓰는 것이지, 남을 가혹하게 요구하는데 쓰는 것이 아니다.   스스로를 놓아주지 못하는 것은 지혜가 없는 것이요, 남을 놓아주지 못하는 것은 자비가 없는 것이다.   역경과 순경은 모두 진일보하기 위한 인연이며, 이를 평상심과 감사의 마음으로 대하여라.   일이 순조로울 때, 자만하여 처지를 잊지 말고, 일에 풍파가 있다 해도, 의기소침할 필요가 없다.   비좁은 마음에 끝없는 욕심까지 부리면, 비록 생활은 부유하게 살지라도, 여전히 즐겁고 행복하지 못한다.   물 깊기가 천 길이라도 결국엔 바닥이 있고, 산 높기가 만길이라도 바다속에서 솟아오른 것이다.   위기가 전환점이 되는 시기로 바뀌면, 막다른 길도 활로가 된다.   인생은 꿈과 같다고 누구나 말하지만, 어찌 한평생 꿈 속에서 깨어나지 못하는가.   뛰어난 사람 위에 더 뛰어난 사람이 있으니, 각자 노력할 뿐 남을 부러워하지 말아라.   부귀는 삼대를 넘어가지 못함을 경계 하여야 하고, 권세는 사람을 타락시킬 수 있음을 주의해라.   마음에 드는 문장 30     세상을 살아가며, 마땅히 갖춰야 할 것이 네 가지가 있다 ; 적합한 곳에서 태어나고, 복이 있게 늙고, 건강하게 병을 하고, 적합한 때에 죽는 것이니, 무수한 행복이 그 속에 있는 것이다.   즐겁든 괴롭든, 타인의 평판에 의해 마음이 움직이거나 영향을 받는다면, 이는 곧 자신의 마음을 제대로 보호하지 못했고, 마음의 환경보호를 못했음이다.   자유자재한 인생은 좌절이 없는 것이 아니라, 좌절한 상황 아래서도, 여전히 몸과 마음을 평온하고, 침착하게 유지하는 것이다.   자신감이 있고, 희망이 있으면, 미래가 생길 것이다.   병이 꼭 괴로운 것은 아니고, 가난함이 꼭 괴로운 것도 아니며, 노동이 꼭 괴로운 것 역시 아니니, 마음의 고통이야말로 진정 괴로운 것이다.   마음 속으로 좌절을 받아들일 준비를 하고 있으면, 곧 좌절이 두렵지 않다.   인생에 순풍만 있을 수는 없다. 몸은 병을 면하기 어려우며, 일에서는 장애를 피하기 어려우며, 자연환경은 재해를 벗어나기 어려우니 ;마음만 안정하면 곧 평안이 있다.   조금만 더 생각하여 보면, 아직도 많은 살길이 있고 ;한 숨만 남아있다면, 곧 무한한 희망이 있는 것이다.   한 숨이 남아있는 한, 생각만 돌리면, 곧 상황도 따라 변할 것이다, 상황은 일정하지 않고 늘 변하기 때문이다.   외부 상황이 어떻게 변화하든 마음을 차분히 하고 침착하게 대한다면, 반드시 해결방법을 찾을 수 있을 것이다.   마음에 드는 문장 41, 42     자신이 잘났다고 생각하지 말 것이며, 또 스스로를 얕볼 필요도 없다.   인생에 여의치 않은 일이 열에 여덟 아홉이고, 여의치 않은 일이 이미 예상되고 있으니, 불안함도 느끼지 않게 된다.  ","categories": [],
        "tags": ["book"],
        "url": "/%EC%84%B1%EC%97%84%EB%B2%95%EC%82%AC108%EC%9E%90%EC%9E%AC%EC%96%B4/",
        "teaser": null
      },{
        "title": "Node.js프로그래밍",
        "excerpt":" layout: page title:  “Node.js프로그래밍” date:   2019-01-05 17:11:37 categories: book comments: true [[—]] 여기에 쓰세요  ","categories": [],
        "tags": [],
        "url": "/Node.js%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/",
        "teaser": null
      },{
        "title": "리엑트교과서",
        "excerpt":"여기에 쓰세요  ","categories": [],
        "tags": [],
        "url": "/%EB%A6%AC%EC%97%91%ED%8A%B8%EA%B5%90%EA%B3%BC%EC%84%9C/",
        "teaser": null
      },{
        "title": "모던자바스크립트입문",
        "excerpt":"이소 히로시 지음, 서재원 옮김, 길벗출판사   자바 스크립트언어를 깊이있게 설명하고, 몇가지 알고리즘 문제와 세부적인 문제를 정해서 푼다. 아마도 C언어로 풀어봤을 문제들을 자바스크립트로 다시 풀어보는 느낌이 강한데, 기존에 다른 언어를 익혔던 사람이라면, 쉽게 읽히는 장점이 있다.  ","categories": [],
        "tags": [],
        "url": "/%EB%AA%A8%EB%8D%98%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9E%85%EB%AC%B8/",
        "teaser": null
      },{
        "title": "Jekyll Toc 플러그인 추가하기",
        "excerpt":"   toshimaru/jekyll-toc  ","categories": ["life"],
        "tags": ["jekyll"],
        "url": "/life/jekyll-toc%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%B6%94%EA%B0%80/",
        "teaser": null
      },{
        "title": "모던 자바스크립트 입문",
        "excerpt":"이소 히로시 지음, 서재원 옮김, 길벗출판사   자바 스크립트언어를 깊이있게 설명하고, 몇가지 알고리즘 문제와 세부적인 문제를 정해서 푼다. 아마도 C언어로 풀어봤을 문제들을 자바스크립트로 다시 풀어보는 느낌이 강한데, 기존에 다른 언어를 익혔던 사람이라면, 쉽게 읽히는 장점이 있다.  ","categories": ["book"],
        "tags": ["javascript"],
        "url": "/book/%EB%AA%A8%EB%8D%98%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9E%85%EB%AC%B8/",
        "teaser": null
      },{
        "title": "리엑트교과서",
        "excerpt":"여기에 쓰세요  ","categories": ["book"],
        "tags": ["javascript"],
        "url": "/book/%EB%A6%AC%EC%97%91%ED%8A%B8%EA%B5%90%EA%B3%BC%EC%84%9C/",
        "teaser": null
      },{
        "title": "Node.js프로그래밍",
        "excerpt":"자바스크립트를 브라우저 밖에서 실행할 수 있도록 함.   python 쓰는 것과 비슷한 느낌이 난다.   자바스크립트는 활용도가 점점 커지는 느낌  ","categories": ["book"],
        "tags": ["javascript"],
        "url": "/book/Node.js%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/",
        "teaser": null
      },{
        "title": "알고리즘문제해결전략12",
        "excerpt":"알고리즘 공부하자 -_-;;   ","categories": ["book"],
        "tags": ["book"],
        "url": "/book/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%AC%B8%EC%A0%9C%ED%95%B4%EA%B2%B0%EC%A0%84%EB%9E%B512/",
        "teaser": null
      },{
        "title": "bash 코딩할 때 도움되는 것들 모아두기",
        "excerpt":"Table Of Content     md 확장자인 파일을 찾아서 string 바꾸기, (sub dir모두)   scp로 파일 복사하기   sftp로 최신 파일 가져오기   References           Heredoc 관련       GetOpt 관련       pushd/popd           md 확장자인 파일을 찾아서 string 바꾸기, (sub dir모두)  $find . -name \"*.md\" -exec sed -i -e 's/AAA/BBB/g' {} \\;      link   scp로 파일 복사하기   sshpass -p암호 scp -o StrictHostKeyChecking=no hello.txt id@111.222.333.444:/home/id/hello.txt      expect + scp로도 가능할 것.   link   sftp로 최신 파일 가져오기      wild card 규칙을 적용할 수 있을까?     fileName=$(echo \"ls -1rt\" | sftp -oIdentityFile=&lt;pathToKeyFile&gt; username@sftpServer:/remoteDir | tail -1)            link   References  Heredoc 관련     how-can-i-write-a-heredoc-to-a-file-in-bash-script : heredoc 이용하기   How can I write a heredoc to a file in Bash script? : heredoc으로 file생성하기   GetOpt 관련     An example of how to use getopts in bash : getopt로 argument처리   pushd/popd     Can I call pushd/popd and prevent it printing the stack?  ","categories": ["script"],
        "tags": ["bash"],
        "url": "/script/bash-tips-list/",
        "teaser": null
      },{
        "title": "jekyll syntax highlight 지정하기",
        "excerpt":"   code example   Reference   code example   function syntaxHighlight(code) { \tvar foo = 'Hello World'; \tvar bar = 100; }   Reference     Syntax highlighter 지정하기 with rouge  ","categories": ["code"],
        "tags": ["jekyll"],
        "url": "/code/jekyll-syntax-highlight-setting/",
        "teaser": null
      },{
        "title": "명상록",
        "excerpt":"2018-03-27 1번 읽기 끝   2018-03-17 읽는 중   철학자로서 황제였다는 사실이 놀랍다. 전쟁도 나가고 국정 업무를 하면서 틈을 내서 글을 썼고, ‘명상록’이란 책이 되었다.   황제로서의 삶을 살았지만, 자신을 다스리는 태도가 끊임없이 글에 느껴졌다.   ","categories": ["book"],
        "tags": ["book"],
        "url": "/book/%EB%AA%85%EC%83%81%EB%A1%9D/",
        "teaser": null
      },{
        "title": "tmux ctrl-b키를 ctrl-a키로 변경하기",
        "excerpt":"Ctrl a로 키맵변경  기본으로는 Ctrl b로 지정되어 있다.   .tmux.conf에 다음을 추가한다.   unbind C-b                                                                                                                                                            set -g prefix C-a                                                                                                                                                     bind C-a send-prefix   Emacs 키맵과 충돌 문제   C-a로 라인의 시작으로 이동하는 명령이 연결되어 있다. tmux에서 이맥스를 켜면, C-a를 tmux가 먼저 인식하게 되는 문제가 있다.   C-a &lt;Home&gt; Move to the beginning of the line (move-beginning-of-line). C-e &lt;End&gt; Move to the end of the line (move-end-of-line).    Reference     Emacs - Moving Point  ","categories": ["script"],
        "tags": ["tmux"],
        "url": "/script/tmux-ctrl-b-change/",
        "teaser": null
      },{
        "title": "tmux-terminal-multiplexer",
        "excerpt":"2018-01-19   Tmux (tmux-terminal-multiplexer)   terminal 하나를 가상으로 여러 terminal처럼 이용할 수 있는 도구      https://youtu.be/wKEGA8oEWXw   tmux conf 참고      https://github.com/tony/tmux-config/blob/master/.tmux.conf   https://gist.github.com/spicycode/1229612   How do I reorder tmux windows?   창 번호가 0 3 5 7 등으로 중간중간 빠졌을 때 유용함   C-b, .      https://superuser.com/questions/343572/how-do-i-reorder-tmux-windows  ","categories": ["script"],
        "tags": ["tmux"],
        "url": "/script/tmux-terminal-multiplexer/",
        "teaser": null
      },{
        "title": "GRIT",
        "excerpt":"타고난 재능이 아닌 끈기와 노력이 성장과 성공으로 이끈다는 긍정의 메시지를 주는 책   만족      2018-03-01 읽기 끝   2017-12-28 읽기 시작   ","categories": [],
        "tags": ["book"],
        "url": "/GRIT-book/",
        "teaser": null
      },{
        "title": "영화 안시성",
        "excerpt":"2018-09-20   오랜만에 재미있게 봤다.   유난히 말을 타던 양만춘의 부하, 기마대장 파소의 모습이 떠오른다. 정말 전투장면 같은 느낌이 들었나보다.   설현도 나왔다. 아마 감독의 상상력이지 싶은데, 전쟁영화에 로맨스를 더한 느낌.   양만춘의 부관도 생각이 난다. 조직을 굳건히 지키는데는 항상 그런 자들이 보이지 않는 곳에서 묵묵히 소임을 다한다.   캐스팅 좋았고, 액션 좋았고, 정신없이 두시간을 흘려보냈다.   지난한 일상에서 잠깐 빠져나와 시간여행을 하고 돌아가는 느낌이다.   양만춘은 정말 저런 장수였을까? 아마도 감독의 상상력이지 싶지만, 그래도 저런 장수가 우리 역사속에 한명 쯤 있었어도 좋겠다.   시찰중에 노인을 구해, 아들에게 데려다주는 그런 성주이면서, 전투할 때는 앞장서는 장수의 모습   현실세계에서 참 보기 힘든 모습이라 더 기억에 남는 것일지도 모르겠다.   영화는 결국 작가의 상상속에서 만들어진 허구이지만, 배우들의 연기와 시청각 효과가 더해지면서 현실같은 모습으로 변신한다.   만족  ","categories": ["culture"],
        "tags": [],
        "url": "/culture/%EC%98%81%ED%99%94%EC%95%88%EC%8B%9C%EC%84%B1/",
        "teaser": null
      },{
        "title": "vimpowerline-setting",
        "excerpt":"2018-05-06   vim powerline 설정해보기      http://shayete.tistory.com/entry/Linux-vim-powerline-%EC%84%A4%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95   https://github.com/wernight/powerline-web-fonts/issues/8   1번 step을 모두 진행한 후   다음 두 줄을 추가하면 잘 나온다   export LANG=en_US.UTF-8 export LC_CTYPE=en_US.UTF-8   화려하고 예쁘다.   ","categories": ["book"],
        "tags": ["vim"],
        "url": "/book/vimpowerline-setting/",
        "teaser": null
      },{
        "title": "vim dracula theme setting",
        "excerpt":"사용법      https://draculatheme.com/vim/   dracula.vim을 받아서 ~/.vim/colors에 넣으면 동작한다.   변수 type에만 배경색이 다른 문제가 생김 - .vimrc에 추가하기   let g:dracula_italic = 0 colorscheme dracula highlight Normal ctermbg=None   출처     https://github.com/dracula/vim/issues/65  ","categories": ["book"],
        "tags": ["vim"],
        "url": "/book/vim-dracula-theme-setting/",
        "teaser": null
      },{
        "title": "Automake GNU manual",
        "excerpt":"Automake GNU 메뉴얼      https://www.gnu.org/software/automake/manual/   texinfo style이 좋은건가?   잘 읽힌다.  ","categories": ["book"],
        "tags": [],
        "url": "/book/Automake-GNU-manual/",
        "teaser": null
      },{
        "title": "Autotools For Beginners",
        "excerpt":"        Autotools Tutorial for Beginners            Autoconf GNU manual            Makefile 쓰는 법            Setting up autoconf            enable, with 옵션 사용법       ","categories": ["book"],
        "tags": [],
        "url": "/book/AutotoolsForBeginners/",
        "teaser": null
      },{
        "title": "file browser on ubuntu terminal",
        "excerpt":"terminal에서 현재 dir을 file browser로 띄우고 싶을 때   nautilus --browser .      https://askubuntu.com/questions/8580/opening-the-file-browser-from-terminal  ","categories": [],
        "tags": ["bash"],
        "url": "/file-browser-on-ubuntu/",
        "teaser": null
      },{
        "title": "my-vim-tips",
        "excerpt":"vim으로 함수 전체 접기   set foldmethod=syntax set foldnestmax=1  0으로 바꾸면 unfold   trailing white spaces 지우기 (in place)   :%s/\\s\\+$//e   여러 파일 열기 (in place)  / buffer 이동   : args a.txt b.txt        :bn    F10으로 파일 내용 클립보드 복사 (.vimrc)   map &lt;F10&gt; &lt;ESC&gt;:!xsel --clipboard --input &lt; % &lt;CR&gt;&lt;CR&gt;   ","categories": ["script"],
        "tags": ["vim"],
        "url": "/script/my-vim-tips/",
        "teaser": null
      },{
        "title": "자바디자인패턴",
        "excerpt":"인프런 강의에 있음. 작은 예제를 골라 설명해주는 방식. 유익하다.      스트래티지   어댑터   팩토리 메소드   싱글톤 패턴(Singleton Pattern)   프로토타입 2   빌더 1   추상 팩토리 1,2   브릿지   컴포지트   방문자   미디에이터   스테이트  ","categories": ["book"],
        "tags": [],
        "url": "/book/%EC%9E%90%EB%B0%94%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/",
        "teaser": null
      },{
        "title": "나눔명조웹폰트사용",
        "excerpt":"   구글 웹폰트에서 내려받음   css의 body에서 font-family를 지정한다.   &lt;html&gt; &lt;head&gt; &lt;title&gt;font test&lt;/title&gt;  &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf8\"&gt;  &lt;link href=\"http://fonts.googleapis.com/earlyaccess/nanummyeongjo.css\" rel=\"stylesheet\" type=\"text/css\" /&gt; &lt;style&gt; body { \tfont-family:'Nanum Myeongjo', serif; }  &lt;/style&gt;  &lt;/head&gt; &lt;body&gt; &lt;p&gt;안녕하세요&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;  ","categories": ["hobby"],
        "tags": ["jekyll"],
        "url": "/hobby/web-font-usage/",
        "teaser": null
      },{
        "title": "점프투파이썬",
        "excerpt":"예제가 쉽고, 설명이 쉽다. 웹북도 있고, 종이책도 있음. 입문과 리퍼런스 용으로 괜찮음      점프투파이썬  ","categories": ["book"],
        "tags": ["python"],
        "url": "/book/%EC%A0%90%ED%94%84%ED%88%AC%ED%8C%8C%EC%9D%B4%EC%8D%AC/",
        "teaser": null
      },{
        "title": "초보자를 위한 파이썬 300제",
        "excerpt":"10문제씩 풀어보면서, 답도 확인 가능함      초보자를 위한 파이썬 300제  ","categories": ["book"],
        "tags": ["python"],
        "url": "/book/%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC%EC%9C%84%ED%95%9C%ED%8C%8C%EC%9D%B4%EC%8D%AC300%EC%A0%9C/",
        "teaser": null
      },{
        "title": "파이썬조각코드모음집",
        "excerpt":"   Python Snippets - 파이썬 조각 코드 모음집  ","categories": ["book"],
        "tags": ["python"],
        "url": "/book/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%A1%B0%EA%B0%81%EC%BD%94%EB%93%9C%EB%AA%A8%EC%9D%8C%EC%A7%91/",
        "teaser": null
      },{
        "title": "Pro Git",
        "excerpt":"Git 사용법     Pro Git   asciidoc으로 작성되어 있음     Pro Git github   ","categories": ["book"],
        "tags": ["git"],
        "url": "/book/ProGit/",
        "teaser": null
      },{
        "title": "Python Design Patterns Tutorial",
        "excerpt":"   Python Design Patterns      Model View Controller Pattern   Singleton pattern   Factory pattern   Builder Pattern   Prototype Pattern   Facade Pattern   Command Pattern   Adapter Pattern   Prototype Pattern   Decorator Pattern   Proxy Pattern   Chain of Responsibility Pattern   Observer Pattern   State Pattern   Strategy Pattern   Template Pattern   Flyweight Pattern   Abstract Factory Pattern   Object Oriented Pattern  ","categories": ["book"],
        "tags": ["python"],
        "url": "/book/PythonDesignPatternsTutorial/",
        "teaser": null
      },{
        "title": "영화 마녀",
        "excerpt":"인간 유전자 개조실험을 통해 길러진 아이가 탈출하여 살아가는 이야기.   늦은 밤 TV 채널을 돌리다가 보게 된 영화.   그나마 이름을 가지고 살수 있었던 마녀 ‘구자윤’과 이름조차 없이 살아갔던 인조인간의 삶이 나온다.   초능력이 없이 사는 사람들이 무기력하다거나 하지 않게 표현되었다.   극장에서 봤었다면 더 좋았을 영화 ‘마녀’  ","categories": ["culture"],
        "tags": [],
        "url": "/culture/%EC%98%81%ED%99%94-%EB%A7%88%EB%85%80/",
        "teaser": null
      },{
        "title": "약해진 마음일 때 하는 결정의 위험성",
        "excerpt":"세상에는 다양한 형태의 비즈니스가 존재한다.   그 중에는 약해질 대로 약해진 사람들의 마음을 쥐고 흔들어 돈을 뽑아내는 사람도 존재한다.   그런 사람들은 언제나 선의로 포장되어 있고, 유머와 쿨함으로 위장하고 있다.   시간이 지나면 결국 본 모습이 드러나겠지만, 그 전까지 그러한 모습에 눌러주는 ‘좋아요’는 그들의 좋은 먹잇감이다.   함부로 휘둘리지 말고, 마음이 약해질 때의 결정을 조심하자.  ","categories": ["life"],
        "tags": [],
        "url": "/life/%EC%95%BD%ED%95%9C%EB%A7%88%EC%9D%8C%EC%97%90%ED%9C%98%EB%91%98%EB%A6%AC%EC%A7%80%EC%95%8A%EA%B8%B0/",
        "teaser": null
      },{
        "title": "영화 순수의 시대",
        "excerpt":"무장 김민재의 삶과 주변의 다양한 사람들의 삶과 태도를 보게하는 영화.   적당히 야한 장면이 나오고, 잔인한 장면도 나온다.   하지만 상징을 통한 의미를 잘 살리려고 노력한 영화 같다.   흥행하지 못한 영화인 것 같은데, 그와 상관없이 나에게 많은 생각할 것을 주었다.   대업을 이루는 것도 망치는 것도 자신의 삶을 잘 다스리는 것에 달려있다.  ","categories": ["culture"],
        "tags": [],
        "url": "/culture/%EC%98%81%ED%99%94-%EC%88%9C%EC%88%98%EC%9D%98%EC%8B%9C%EB%8C%80/",
        "teaser": null
      },{
        "title": "알라딘",
        "excerpt":"화려한 영상미가 돋보이는 영화. 램프의 지니가 소원을 들어준다는 이야기로 풀어나간다.   더빙판을 봤는데, 노래를 하는 장면들이 어색하지 않게 잘 처리되었다.   성우들이 노래도 잘하나보다.   2시간여 동안 일상을 잊고, 빠져들기 좋았던 영화  ","categories": ["culture"],
        "tags": [],
        "url": "/culture/%EC%98%81%ED%99%94-%EC%95%8C%EB%9D%BC%EB%94%98/",
        "teaser": null
      },{
        "title": "트로이",
        "excerpt":"최강의 검투사인 아킬리스가 트로이 침공의 선두에 나서 활약하는 이야기   평범한 사람들이 두려워할 상황을 영광으로 생각하고, 위험을 극복한다.   누군가에게는 전쟁이 소중한 가족을 지키는 일이고,   누군가에게는 자신의 영광을 얻기 위한 기회가 되기도 한다.   다양한 사람들이 전쟁이라는 상황에서 보이는 감정을 잘 표현한 영화, 트로이.  ","categories": ["culture"],
        "tags": [],
        "url": "/culture/%EC%98%81%ED%99%94-%ED%8A%B8%EB%A1%9C%EC%9D%B4/",
        "teaser": null
      },{
        "title": "repl.it",
        "excerpt":"   repl.it   C/C++ 프로그래밍을 온라인 환경에서 해볼 수 있음.   bash shell에서 컴파일하는 과정을 보여준다.   stdin, stdout을 이용할 수 있음   vim edit mode지원함  ","categories": ["IT"],
        "tags": [],
        "url": "/it/repl-it/",
        "teaser": null
      },{
        "title": "ack.vim",
        "excerpt":"vim에서 text search를 위한 도구   :Ack keyword   :Ack keyword filename   vim 안에서 화면을 나누어서, 검색결과를 볼 수 있다.      link to ack.vim  ","categories": [],
        "tags": ["vim"],
        "url": "/ack-vim/",
        "teaser": null
      },{
        "title": "clang_complete 이용하기",
        "excerpt":"   libclang 설치   .vimrc에 플러그인 설치하기   .vimrc에 clang_complete 설정하기   사용법   References   libclang 설치   sudo apt-get install libclang-3.8-dev   .vimrc에 플러그인 설치하기   Plugin 'SirVer/ultisnips' Plugin 'xavierd/clang_complete'   .vimrc에 clang_complete 설정하기   let g:clang_library_path='/usr/lib/llvm-3.8/lib'  set pumheight=10             \" so the complete menu doesn't get too big set completeopt-=preview set completeopt=menu,longest \" menu, menuone, longest and preview  let g:SuperTabDefaultCompletionType='context' let g:clang_complete_auto=0  \" I can start the autocompletion myself, thanks.. let g:clang_snippets=1       \" use a snippet engine for placeholders let g:clang_snippets_engine='ultisnips' let g:clang_auto_select=2     사용법     함수 이름 + Ctrl-x Ctrl-u 입력하면, parameter list가 채워진다.      References     https://stackoverflow.com/questions/11300788/vim-function-hints-for-c   https://github.com/xavierd/clang_complete   https://www.vim.org/scripts/script.php?script_id=2715   ","categories": [],
        "tags": ["vim"],
        "url": "/vim-function-complete/",
        "teaser": null
      },{
        "title": "Jekyll 명령어 모음",
        "excerpt":"Jekyll 설치, Gem으로 theme 설치     설치방법   Gem으로 theme설치   Jekyll blog 만들기  jekyll new BLOGNAME.github.io   Jekyll 명령 실행하기  bundle exec jekyll serve   Gemfile에 플러그인 설치하기   Gemfile에 내용을 편집한 후 bundle 명령어를 실행한다.   bundle install   ","categories": ["code"],
        "tags": ["jekyll"],
        "url": "/code/jekyll-serve/",
        "teaser": null
      },{
        "title": "vim과 GNU global 연동",
        "excerpt":"Table Of Content     GNU Global이란?   mkcscope.sh와 비슷하게 script를 만들기   Incremental 업데이트 하기   global 예제   6.6 최신 버전 설치하기   References   GNU Global이란?   vim + cscope조합을 꽤 오랫동안 쓰다가, 바꿔봤다.   gtags.vim이 소스 검색 결과를 좀더 잘 보여준다.      변수, 함수의 선언으로 이동   구현으로 이동   사용한 곳으로 이동   파일이름으로 이동   mkcscope.sh와 비슷하게 script를 만들기   #!/bin/bash find . -name '*.cpp' -o -name '*.h' &gt; gtags.files gtags --accept-dotfiles -c -f gtags.files  mktags.sh로 만들고 실행권한을 준다. source의 최상위 dir에서 한번 호출해주면 된다.   Incremental 업데이트 하기   한번 tag database를 만든 다음에는 변경된 소스만 대상으로 db를 업데이트 해준다.   파일이 변경되면, update하게 하면 어떨까?   $ global -vu   global 예제   $ global func1                 # definition $ global -r func2              # reference $ global 'func[1-3]'           # regular expression $ global -x func2              # show detail $ global -xg '#ifdef NDEBUG'   # specific pattern  $ global -c kmem&lt;TAB&gt;&lt;TAB&gt;     # complete command $ vi `global func1`            # edit files having specified tags.   6.6 최신 버전 설치하기   https://ftp.gnu.org/pub/gnu/global/ 코드 다운로드  $ tar -xvzf global-6.6.tar.gz $ cd global-6.6 $ ./configure $ make $ make install $ global --version global (GNU GLOBAL) 6.6   References     GNU Global Manual   gtags.vim   keymap 예제   script형태로 쓰기  ","categories": [],
        "tags": ["vim"],
        "url": "/vim-gnu-global/",
        "teaser": null
      },{
        "title": "Windows10에 git 설치, MSYS2",
        "excerpt":"git client windows용을 설치하면 된다. 간단한 terminal이 제공되는데, 이게 쓸만함. 여기에 MinGW를 설치해서 gcc, make등을 이용할 수 있음   tmux를 쓰려면 MSYS2를 설치해야 함.  ","categories": ["git"],
        "tags": [],
        "url": "/git/wingit-on-win10/",
        "teaser": null
      },{
        "title": "elisp - hello world 예제",
        "excerpt":"elisp로 hello world 출력하기   M-x ielm으로 모드를 진입하고, 함수를 만들어 본다.   *** Welcome to IELM ***  Type (describe-mode) for help. ELISP&gt; (defun say-hello () \"hello\") say-hello ELISP&gt; (say-hello) \"hello\"   list를 만들기   ELISP&gt; '(rose violet daisy buttercup)  (rose violet daisy buttercup)  ELISP&gt;   emacs에서 2+2 evalute하기   블럭을 지정한 후, C-x C-e하면 evalute된다.  (+ 2 2)   Reference     Practical Emacs Lisp   elisp_basics   Emacs Lisp for Hackers: Hello World   Manual &gt; Lisp-Lists   Manual &gt; Run-a-Program  ","categories": ["emacs","elisp"],
        "tags": [],
        "url": "/emacs/elisp/elisp-say-hello/",
        "teaser": null
      },{
        "title": "jekyll texture 테마 설치하기",
        "excerpt":"간단하게 사용하기 좋다.   git clone https://github.com/thelehhman/texture.git vi _config.yml bundle exec jekyll serve  ","categories": ["jekyll"],
        "tags": [],
        "url": "/jekyll/install-texture-theme/",
        "teaser": null
      },{
        "title": "vim lightline.vim 설치",
        "excerpt":"   airline 플러그인과 비슷하지만, 좀 더 예쁘게 상태바를 표현해준다.   같이 써도 괜찮다.   link - lightline.vim  ","categories": [],
        "tags": ["vim"],
        "url": "/vim-plugin-lightline/",
        "teaser": null
      },{
        "title": "My Emacs Reference Card",
        "excerpt":"주로 쓰는 emacs 명령어 정리   basic command                  CMD       DESC                       C-x C-f       파일 Open                 C-x C-s       파일 Save                 M-x package-list-packages       package list로 진입하기                 C-n       아래로 이동                 C-f       오른쪽으로 이동                 C-b       왼쪽으로 이동                 C-p       위로 이동                 C-d       한 글자 지우기                 C-k C-y       한줄 지우고, 붙이기                 C-SPC       visual block 지정 시작                 C-x C-b       Buffer List 열기                 C-x o       창분할된 옆창 이동           ##  | CMD\t                         | DESC                      | |——————————–|—————————| | M-x toggle-truncate-lines      | auto line warpping on/off |   org-mode command                  CMD       DESC                       org-agenda 진입 후 m       tag를 이용한 검색                 F12       org-todo-list 진입                 C-c C-w       refile하기                 C-c C-o       org-open-at-point 문서내부 URL을 browser로 열기           c programming  | CMD\t                             | DESC                                                          | |————————————|—————————————————————| | block 지정 후 M-x c-macro-expand   | preprocessor 문장을 해석해준다.                               |   emacs config mapping   F11, F12를 org-todo-list, agenda로 매핑하기  (global-set-key (kbd \"&lt;f12&gt;\") 'org-todo-list) (global-set-key (kbd \"&lt;f11&gt;\") 'org-agenda)   refile target이되는 파일 이름 지정하기  (setq org-refile-targets '((\"archive.org\" :level . 1)))   ","categories": [],
        "tags": ["emacs"],
        "url": "/my-emacs-ref/",
        "teaser": null
      },{
        "title": "My Vim Reference Card",
        "excerpt":"주로 쓰는 vim 명령어 정리   basic command                  CMD       DESC                       :w filename       파일 이름으로 저장                 Ctrl-v 커서 이동 + y       visual block만들고 copy                 p       paste 하기                 :find text.txt       sub dir에서 파일 찾기                 :g/^$/d       empty line 지우기                 :v/./d       empty line 지우기           plugin이용 command                  CMD       DESC                       Ctrl-p       ctrlp로 파일 찾기           C/C++용 키맵 (GNU global)                  CMD       DESC                       ,gd ,ld       definition으로 점프                 ,gr ,lr       reference로 점프                 ,gs ,ls       string 검색           Text Object 예제                  CMD       DESC                       6+       6 줄 다음으로 이동                 6-       6 줄 이전으로 이동                 gUaW       단어 전체를 대문자화                 guaW       단어 전체를 소문자화                 4$       4줄 뒤 맨뒤로 이동                 #       paren, bracket, #ifdef의 match되는 곳으로 이동           Talk on going mouseless with Vim, Tmux, and Hotkeys   Reference     Remove_unwanted_empty_line  ","categories": [],
        "tags": ["vim"],
        "url": "/my-vim-ref/",
        "teaser": null
      },{
        "title": "cscope와 mkcscope.sh",
        "excerpt":"vim + cscope조합을 오래 썼다.   적당히 유용하고, indexing된 파일을 분리해서 만들어, 연결해 쓸 수 있다는 장점이 있다.   cscope 커맨드라인도구를 따로 쓸 수 있음. (코드 분석 목적)   mkcscope.sh로 만들기  #!/bin/sh rm -rf cscope.files cscope.files find `pwd` \\( -name '*.c' -o -name '*.cpp' -o -name '*.cc' -o -name '*.h' -o -name '*.y' -o -name '*.s' -o -name '*.S' \\) -print &gt; cscope.files cscope -b -i cscope.files  mkcscope.sh로 만들고 실행권한을 준다. source의 최상위 dir에서 한번 호출해주면 된다.   vim에서 reset해서 업데이트된 cscope DB를 들고올 수 있다.  :cs reset   References     ctags and cscope 사용법  ","categories": [],
        "tags": ["vim"],
        "url": "/mkcscope-sh-usage/",
        "teaser": null
      },{
        "title": "gravata에 이미지 등록",
        "excerpt":"Gravata에 이미지 등록하기   크롬 스토어에서 Avatar Maker 설치하고, 이미지를 만든 후, gravata 사이트에 회원가입 후, 이미지를 등록하면 된다.      Reference     Image Requests  ","categories": [],
        "tags": ["vim"],
        "url": "/gravata-generation/",
        "teaser": null
      },{
        "title": "expect 사용하기",
        "excerpt":"expect script   command를 입력하고, 예상되는 출력에 따라 다른 동작을 하게 할 때 사용함.   정형적인 작업의 흐름을 자동화 하기 좋을 것 같다.      HEREDOC 방식으로 bash script안에서 할 수 있음   Reference      Bash script에 expect 스크립트 넣기  ","categories": [],
        "tags": ["expect"],
        "url": "/expect-automation/",
        "teaser": null
      },{
        "title": "jekyll config 지정하기",
        "excerpt":"disqus 지정하기   _config.yml에 shortname 추가  disqus_shortname: \"XXXXXXX\"    disqus comment 없애기   post를 작성할 때, 상단 config에 nocomments를 지정함   nocomments: true   보이는 것은 default지정   tag 기능 추가   Tag를 Category아래 추가한다.   header:   links:             # Links on the header. Link to in-site page with a slash as prefix     About: /about/     Category: /category/     Tag: /tag/   tag.html 파일을 만들고, Jekyll template engine 문법에 맞춰서 코딩   수학식 출력 (Mathjax)   \\[x = y^2\\] ","categories": [],
        "tags": ["vim"],
        "url": "/jekyll-config/",
        "teaser": null
      },{
        "title": "vim relative 라인 번호 지정",
        "excerpt":"set rnu이란?  vim에서 행 번호를 현재 커서 기준으로 위 아래를 지정할 하는 기능   set number set nu set relativenumber set rnu     \" 켜기 set rnu!    \" 끄기   행 번호가 상대기준으로 보인다면 줄 이동을 여러번 key입력하지 않아도 된다.  7+    \" 7줄 아래로 이동 g-    \" 7줄 위로 이동   Ctrl-L Ctrl-L을 이용해서 모드 변경하기  \" .vimrc에 키맵을 추가함 \" Relative number display nmap &lt;C-L&gt;&lt;C-L&gt; :set invrelativenumber&lt;CR&gt;   Reference  Link  ","categories": [],
        "tags": ["vim"],
        "url": "/vim-relative-linenumber/",
        "teaser": null
      },{
        "title": "OrgMode를 이용한 Jekyll 블로그 쓰기",
        "excerpt":" org mode를 이용한 블로그 쓰기    이 페이지는 emacs org mode로 만들어짐 이맥스 에디터 안에서 블로그 글을 모두 작성하고, preview 가능한 구조 구축 글이 완성되면 git push를 하면 된다.     emacs config 내용    (setq org-publish-project-alist       '(         (\"org-site\"           ;; Path to your org files.          :base-directory \"~/work/github/JEKYLLDIR/_org_post/\"          :base-extension \"org\"           ;; Path to your Jekyll project.          :publishing-directory \"~/work/github/JEKYLLDIR/\"          :recursive t          :publishing-function org-html-publish-to-html          :html-extension \"html\"          :body-only t ;; Only export section between &lt;body&gt; &lt;/body&gt;           :section-numbers nil          :with-toc nil          :auto-index nil          :auto-preamble nil          :body-only t          :auto-postamble nil          )          (\"org-static-site\"          :base-directory \"~/work/github/JEKYLLDIR/_org_post/\"          :base-extension \"css\\\\|js\\\\|png\\\\|jpg\\\\|gif\"          :publishing-directory \"~/work/JEKYLLDIR/\"          :recursive t          :publishing-function org-publish-attachment          )          (\"mysite\" :components (           \"org-site\"           \"org-static-site\"         )       )     ) )       page마다 front matter 쓰기    맨 위에 다음을 추가한다.     #+HTML: --- #+HTML: title: org mode를 이용한 블로그 쓰기 #+HTML: tags: OrgMode #+HTML: ---      C++ 소스 쓰기     #include &lt;iostream&gt; using namespace std;  int main(int argc, char* argv[]) {     cout &lt;&lt; \"Hello World\" &lt;&lt; endl;     return 0; }        생성 방법    C-c C-e P x 후 현재 등록된 proejct를 고른다.(org-zune)      DONE image 추가하기    [[../assets/imgs/test.jpeg]]             TODO orgmode로 표 추가하기             Name Phone    1 2          참고자료    https://www.mfoot.com/blog/2015/11/17/using-org-mode-to-write-jekyll-blogs/ https://orgmode.org/worg/org-tutorials/org-jekyll.html    ","categories": [],
        "tags": ["Emacs"],
        "url": "/org-mode-jekyll-pub-blog/",
        "teaser": null
      },{
        "title": "git 명령어 모음",
        "excerpt":" 자주 쓰는 명령어    git pull                            # &#50896;&#44201; &#51200;&#51109;&#49548;&#51032; &#45236;&#50857; &#44032;&#51256;&#50724;&#44592; (&#45817;&#44200;&#50724;&#44592;) git log                             # log&#48372;&#44592; git add                             # commit&#54624; &#54028;&#51068; &#52628;&#44032;&#54616;&#44592; git commit -m \"commit message\"      # commit&#54616;&#44592; git push                            # &#50896;&#44201; &#51200;&#51109;&#49548;&#50640; push&#54616;&#44592; git reset --hard                    # &#47196;&#52972; &#51200;&#51109;&#49548; &#48320;&#44221;&#45236;&#50857; &#51648;&#50880;       2020년 이후의 commit만 1줄로 보기 + 저자 상대적 시간 출력    git log --pretty=format:\"%s (%ar)\" --after='2020-01-01'       git rebase    자주 안쓴다.        TODO git clone    tutorial git볼 것      Reference    totorial-git git-scm-book    ","categories": [],
        "tags": ["git"],
        "url": "/my-git-cmd-ref/",
        "teaser": null
      },{
        "title": "ox-gfm으로 org를 markdown변환하기",
        "excerpt":" org mode로 markdown page export 시도    M-x package install ox-gfm      설치한 패키지 제거하기    M-x package-list-packages ox-gfx d로 마크하고 x선택      결과    에러 발생함 시간날 때 고쳐보자    Symbol's function definition is void: org-export-custom-protocol-maybe    publish를 markdown으로 하도록 project config구성 필요함 (org-publish-project-alist)       Reference   ","categories": [],
        "tags": ["org-mode"],
        "url": "/org-export-gfm/",
        "teaser": null
      },{
        "title": "vim + conqueGDB 이용",
        "excerpt":" 사용법    vim에서 코딩하고, 빌드한 실행파일 이름을 적어준다.    :conqueGDB code   code는 실행파일 이름 화면을 split해서 하단에 gdb가 있는 형태      느낀 점    생각보다 자연스럽게 동작하는 것 같지 않음 그냥 gdb CLI나 ddd를 쓰는게 나아보인다.      Reference    https://github.com/vim-scripts/Conque-GDB     ","categories": [],
        "tags": ["vim"],
        "url": "/vim-conque-gdb/",
        "teaser": null
      },{
        "title": "todo.txt 이용하기",
        "excerpt":" todo.txt-vim    vim을 이용해서 todo.txt 포맷으로 할일 관리를 할 수 있는 플러그인       vim 키맵    &lt;localleader&gt;s : Sort the file &lt;localleader&gt;s+ : 프로젝트를 sorting &lt;localleader&gt;s@ : 컨택스트로 sorting &lt;localleader&gt;sd : 날자로 sorting &lt;localleader&gt;sd : due date로 sorting &lt;localleader&gt;dd : 날자를 붙여준다 &lt;localleader&gt;x : 현재 task에 완료 표시 &lt;localleader&gt;d : 완료된 task를 done.txt로 보낸다.      config    매핑을 F12로 해주었다.    let maplocalleader = \"\\\\\" map &lt;F12&gt; &lt;ESC&gt;:e ~/Dropbox/todo/todo.txt &lt;CR&gt;       date로 정렬 역순으로 하게하기    ~/vim/bundle/todo.txt-vim/autoload/todo/todo.vim을 열어서 sort를 %sort! 로 변경하면 역순으로 시간이 보이게 된다.    function! todo#txt#sort_by_date() range     let l:date_regex = \"\\\\d\\\\{2,4\\\\}-\\\\d\\\\{2\\\\}-\\\\d\\\\{2\\\\}\"     execute a:firstline . \",\" . a:lastline . \"%sort! /\" . l:date_regex . \"/ r\"     execute a:firstline . \",\" . a:lastline . \"g!/\" . l:date_regex . \"/m\" . a:lastline endfunction       Reference    https://github.com/todotxt/todo.txt https://github.com/freitass/todo.txt-vim      SimpleTask Cloud와 연동하기    Dropbox에 저장한 파일을 Android app에서 편집하고, desktop에서 vim으로 편집을 할 수 있다.     Dropbox/todo dir아래에 파일이 저장되는 것 같다.     Simple Task App      사용 소감    orgmode는 project단위로 트리구조를 타고 내려가며 정리하기 좋은 구조라면, todo.txt는 할일관리를 날자 단위로 챙기기 좋게 되어있다.     ","categories": [],
        "tags": ["vim"],
        "url": "/todo-txt-ref/",
        "teaser": null
      },{
        "title": "STL pair와 vector 같이 쓰기",
        "excerpt":" STL Pair    first, second를 필드로 가짐 컨테이너의 요소 하나에 두개의 데이터가 저장이 필요할 때 사용한다.      헤더 추가하기    #include &lt;utility&gt; using namespace std;       pair를 요소로 가지는 vector 선언    vector &lt; pair&lt;int, int&gt; &gt; vt;       make pair로 만든 pair를 vector에 추가하기    vt.push_back(make_pair(1,3)); vt.push_back(make_pair(3,1)); vt.push_back(make_pair(2,2));       sort는 동일하게 함    sort(vt.begin(), vt.end());     ","categories": [],
        "tags": ["STL"],
        "url": "/STL-pair-vector/",
        "teaser": null
      },{
        "title": "STL priority queue",
        "excerpt":" STL priority queue    Max heap, Min heap이 필요할 때      헤더 추가하기    #include &lt;queue&gt; using namespace std;       Min heap 변수 선언    priority_queue &lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;  priority_queue&lt;string, vector&lt;string&gt;, greater&lt;string&gt; &gt;pq;  priority_queue&lt; pair&lt;int, int&gt;, vector&lt; pair&lt;int, int&gt; &gt;, greater&lt; pair&lt;int, int&gt; &gt; &gt;pq;     pair는 first를 기준으로 정렬된다.       Max heap 변수 선언    priority_queue &lt; int, vector&lt;int&gt;, less&lt;int&gt; &gt; pq;  priority_queue&lt;string, vector&lt;string&gt;, less&lt;string&gt; &gt;pq;       우선순위큐 empty 될 때까지 loop     while( ! pq.empty() ) {     int cost = pq.top().first;     int num = pq.top.second;     pq.pop();      ...     ...     pq.push(make_pair(x, y)); }     ","categories": [],
        "tags": ["STL"],
        "url": "/STL-priority-queue/",
        "teaser": null
      },{
        "title": "STL vector 이용",
        "excerpt":" STL Vector    동적 배열 형태로 사용함. 이번에 정리해서 매번 찾아보지 말자. -_-     헤더 추가하기    #include &lt;vector&gt; using namespace std;       1차원 int 배열 초기화    vector&lt;int&gt; v = {1, 2, 3, 4, 5};       int 배열을 loop 하면서 push back으로 추가    원래 하던 방식       int 배열을 받아서 vector 초기화    vector &lt;int &gt; vt(a, a + sizeof(a)/sizeof(int));       1차원 int 배열 iteration    for(vector&lt;int&gt;::iterator iter = vt.begin();iter != vt.end();iter++) {      cout &lt;&lt; *iter &lt;&lt; endl; }       3*3 2차원 배열 형태로 접근하기    vector&lt; vector&lt;int&gt; &gt; a(3, vector&lt;int&gt;(3));     이차원 배열 쓰듯, 접근이 가능함    int cnt; for(int i=0;i&lt;3;i++) {     for(int j=0;j&lt;3;j++) {         a[i][j] = ++cnt;     } }       Reference    what-is-the-easiest-way-to-initialize-a-stdvector-with-hardcoded-element     ","categories": [],
        "tags": ["STL"],
        "url": "/stl-vector/",
        "teaser": null
      },{
        "title": "파인만의 공부하는 방법",
        "excerpt":" 파인만이 제시한 공부방법    배울 것의 제목을 적는다.  나의 언어로 설명하고, 적어본다.  써놓은 것을 살펴본다.  복잡하거나 혼란스러우면 다시 공부한다.  이해하기 쉽도록 다시 쓴다. 이 단계에서도 완전히 이해하지 못했다면, 다시 공부한다.       느낌    참 단순한 방법이다. 어린시절 선생님들에게 '쓰면서 공부하라'는 조언을 들었는데, 비슷한 변형이 아닐까? 어떤 개념을 익힌 후, 나의 언어로 설명할 수 있어야 한다는 것을 강조함. 어떤 개념의 이름을 아는 것과 그 개념 자제를 아는 것이 다름.      Reference    - 파인만의 기술     ","categories": [],
        "tags": ["life"],
        "url": "/feynman-study-technic/",
        "teaser": null
      },{
        "title": "Problem solving 토픽",
        "excerpt":" 주제별 분류     수학    GCD / LCM 구하기 에라토스테네스의 체      Array 이용     자료구조 구현    스택 큐 최소/최대 힙 리스트 해시테이블 이진트리 LCRS tree Binary Search Tree      비트마스크     Sorting    삽입정렬 선택정렬 버블정렬 머지정렬 퀵정렬 Partial Sort 기수정렬      String    strcmp, strcpy 구현 KMP 알고리즘 접미사 배열 접미사 트리 Trie Rabin Karp 아호 코라식      완전탐색 / Brute Force     Graph 알고리즘    DFS BFS 다익스트라 벨만 포드 플로이드 와샬      Minimum Spanning Tree    크루스컬 알고리즘 프림 알고리즘      Topological Sort    indegree를 이용하는 방법 dfs를 이용하는 방법      Greedy Method     이분탐색    Lower bound / Upper bound Parametric Search      Dynamic Programing    동전교환 문제 가짓수 동전교환 문제 최소 동전수 LIS를 DP로 구현 + 경로 출력 LIS를 lower bound로 구현 + 경로 출력 기업투자 문제를 DP로 구현 + 선택 내용 출력 0/1 knapsack DP 구현 + 선택 내용 출력 LCS 최소 비용 이동(left and down방향) 가장 긴 연속적으로 증가하는 부분 수열 (LIS와 다름)      트리 알고리즘    트리를 표현하는 방법 트리의 탐색(전위/중위/후위) 트리의 지름 구하기 LCA (최소 공통 조상 구하기)      Union Find     Index Tree     Segment Tree     시뮬레이션 문제들      참고자료    Topcoder tutorial E-Maxx Algorithms in English Introductory tutorials for competitive programming    ","categories": [],
        "tags": ["ProblemSolving"],
        "url": "/ps-study-list/",
        "teaser": null
      },{
        "title": "STL queue 이용",
        "excerpt":" STL queue    맨 뒤에 데이터를 추가하고, 맨 앞에서 데이터를 꺼내는 자료구조    #include &lt;iostream&gt; #include &lt;queue&gt;  using namespace std;  int main(int argc, char *argv[]) {     queue&lt; int &gt; q;      q.push(1); // &#47592; &#46244;&#50640; &#45936;&#51060;&#53552; &#52628;&#44032;     q.push(2);     q.push(3);     q.push(4);     q.push(5);      // &#50526;&#50640;&#49436; 3&#44060; &#44732;&#45236;&#49436;, &#47592; &#46244;&#47196; &#52264;&#47168;&#45824;&#47196; push&#54616;&#44592;     int cnt = 3;     while(cnt-- &amp;&amp; !q.empty()) {         int cur = q.front();  // &#47592; &#50526;&#50640;&#49436; &#45936;&#51060;&#53552; &#44032;&#51256;&#50724;&#44592;         q.pop();              // &#47592; &#50526; &#45936;&#51060;&#53552; queue&#50640;&#49436; &#51228;&#44144;         q.push(cur);          // queue&#51032; &#47592; &#46244;&#50640; &#52628;&#44032;     }      // queue&#50640;&#49436; &#54616;&#45208;&#50473; &#44732;&#45236;&#49436; &#52636;&#47141;&#54616;&#44592;     while(!q.empty()) {         int cur = q.front();         cout &lt;&lt; cur &lt;&lt; endl;         q.pop();     }     return 0; }     ","categories": [],
        "tags": ["STL"],
        "url": "/STL-queue/",
        "teaser": null
      },{
        "title": "STL map 이용",
        "excerpt":" STL map    unique key를 이용한 key-value pair기반 정렬된 연관 컨테이너이다. Map은 일반적으로  red-black tree로 구현된다.       이용하기    map객체에 key, data를 추가하면, key를 기반으로 정렬된다는 의미 key가 string이라면 사전순 정렬이 된다. tree 구조를 표현하기 유리할 듯 싶다.      예제 코드1 : int를 key로, string을 가지는 객체의 map    #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std;  int main(int argc, char* argv[]) {     // int&#47484; key&#47196;, string&#51012; &#44032;&#51648;&#45716; map &#44061;&#52404; &#49440;&#50616;     map &lt;int, string&gt; m;        // 3&#44060;&#51032; &#45936;&#51060;&#53552;&#47484; &#52628;&#44032;     m.insert(make_pair(1, \"aaa\"));     m.insert(make_pair(2, \"bbb\"));     m.insert(make_pair(3, \"ccc\"));      // loop&#47484; &#46028;&#47732;&#49436;, &#52636;&#47141;     for(map&lt;int, string&gt;::iterator it = m.begin();it!=m.end();it++) {         cout &lt;&lt; it-&gt;second &lt;&lt;endl;     }     cout &lt;&lt; \"-----\" &lt;&lt; endl;      // &#48176;&#50676; &#54805;&#53468;&#47196; &#51217;&#44540;&#54616;&#47732;&#49436;, &#45236;&#50857; &#48320;&#44221;     m[1] = \"AAA\";     m[2] = \"BBB\";     m[3] = \"CCC\";      // loop&#47484; &#46028;&#47732;&#49436;, &#52636;&#47141;     for(map&lt;int, string&gt;::iterator it = m.begin();it!=m.end();it++) {         cout &lt;&lt; it-&gt;second &lt;&lt;endl;     }     return 0; }       Reference    https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/    ","categories": [],
        "tags": ["STL"],
        "url": "/using-STL-map/",
        "teaser": null
      },{
        "title": "불한당 나쁜 놈들의 세상",
        "excerpt":"배신과 배신을 거듭하는 스토리가 나온다.   배우 전혜진이 무척 크게 보이는 영화.  ","categories": ["culture"],
        "tags": [],
        "url": "/culture/%EB%82%98%EC%81%9C%EB%86%88%EB%93%A4%EC%9D%98%EC%84%B8%EC%83%81/",
        "teaser": null
      },{
        "title": "NEERC input/output file 테스트하기",
        "excerpt":"script로 NEERC 문제 input/output test하기   NEERC는 문제에 대한 input/output file을 제공한다. 다음처럼 script를 이용하면, 손쉽게 pass/fail을 테스트할 수 있다.   #!/bin/bash  ./code &lt; tests/disktree.01 | diff ./tests/disktree.01a - ./code &lt; tests/disktree.02 | diff ./tests/disktree.02a - ./code &lt; tests/disktree.03 | diff ./tests/disktree.03a - ./code &lt; tests/disktree.04 | diff ./tests/disktree.04a - ./code &lt; tests/disktree.05 | diff ./tests/disktree.05a - ./code &lt; tests/disktree.06 | diff ./tests/disktree.06a - ./code &lt; tests/disktree.07 | diff ./tests/disktree.07a - ./code &lt; tests/disktree.08 | diff ./tests/disktree.08a - ./code &lt; tests/disktree.09 | diff ./tests/disktree.09a - ./code &lt; tests/disktree.10 | diff ./tests/disktree.10a -   Reference  https://neerc.ifmo.ru/archive/2000.html  ","categories": ["ProblemSolving"],
        "tags": [],
        "url": "/problemsolving/neerc-sample-test/",
        "teaser": null
      },{
        "title": "영어듣기 자료 + 자막",
        "excerpt":" Youtube    PBS news - 자막 있음 공부하기 좋다. ABC Prime - 1시간 길이의 영어 뉴스 TED ed - 5분 분량 자막 좋음 CNBC Explains - 자막 있음, 주로 비즈니스 Bob the canadian      Podcast    NBC Nightly News ABC World News Meet The Press Good Morning Seoul VOA IE Up First    ","categories": [],
        "tags": ["English"],
        "url": "/english-news/",
        "teaser": null
      },{
        "title": "Input font 설치하기",
        "excerpt":" https://input.fontbureau.com/download/ 에서 다운로드 받아서 설치한다.     sudo find . -name *.ttf -exec cp {} /usr/share/fonts -rf \\; fc-cache -f    조금 더 써봐야겠다. Inconsolata보다 깔끔해보이지 않는다.    ","categories": [],
        "tags": ["font"],
        "url": "/Input-font-on-linux/",
        "teaser": null
      },{
        "title": "Vim28 설치하기",
        "excerpt":" Setting up    sudo add-apt-repository ppa:jonathonf/vim sudo apt update sudo apt install vim sudo apt-get install vim vi ~/.bashrc source ~/.bashrc    Append this line to .bashrc    export VIMRUNTIME=/usr/share/vim/vim82               a b c    hello world table        Reference    http://ubuntuhandbook.org/index.php/2019/12/install-vim-8-2-ubuntu-18-04-16-04-19-10/ https://askubuntu.com/questions/445686/vim-cannot-find-syntax-vim    ","categories": [],
        "tags": ["vim"],
        "url": "/setup-vim28/",
        "teaser": null
      },{
        "title": "Emacs26 설치",
        "excerpt":" Setting up    sudo add-apt-repository ppa:kelleyk/emacs sudo apt update sudo apt install emacs26      Reinstalling Packages     emacs 설치된 패키지 upgrade  -M package-list RET  'U' 입력 -&gt; 'x' 실행       Emacs26을 기본으로 선택하게 하기     $ sudo update-alternatives --config emacs ... Press &lt;enter&gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/bin/emacs26 to provide /usr/bin/emacs (emacs) in manual mode $ emacs --version GNU Emacs 26.3 Copyright (C) 2019 Free Software Foundation, Inc. GNU Emacs comes with ABSOLUTELY NO WARRANTY. You may redistribute copies of GNU Emacs under the terms of the GNU General Public License. For more information about these matters, see the file named COPYING.        Reference    http://ubuntuhandbook.org/index.php/2019/02/install-gnu-emacs-26-1-ubuntu-18-04-16-04-18-10/      더 할일    emacs26이 emacs가 되도록 하기    ","categories": [],
        "tags": ["Emacs"],
        "url": "/emacs26-install/",
        "teaser": null
      },{
        "title": "English Expressions",
        "excerpt":"basic expressions                  KOR       ENG                       한글       Hello          ","categories": [],
        "tags": ["English"],
        "url": "/eng-expr/",
        "teaser": null
      },{
        "title": "20년 영어듣기",
        "excerpt":" Oct     5 things that help me avoid procrastination    https://www.youtube.com/watch?v=cRpQOXV2cFg     Developers vs. App Store: Apple's Fights, Explained | WSJ    https://www.youtube.com/watch?v=JZXWf65yhGM     3 Big Mistakes in Your English Listening | Go Natural English    https://www.youtube.com/watch?v=BlCBnY3Y-jw     Winter Is Coming: Restaurant Owners Worry About Business Impact | WSJ    https://www.youtube.com/watch?v=HZDROyavRwg&amp;t=69s     Who is leading in renewable ennergy? | CNBC Explains    https://www.youtube.com/watch?v=fyqDC_AKVgE     Why Tech Firms Flock to Expensive Cities | WSJ    https://www.youtube.com/watch?v=50vRNNGqlp4     ","categories": [],
        "tags": ["StudyEnglish"],
        "url": "/English-Listening/",
        "teaser": null
      },{
        "title": "text file의 홀수 행만 출력하기",
        "excerpt":"홀수행만 출력하기   sed -n 1~2p ~/test2.txt   짝수행만 출력하기   sed -n 2~2p ~/test2.txt   Reference  Link  ","categories": [],
        "tags": ["bash"],
        "url": "/bash-print-even-lines/",
        "teaser": null
      },{
        "title": "Luke English Podcast",
        "excerpt":" Luke English Podcast     특징    괞찮은 영어 포드캐스트 찾음 podcast, web, mp3등으로 들을 수 있고, 대본을 많이 제공함. 유료 구독 프로그램 있고, 저렴한 편      Episods link    https://teacherluke.co.uk/archive-of-episodes-1-149/ http://teacherluke.co.uk/episodes-with-transcripts/     ","categories": [],
        "tags": ["StudyEnglish"],
        "url": "/Luke-English-Pod/",
        "teaser": null
      },{
        "title": "The Tim Ferris Show Pod",
        "excerpt":" The Tim Ferris Show - Podcast     특징    전세계적으로 유명한 Podcast 방송 Podcast, Web, mp3로 들을 수 있음 pdf로 된 대본을 구할 수 있음      Transcrips    https://tim.blog/2018/09/20/all-transcripts-from-the-tim-ferriss-show/     ","categories": [],
        "tags": ["StudyEnglish"],
        "url": "/Tim-Ferris-Pod/",
        "teaser": null
      },{
        "title": "Plain English Pod",
        "excerpt":" PLAIN ENLIGSH - Podcast     특징    듣기, 쉐도잉에 좋은 자료를 제공함, 공부하기 좋다. Podcast, Web, mp3로 들을 수 있음 빠른 속도 mp3도 제공하는데, 유료구독에 한함 pod로 전체 episods 들을 수 있는 듯      Transcrips    회원가입후, 대본 볼 수 있음. 느린 속도 재생 mp3 다운가능     ","categories": [],
        "tags": ["StudyEnglish"],
        "url": "/Plain-English-Pod/",
        "teaser": null
      },{
        "title": "FRONTLINE",
        "excerpt":" PBS FRONTLINE - Podcast     특징    Podcast, youtube, web으로 들을 수 있음 pod로 전체 episods 들을 수 있는 듯      Transcrips    https://www.pbs.org/wgbh/frontline/film/ 각 메뉴에 들어가면 대본이 있음     ","categories": [],
        "tags": ["StudyEnglish"],
        "url": "/FrontLine-Pbs-Pod/",
        "teaser": null
      },{
        "title": "대본이 제공되는 Podcast",
        "excerpt":" 대본이 있는 포드캐스트     CNN New - Transcript - Erin Burnett    podcast와 1일의 차이가 날 수 있음을 고려할 것 http://transcripts.cnn.com/TRANSCRIPTS/2010/06/ebo.01.html     Play FM에서 제공하는 링크 참고, 매번 변경되는 듯    https://player.fm/podcasts/Transcript     ThisAmericanLife    https://www.thisamericanlife.org/587/transcript     StoryCops Org    https://storycorps.org     NPR Weekend edition    https://www.npr.org/transcripts/795660984      99percentinvisible    https://99percentinvisible.org/episode/ten-thousand-years/transcript/     Science-VS    https://gimletmedia.com/shows/science-vs/o2hx57/sleep-all-aboard-the-snooze-cruise https://gimletmedia.com/shows/science-vs/6nh2zlk/sharks-sink-your-teeth-in-again       References    https://soenglish.me/learn-english-podcasts/    ","categories": [],
        "tags": ["StudyEnglish"],
        "url": "/Podcast-With-Transcripts/",
        "teaser": null
      },{
        "title": "Emacs Deft 설치",
        "excerpt":" Emacs Deft 설치    https://github.com/jrblevin/deft    설치하라는대로 하면 된다.     F8j을 눌러서, orgmode를 편집할 수 있다.     검색기능이 있다는 것이 편리      F8로 키맵하고 directory 지정하기    ; Deft (global-set-key [f8] 'deft) (setq deft-extensions '(\"org\")) (setq deft-directory \"XXXXXXX/work/github/YYYYYYYY/_org_posts/_posts\") (setq deft-recursive t)           참고자료    https://zaiste.net/courses/emacs-doom/emacs-doom-23-deft-emacs/    ","categories": [],
        "tags": ["Emacs","Deft"],
        "url": "/Deft-Emacs/",
        "teaser": null
      },{
        "title": "Space Vim 설치",
        "excerpt":" SpaceVim 설치     SpaceVim 설치 명령어    curl -sLf https://spacevim.org/install.sh | bash    vim하면 실행된다.     vim, nvim 모두 설치된 환경에서 nvim에만 설치하기    curl -sLf https://spacevim.org/install.sh | bash -s -- --install neovim      SpaceVim 지우기    원래 있던 vim으로 연결해준다.    curl -sLf https://spacevim.org/install.sh | bash -s -- --uninstall      환경설정 파일 위치    ~/.SpaceVim.d/init.toml     내 config example    # All SpaceVim option below [option] section [options]     # set spacevim theme. by default colorscheme layer is not loaded,     # if you want to use more colorscheme, please load the colorscheme     # layer    colorscheme = \"codedark\"     #colorscheme = \"gruvbox\"     # colorscheme = \"onedark\"     colorscheme_bg = \"dark\"     # Disable guicolors in basic mode, many terminal do not support 24bit     # true colors     enable_guicolors = true     # Disable statusline separator, if you want to use other value, please     # install nerd fonts     statusline_separator = \"arrow\"     statusline_inactive_separator = \"arrow\"     buffer_index_type = 4     enable_tabline_filetype_icon = true     enable_statusline_mode = false  [[custom_plugins]]   name=\"tomasiser/vim-code-dark\"   merged = 0 # Enable autocomplete layer [[layers]]   name = 'autocomplete'   auto_completion_return_key_behavior = \"complete\"   auto_completion_tab_key_behavior = \"smart\"  [[layers]]   name = 'shell'   default_position = 'top'   default_height = 30  [[layers]]   name = 'fzf' #name = 'denite'  [[layers]]   name = 'gtags'  [[layers]]   name = 'tmux'  [[layers]]   name = \"lang#c\"   enable_clang_syntax_highlight = true       Referene    https://spacevim.org/quick-start-guide https://velog.io/@ausg/monsters-use-vim     ","categories": [],
        "tags": ["SpaceVim"],
        "url": "/Space-Vim-Install/",
        "teaser": null
      },{
        "title": "AdeptEnglish Pod",
        "excerpt":" Adept English pod    https://adeptenglish.com/downloads/     특징    영국영어 엑센트 느낌이다. pod로 전체 episods 들을 수 있는 듯      Transcrips    대본을 pdf로 제공함     ","categories": [],
        "tags": ["StudyEnglish"],
        "url": "/AdeptEnglish/",
        "teaser": null
      },{
        "title": "BOJ 2138 전구와 스위치",
        "excerpt":" BOJ 2138 전구와 스위치    N개의 스위치로 N개의 전구의 on/off상태를 조정해서 목적 state로 갈 수 있는지 확인 스위치를 최소 몇번 눌러야 하나      접근하기    1. 맨처음 상태를 누르지 않고 시작    -&gt; cnt = 0;    -&gt; for(int i=1 ...) 모두 진행하기  2. 맨처음 상태를 누르고 시작 (0번을 누르면, 1번도 같이 눌림, -1번은 없으니 무시)    -&gt; cnt = 1    -&gt; a[-1] ^= 1;   // -1은 범위가 아님 제외    -&gt; a[0] ^= 1;    -&gt; a[1] ^= 1;    -&gt; for(int i=1 ...) 모두 진행하기  case 1만 성공 -&gt; 1cnt 출력 case 2만 성공 -&gt; 2cnt 출력 둘다 성공     -&gt; min(1cnt, 2cnt) 둘다 실패     -&gt; -1출력      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N;  char astr[100010]; int a0[100010]; int a1[100010];  char bstr[100010]; int b0[100010];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     scanf(\"%s\", astr);         scanf(\"%s\", bstr);          int i;     for(i=0;i&lt;N;i++) {         a0[i] = astr[i] - '0';         a1[i] = astr[i] - '0';          b0[i] = bstr[i] - '0';     }      // a0     // 0&#48264; &#49828;&#50948;&#52824; &#45572;&#47492;     a0[0] ^= 1;     a0[1] ^= 1;     // &#45572;&#47492;&#51060;&#48064;&#47196; 1&#47196; &#49884;&#51089;     int a0cnt = 1;     for(int i=1;i&lt;N;i++) {         if (a0[i-1] != b0[i-1]) {             if (i-1 &gt;= 0) a0[i-1] ^= 1;             a0[i] ^= 1;             if (i+1 &lt; N) a0[i+1] ^= 1;             a0cnt += 1;         }     }          // a1     int a1cnt = 0;     for(int i=1;i&lt;N;i++) {         if (a1[i-1] != b0[i-1]) {             if (i-1 &gt;= 0) a1[i-1] ^= 1;             a1[i] ^= 1;             if (i+1 &lt; N) a1[i+1] ^= 1;             a1cnt += 1;         }     }          bool same0 = true;     for(int i=0;i&lt;N;i++) {         if (a0[i] != b0[i]) {             same0 = false;             break;         }      }      bool same1 = true;     for(int i=0;i&lt;N;i++) {         if (a1[i] != b0[i]) {             same1 = false;             break;         }      }     if (!same0 &amp;&amp; !same1) {         printf(\"-1\\n\");     } else if (same0 &amp;&amp; !same1) {         printf(\"%d\\n\", a0cnt);     } else if (same1 &amp;&amp; !same0) {         printf(\"%d\\n\", a1cnt);     } else {         printf(\"%d\\n\", min(a0cnt, a1cnt));     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/2138    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-2138/",
        "teaser": null
      },{
        "title": "hello.py 인터프리터에서 실행하기",
        "excerpt":" 예제    exec(open('hello.py').read()) 'Hello World!'      참고자료    https://realpython.com/run-python-scripts/    ","categories": ["python"],
        "tags": [],
        "url": "/python/run-hello-py-on-interpreter/",
        "teaser": null
      },{
        "title": "permutation을 구하는 코드",
        "excerpt":" permutation 구하기    3개의 공이 있을 때, 순서를 섞기    1, 2, 3이 있다면, 6가지 경우가 생긴다. (3x2x1)    1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1      코드 예제    #include &lt;stdio.h&gt;  int N; int a[11]; int b[11]; int visit[11];  void f(int k) {     if (k == N) {         for(int i=0;i&lt;N;i++) {             printf(\"%d \", b[i]);         }         printf(\"\\n\");         return;     }      for(int i=0;i&lt;N;i++) {         if (visit[i] == 0) {             visit[i] = 1;             b[k] = a[i];             f(k+1);             visit[i] = 0;         }     } }  void solve() {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     f(0); }     ","categories": [],
        "tags": ["coding"],
        "url": "/perm-code/",
        "teaser": null
      },{
        "title": "bit shift 예제",
        "excerpt":" bit shift 예제    왼쪽으로 시프트 : 2를 곱하는 효과    &gt;&gt;&gt; 1 &lt;&lt; 0 1 &gt;&gt;&gt; 1 &lt;&lt; 1 2 &gt;&gt;&gt; 1 &lt;&lt; 2 4 &gt;&gt;&gt; 1 &lt;&lt; 3 8     오른쪽으로 shift : 2로 나누는 효과    &gt;&gt;&gt; 10 &gt;&gt; 1 5 &gt;&gt;&gt; 5 &gt;&gt; 1 2 &gt;&gt;&gt; 2 &gt;&gt; 1 1 &gt;&gt;&gt; 1 &gt;&gt; 1 0       알파벳 A,B,C,D를 bit로 mapping하기    1 &lt;&lt; (ch - 'A')     작은 bit부서 순서대로 set된다.    A : 1 &lt;&lt; ( 'A' - 'A')  =  1 &lt;&lt; 0  =  1  =  0001 B : 1 &lt;&lt; ( 'B' - 'A')  =  1 &lt;&lt; 1  =  2  =  0010 C : 1 &lt;&lt; ( 'C' - 'A')  =  1 &lt;&lt; 2  =  4  =  0100 D : 1 &lt;&lt; ( 'D' - 'A')  =  1 &lt;&lt; 3  =  8  =  1000    ","categories": [],
        "tags": ["coding"],
        "url": "/bit-shift-example/",
        "teaser": null
      },{
        "title": "STL set",
        "excerpt":" STL set    데이터의 중복없이, 순서대로 정렬되어 저장하는 자료구조 Red Black tree 기반      예제    #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;set&gt; using namespace std;  int main(int argc, char* argv[]) {     set &lt;int&gt; s;      //for(int i=1;i&lt;=10;i++)     s.insert(1);     s.insert(1);     s.insert(2);     s.insert(2);     s.insert(3);     s.insert(3);      for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++) {         cout &lt;&lt; *it &lt;&lt; endl;     }     return 0; }     ","categories": [],
        "tags": ["STL"],
        "url": "/stl-set/",
        "teaser": null
      },{
        "title": "C - One More aab aba baa",
        "excerpt":" C - One More aab aba baa    string을 순열로 나열했을 때, K번째를 구하는 문제 STL의 next_permutation으로도 구할 수 있음    sort를 해야 한다는 생각이 잘 안떠올랐던 문제       코드    #include &lt;stdio.h&gt;  char t[10]; char s[10]; int N; int len; int cnt; int table[26];  void f(int k) {     if (cnt &gt; N) return;     if (k == len) {         if (cnt++ == N) {             for(int i=0;i&lt;len;i++) {                 printf(\"%c\", t[i]);             }             printf(\"\\n\");         }         return;     }       for(int i=0;i&lt;26;i++) {         if (table[i]) {             table[i]--;             t[k] = 'a' + i;             f(k+1);             table[i]++;         }     } }  int main(int argc, char* argv[]) {     cnt = 1;     scanf(\"%s %d\", s, &amp;N);     for(len=0;s[len];len++) {         int idx = s[len] - 'a';         table[idx]++;     }     f(0);      return 0; }       문제 링크    https://atcoder.jp/contests/abc215/tasks/abc215_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc215-c-upsolve/",
        "teaser": null
      },{
        "title": "D - Coprime 2",
        "excerpt":" D - Coprime 2    작성중      용어    서로소(coprime integers) GCD(x, y) = 1 의미는 x, y는 공약수(a common divisor)가 없다. 소인수분해 (prime factorization, factorization in prime factors) 인수분해 (factorization) 소인수 (prime factor)      Prime Factorization (소인수분해)    12 = 2 x 2 x 3      접근하기    GCD(x, y) = 1은 서로 소인 수를 의미함  GCD(x, y) != 1 은 X를 소인수분해 했을 때, 배수가 있음을 의미  룩업 배열에 인수와 그 배수를 check해주고, 1~M까지 loop에서 남아있는 수를 고르면 된다.   a[x] = GCD(A[i], x) != 1       풀이    #include &lt;iostream&gt; using namespace std;  #define ARR_SIZE 100010  int N, M;  int a[ARR_SIZE]; int fact[ARR_SIZE]; int fidx;  int out[ARR_SIZE]; int idx;  void pfact(int num) {     for(int i=2;i*i&lt;=num;i++) {         while(num%i==0) {             num /= i;             fact[fidx++] = i;         }     }       if (num != 1)         fact[fidx++] = num; }  int main(int argc, char* argv[]) {     cin &gt;&gt; N &gt;&gt; M;     for(int i=0;i&lt;ARR_SIZE;i++) a[i] = 1;      for(int i=0;i&lt;N;i++) {         int num;         cin &gt;&gt; num;          fidx = 0;         pfact(num);         for(int j=0;j&lt;fidx;j++) {             if(a[fact[j]]) {                 for(int k=fact[j];k&lt;ARR_SIZE;k+=fact[j]) {                     a[k] = 0;                 }             }         }     }      for(int i=1;i&lt;=M;i++) {         if (a[i]) out[idx++] = i;             }          cout &lt;&lt; idx &lt;&lt; endl;     for(int i=0;i&lt;idx;i++) {         cout &lt;&lt; out[i] &lt;&lt; endl;     }     return 0; }       문제 링크/참고자료    https://atcoder.jp/contests/abc215/tasks/abc215_d https://blog.hamayanhamayan.com/entry/2021/08/21/233514    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc215-d-upsolve/",
        "teaser": null
      },{
        "title": "E - Chain Contestant",
        "excerpt":" TODO E - Chain Contestant    작성중 Bit DP를 익히고 다시 볼 것      문제 링크    https://atcoder.jp/contests/abc215/tasks/abc215_e       참고자료    비트필드와 완전 탐색 최적화 (Bit DP) Bit DP란? 비트마스크(BitMask) 는 무엇인가?      문제모음    Bitmask+DP 문제집    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc215-e/",
        "teaser": null
      },{
        "title": "A. Way Too Long Word",
        "excerpt":" A. A. Way Too Long Words    긴 문자열만 골라서 축약형 문자열을 만드는 문제 Let's consider a word too long, if its length is strictly more than 10 characters.   10이 넘는 경우만 줄인다. (10을 포함하지 않음)       문제 링크    https://codeforces.com/problemset/problem/71/A    ","categories": [],
        "tags": ["CodeForces"],
        "url": "/cf-71a/",
        "teaser": null
      },{
        "title": "OrgMode Tips 정리",
        "excerpt":" orgmode 마크업     underscore 뒤 문자가 작아지는 문제    옵션을 추가해주면 된다.    #+OPTIONS: ^:nil      C++ 소스코드 추가    &lt;s 후 TAB 입력 cpp       Jekyll github운영     Jekyll에서 org mode로 page 생성하기    C-c C-e P p      #  (Publish -&gt; Current Project)      ","categories": [],
        "tags": ["orgmode"],
        "url": "/orgmode-tips/",
        "teaser": null
      },{
        "title": "vim에서 C++14 파일 compile",
        "excerpt":" 사용법    .vimrc에 다음 라인을 넣어준다. ,bb를 누르면, 빌드를 함   map ,bb &lt;ESC&gt;:!g++ -o %:r % -std=c++1y &lt;CR&gt;       의미    %가 파일이름 전체를 의미함 %:r이 extension을 제외한 파일 이름을 의미함 code.cpp가 %이면, %:r은 code가 된다.      c.vim에서 C_CFlags 변경    std=c++14를 붙여줘도 동일한 효과가 난다. (더 편리한 듯) F9를 눌러서 실행   let s:C_CFlags                = '-Wall -g -O0 -c -std=c++14'      \" compiler flags: compile, don't optimize    ","categories": [],
        "tags": ["vim"],
        "url": "/vim-cpp14-execution/",
        "teaser": null
      },{
        "title": "BOJ 2309 일곱 난쟁이",
        "excerpt":" 일곱 난쟁이    bit를 이용한 power set을 이용해서 반복함 완전탐색으로 조합순서를 만들기 가능  가지치기를 적용해볼 수 있음  sum - 100이 되도록 두 수를 찾아도 됨      bitmask 이용 powerset    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int a[9]; int b[9];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     for(int i=0;i&lt;9;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+9);     for(int i=0;i&lt;(1&lt;&lt;9);i++) {          int sum = 0;         int cnt = 0;         for(int j=0;j&lt;9;j++) {             if (i &amp; (1&lt;&lt;j)) {                 sum += a[j];                  cnt += 1;             }         }          if (cnt == 7 &amp;&amp; sum == 100) {             for(int j=0;j&lt;9;j++) {                 if (i &amp; (1&lt;&lt;j)) {                     printf(\"%d\\n\", a[j]);                 }             }             goto exit;         }     }  exit:      return 0; }       완전탐색 + quicksort 구현    #include &lt;cstdio&gt;  int a[9]; int b[9]; int visit[9];  int ans = 0;  int partition(int a[], int left, int right) {         int pivot = left;         int i = left-1;         int j = right+1;          while(1)         {                 do {                         i++;                 } while (a[i] &lt; a[pivot]);                  do {                         j--;                 } while (a[j] &gt; a[pivot]);                  if (i&gt;=j)       return j;                  int t = a[i];                 a[i] = a[j];                 a[j] = t;         }         return j; }  void quicksort(int a[], int left, int right) {         if (left &lt; right) {                 int p = partition(a, left, right);                 quicksort(a, left, p);                 quicksort(a, p+1, right);         } }  int bt(int k, int sum) {         if ( ans ) return 0;         if ( sum &gt; 100) return 0;         if (7 == k) {                 if (sum == 100) {                         quicksort(b, 0, 6);                         for(int i=0; i&lt;7;i++) {                                 printf(\"%d\\n\", b[i]);                         }                         ans = 1;                 }                 return 0;         }          for(int i=0;i&lt;9;i++) {                 if (visit[i] == 0) {                         visit[i] = 1;                         b[k] = a[i];                         bt(k+1, sum+a[i]);                         visit[i] = 0;                  }         }         return 0; }  int main(int argc, char* argv[]) {         for(int i=0;i&lt;9;i++) {                 scanf(\"%d\", &amp;a[i]);         }         bt(0, 0);         return 0; }      powerset이용 bactracking + bound이용 최적화    powerset을 구하는 bactracking코드 100보다 크면 제외하기 앞으로 나올값과 현재값을 더했을때 100이 될 가능성이 없으면 제외    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int a[9]; int b[9]; int run;  void f(int idx, int sum, int remaining, int cnt) {     if (run == 0) return;     if (sum &gt; 100) return;  // 100&#48372;&#45796; &#53356;&#47732;, &#51228;&#50808;     if (sum + remaining &lt; 100) return;   // &#54788;&#51116; + &#50526;&#51004;&#47196; &#44032;&#45733;&#54620; &#44050;&#51060; 100&#48372;&#45796; &#51089;&#51004;&#47732; &#51228;&#50808;      if (idx == 9) {         if (cnt == 7 &amp;&amp; sum == 100) {             sort(b, b+9);             for(int i=0;i&lt;9;i++) {                 if (b[i]) printf(\"%d\\n\", b[i]);             }             run = 0;         }         return;     }      b[idx] = 0;     f(idx+1, sum, remaining, cnt);      b[idx] = a[idx];     f(idx+1, sum + a[idx], remaining - a[idx], cnt + 1); }  int main(int argc, char* argv[]) {     int sum = 0;     for(int i=0;i&lt;9;i++) {         scanf(\"%d\", &amp;a[i]);         sum += a[i];     }      run = 1;     f(0, 0, sum, 0);     return 0; }      TODO 두수를 뺐을 때, 100이 되게하는 목록 만들기    이중 loop에서 두 숫자 x, y를 구함 sum - x - y == 100이면, 전체 목록에서 x, y를 제거하고 출력하기      TODO sort하고, 두 수를 찾기    두수의 합이 sum - 100이 되도록 하는 두 수 찾기 알고리즘 이름이 뭐였더라?      참고자료    비트마스크(BitMask) 는 무엇인가?      문제 링크    https://www.acmicpc.net/problem/2309    ","categories": [],
        "tags": ["완전탐색","Bitmask"],
        "url": "/boj-2309/",
        "teaser": null
      },{
        "title": "카운팅소트",
        "excerpt":" 카운팅 소트    0, 양의 정수만으로 이뤄진 수를 정렬할 때 이용 가능 O(N) 수들이 특정 범위 안에 좁게 몰려 있을 때 좋다.      코드    #include &lt;iostream&gt; #include &lt;cstdio&gt; using namespace std;  int N;  int a[1010];   // 1000&#44620;&#51648;&#51032; &#48176;&#50676; int b[10010];  // &#44050;&#51032; &#48276;&#50948;&#44032; 0 ~ 10000&#44620;&#51648; int c[1010];  int main(int argc, char* argv[]) {     cin &gt;&gt; N;      int maxv = 0;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; a[i];         if (maxv &lt; a[i]) maxv = a[i];         b[a[i]]++;  // &#47337;&#50629;&#48176;&#50676;&#50640; &#52852;&#50868;&#54021;     }      for(int i=1;i&lt;=maxv;i++) {          b[i] += b[i-1];  // &#45572;&#51201;&#54633;     }      for(int i=0;i&lt;N;i++) { // c&#48176;&#50676;&#50640; &#51221;&#47148;&#54644;&#49436; &#45812;&#44592;         c[b[a[i]]] = a[i];         b[a[i]] -= 1;     }      for(int i=1;i&lt;=N;i++) {         cout &lt;&lt; c[i] &lt;&lt; \" \";     }     cout &lt;&lt; endl;     return 0; }     ","categories": [],
        "tags": ["정렬"],
        "url": "/counting-sort/",
        "teaser": null
      },{
        "title": "알고리즘 읽을 거리",
        "excerpt":"라이 마법의 수퍼마리오     완전탐색   빅오표기법   비트마스킹   구간합 배열   이분탐색   동적계획법 DP   그리디   투포인터,슬라이딩 윈도우   다익스트라   플로이드와샬   밸만포드   최소스패닝트리 MST   위상정렬   오일러경로, 오일러회로   강한 연결요소   이중 연결요소   유니온 파인드   세그먼트 트리   트리   이진검색트리   희소테이블  ","categories": [],
        "tags": ["PS"],
        "url": "/ps-bookmarks/",
        "teaser": null
      },{
        "title": "C - Distribution",
        "excerpt":" C - Distribution    원에 N개의 Snuke가 위치하고, t시간 간격에 이동조건이 주어질 때, gem을 첫번째로 받는 시간을 출력하는 문제  원을 N*2만큼 회전해보면서, 생각하기      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N; int s[200010]; long long t[200010]; long long a[200010];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;s[i]);     }      for(int i=0;i&lt;N;i++) {         scanf(\"%lld\", &amp;t[i]);     }      a[0] = t[0];     for(int i=0;i&lt;N*2;i++) {         a[i%N] = min(a[(i-1)%N] + s[(i-1)%N], t[i%N]);     }      for(int i=0;i&lt;N;i++) {         printf(\"%lld\\n\", a[i]);     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc215/tasks/abc214_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc124-c-upsolving/",
        "teaser": null
      },{
        "title": "D - Sum of Maximum Weights",
        "excerpt":" D - Sum of Maximum Weights     접근하기    Union Find에서 연결된 집합의 크기를 count할 수 있어야 함  배열을 하나 더 선언해서 count하는 방법 Weighted Union Find를 이용하는 방법     3 1 2 10 2 3 20    f(1,2) = 10 f(2,3) = 20 f(1,3) = 20 : 10 -&gt; 20이면 가장 큰 값을 고름  문제 나온 수학식의 의미 : 모든 쌍을 다 찾아보라   for(int i=1;i&lt;=N-1) {     for(int j=i+1;j&lt;=N;j++) {          f(i, j);     } }       코드 - Weighted Union Find를 이용하기    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N;  typedef struct Node {     int u;     int v;     int w; } Node; Node pool[200020];  int p[200020];  int Find(int num) {     if(p[num] &lt; 0) return num;     return p[num] = Find(p[num]); }  void Union(int a, int b) {     a = Find(a);     b = Find(b);      if (a == b) return;      if (p[a] &lt;= p[b]) {         p[a] += p[b];             p[b] = a;     } else {         p[b] += p[a];             p[a] = b;     } }  bool cmp(Node&amp; p1, Node&amp; p2) {     return (p1.w &lt; p2.w); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;=N;i++) p[i] = -1;      for(register int i=0;i&lt;N-1;i++) {         scanf(\"%d %d %d\", &amp;pool[i].u, &amp;pool[i].v, &amp;pool[i].w);     }     sort(pool, pool+(N-1), cmp);      long long ans = 0;     for(register int i=0;i&lt;N-1;i++) {         ans += (long long)pool[i].w * p[Find(pool[i].u)] * p[Find(pool[i].v)];         Union(pool[i].u, pool[i].v);     }     printf(\"%lld\\n\", ans);     return 0; }        문제 링크/참고자료    https://atcoder.jp/contests/abc214/tasks/abc214_d Weighted Union Find    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc214-d-upsolve/",
        "teaser": null
      },{
        "title": "BOJ 1717 집합의 표현",
        "excerpt":" 집합의 표현    집합을 합치는 연산을 어떻게 처리하는지 보기      문제 링크    https://www.acmicpc.net/problem/1717    문제에 주어진 입력을 Weighted Union Find로 구현.       설명    # 1-3-6-7 연결이 Path compression 됨 # 4-2 연결  5: p[1] = -4   # 1번은 자신 포함 4개 -&gt; root 노드 6: p[2] = 4    # 2번의 부모는 4 7: p[3] = 1    # 3번의 부모는 1 8: p[4] = -2   # 4번은 자신 포함 2개 -&gt; root 노드 9: p[5] = -1   # 자식노드가 없는 혼자df 10: p[6] = 7   # 6번의 부모는 7 11: p[7] = 1   # 7번의 부모는 1   첫번째 집합의 크기는 4  [R] (1) --- (7)      \\     \\      (3)    (6)  두번째 집합의 크기는 2   [R] (4) - (2)       코드    #include &lt;stdio.h&gt;  int N, M; int p[1000010];  int Find(int a) {     // p[a]&#44032; &#51020;&#49688;&#51060;&#47732;, a&#45716; root&#45432;&#46300;&#51076;     // &#51020;&#49688;&#44032; &#51665;&#54633;&#51032; &#45432;&#46300; &#44060;&#49688;&#47484; &#51032;&#48120;&#54632;     if (p[a] &lt; 0) return a;     return p[a] = Find(p[a]); // path compression }  void Union(int a, int b) {     a = Find(a);         b = Find(b);          if (a == b) return;      if (p[a] &lt;= p[b]) { // &#51089;&#51008; &#44050;&#51012; &#48512;&#47784;&#47196; &#50732;&#47548;         p[a] += p[b];   // &#51089;&#51008; &#44050;&#51008; &#51088;&#49885; &#45432;&#46300;&#51032; &#44060;&#49688;&#47484; &#45572;&#51201;         p[b] = a;     } else {         p[b] += p[a];         p[a] = b;     } }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      // &#52488;&#44592;&#44050;&#51012; -1&#47196; &#51648;&#51221;     for(int i=0;i&lt;=N;i++) {         p[i] = -1;     }      int cmd, a, b;     for(int i=0;i&lt;M;i++) {         scanf(\"%d %d %d\", &amp;cmd, &amp;a, &amp;b);         if (cmd == 0) {             Union(a, b);         } else if (cmd == 1) {             if (Find(a) == Find(b)){                 printf(\"YES\\n\");             } else {                 printf(\"NO\\n\");             }         }     }     return 0; }       참고자료    유니온 파인드 Ries - Union Find    ","categories": [],
        "tags": ["UnionFind"],
        "url": "/boj-1717/",
        "teaser": null
      },{
        "title": "공작",
        "excerpt":"목표했던 바를 이루기 위해 10년을 기다리고,   리명운과 박석영 두 사람의 만남이 참 감동적으로 보였던 영화   ","categories": ["culture"],
        "tags": [],
        "url": "/culture/%EC%98%81%ED%99%94-%EA%B3%B5%EC%9E%91/",
        "teaser": null
      },{
        "title": "D - Cutting Woods",
        "excerpt":" D - Cutting Woods    큰 통나무가 있고, query를 통해 통나무를 자른다. 자른 통나무 조각의 길이를 잰다.      접근하기    STL set을 이용해서 풀이 set에 int를 insert하면, 정렬된 상태로 저장됨. upper_bound를 이용해서 x보다 큰 가장 가까운 값의 위치를 얻을 수 있음      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;set&gt; using namespace std;  int L, Q;  int main(int argc, char* argv[]) {     set&lt;int&gt; st;     scanf(\"%d %d\", &amp;L, &amp;Q);     st.insert(0);            // 0&#51012; &#52628;&#44032;     st.insert(L);            // L&#51012; &#52628;&#44032; -&gt; L - 0&#51008; &#51204;&#52404;&#51032; &#44600;&#51060;&#44032; &#46108;&#45796;.      int c, x;     for(int i=0;i&lt;Q;i++) {         scanf(\"%d %d\", &amp;c, &amp;x);          if (c == 1) {             st.insert(x);    // &#51221;&#47148;&#46108; &#49692;&#49436;&#47196; &#52628;&#44032;         } else if (c == 2) {             auto i = st.upper_bound(x);  // x&#48372;&#45796; &#53360; &#52395;&#48264;&#51705; &#44050;&#51032; &#50948;&#52824;&#47484; &#44396;&#54632;             int up = *i;             i--;             int down = *i;             printf(\"%d\\n\", up - down);         }     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc217/tasks/abc217_d    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc217-d/",
        "teaser": null
      },{
        "title": "E - Sorting Query",
        "excerpt":" E - Sorting Query    1 x : A에 맨 뒤에 x추가 2 A에서 맨앞 노드 출력 3 Sort A 동작      접근하기    우선순위 queue와 deque를 이용해서 풀이 deque로 맨 앞노드를 출력하는데, sort가 된 이후에는 우선순위Q에서 값을 출력 그 사이 1번 명령이 오면, deque에만 추가해도 된다.      코드    #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std;  int N; int a[200010]; // deque&#47484; &#48176;&#50676;&#47196; &#44396;&#54788;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int num;     int cmd;     int tmp;     int front, rear;     front = rear = 0;      priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; // &#50864;&#49440;&#49692;&#50948;Q     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;cmd);          if (cmd == 1) {             scanf(\"%d\", &amp;num);             a[rear++] = num;   // deque &#47592;&#46244;&#50640; &#52628;&#44032;         } else if (cmd == 2) {             if (!pq.empty()) {   // &#51060;&#51204;&#50640; sort&#44032; &#46104;&#50632;&#45796;&#47732;,                 tmp = pq.top();  // pq&#50640;&#49436; &#45936;&#51060;&#53552; &#52636;&#47141;                 pq.pop();             } else {                 tmp = a[front++]; // &#51060;&#51204;&#50640; sort&#44032; &#50504;&#46104;&#50632;&#45796;&#47732;, deque&#50640;&#49436; &#45936;&#51060;&#53552; &#52636;&#47141;             }             printf(\"%d\\n\", tmp);         } else if (cmd == 3) {             for(int i=front;i&lt;rear;i++) {  // sort&#49884; deque&#51032; &#45236;&#50857;&#51012; &#47784;&#46160; pq&#50640; &#51060;&#46041;&#49884;&#53416;&#45796;.                 pq.push(a[i]);             }             front = rear = 0;         }     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc217/tasks/abc217_e      생각    Editorial에서는 STL multiset을 이용해서 풀이함    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc217-e/",
        "teaser": null
      },{
        "title": "Nvim 설치하기",
        "excerpt":" NeoVim    기존 vim에서 비동기 처리가 잘 된다고 함 그래서 써보기로 함      config 파일의 위치    ~/.config/nvim/init.vim   기존의 gvim config와 같은 모양으로 쓸 수 있다.      TODO C++ 개발환경 구축    Modern C++ development in (Neo)vim    ","categories": [],
        "tags": ["nvim"],
        "url": "/nvim-config/",
        "teaser": null
      },{
        "title": "C - Many Balls",
        "excerpt":" C - Many Balls    N개의 공을 빈 상자에 규칙에 따라 넣을 때, 하나의 경우를 찍으면 되는 문제      접근    2로 나눈 나머지가 0이면 B추가 아니면 N에서 1빼기 마지막에 역순으로 출력      코드    #include &lt;cstdio&gt; using namespace std;  long long N; char a[2000]; int idx; int run;  int main(int argc, char* argv[]) {     idx = 0;     scanf(\"%lld\", &amp;N);     while(N) {         if (N%2 == 0) {             a[idx++] = 'B';             N = N / 2;         } else {             a[idx++] = 'A';             N = N - 1;         }     }      for(int i=idx-1;i&gt;=0;i--) {         printf(\"%c\", a[i]);     }     printf(\"\\n\");     return 0; }       문제 링크/참고자료    https://atcoder.jp/contests/abc214/tasks/abc216_c AtCoder Beginner Contest 216 Announcement    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc-216-upsolving/",
        "teaser": null
      },{
        "title": "abc206 C - Swappable",
        "excerpt":" C - Swappable     접근하기    1~N까지는 N*(N-1)/2개의 쌍이 있다는 점에 착안 중복을 제거한다. 중복을 세는 방법을 생각하기      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  long long N; int a[300010]; long long d[300010];  int main(int argc, char* argv[]) {     scanf(\"%lld\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+N);     for(int i=0;i&lt;N;i++) d[i] = 1;      for(int i=1;i&lt;N;i++) {         if (a[i] == a[i-1]) {             d[i] = d[i-1] + 1;         }     }     long long ans = (long long)(N*(N-1))/2;     for(int i=N-1;i&gt;0;) {         ans -= (d[i]*(d[i]-1))/2;         i -= d[i];     }     printf(\"%lld\\n\", ans);     return 0; }       문제 링크    https://atcoder.jp/contests/abc206/tasks/abc206_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc206-c-upsolving/",
        "teaser": null
      },{
        "title": "abc207 C - Many Segments",
        "excerpt":" C - Many Segments     접근하기    l, r 중에서 r로 sort함 구간이 서로 겹치는 곳을 찾아서 count하기      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N;  typedef struct Node {     int p1;     int on1;     int p2;     int on2; } Node;  Node pool[2020];  bool comp(Node&amp; before, Node&amp; after) {     return (before.p2 - after.p2) &lt; 0; }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      int cmd, p1, p2;     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d %d\",&amp;cmd, &amp;p1, &amp;p2);         pool[i].p1 = p1;          pool[i].p2 = p2;          switch(cmd)         {         case 1:             pool[i].on1 = 1;              pool[i].on2 = 1;              break;         case 2:             pool[i].on1 = 1;              pool[i].on2 = 0;              break;         case 3:             pool[i].on1 = 0;              pool[i].on2 = 1;              break;         case 4:             pool[i].on1 = 0;              pool[i].on2 = 0;              break;         }     }     sort(pool, pool+N, comp);      int ans = 0;     for(int i=0;i&lt;N;i++) {         for(int j=i+1;j&lt;N;j++) {             if (i == j) continue;             if (pool[i].p2 &gt; pool[j].p1) {                 ans++;             } else if (pool[i].p2 == pool[j].p1 &amp;&amp; pool[i].on2 == 1 &amp;&amp; pool[j].on1 == 1) {                 ans++;             }         }     }     printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://atcoder.jp/contests/abc207/tasks/abc207_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc207-c-upsolving/",
        "teaser": null
      },{
        "title": "C - Fair Candy Distribution",
        "excerpt":" C - Fair Candy Distribution     접근하기    나눈 몫은 모두에게 주고, 나머지만큼 loop를 돌면서 count함 sort를 두가지 방식으로 필요함      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N; long long K;  typedef struct Node {     int num;     int idx;     long long ans; } Node;  Node a[200010];  bool comp1(Node&amp; p1, Node&amp; p2) {     return (p1.num - p2.num) &lt; 0; }  bool comp2(Node&amp; p1, Node&amp; p2) {     return (p1.idx - p2.idx) &lt; 0; }  int main(int argc, char* argv[]) {     scanf(\"%d %lld\", &amp;N, &amp;K);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i].num);         a[i].idx = i;     }     sort(a, a+N, comp1);     long long all = K/N;     for(int i=0;i&lt;K%N;i++) {         a[i].ans += 1;     }      sort(a, a+N, comp2);     for(int i=0;i&lt;N;i++) {         printf(\"%lld\\n\", a[i].ans + all);     }      return 0; }       문제 링크    https://atcoder.jp/contests/abc208/tasks/abc208_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc208-c-upsolving/",
        "teaser": null
      },{
        "title": "C - Not Equal",
        "excerpt":" C - Not Equal     접근하기    정렬한 후 곱하면, 답이 되는 규칙을 찾음   4 0 1 2 3 3 3 4 4  3 * 2 * 2 * 1 = 12      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #define MOD 1000000007 using namespace std;  int N; int a[200010];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }      sort(a, a+N);     long long cnt = 1;     for(int i=0;i&lt;N;i++) {         cnt *= (a[i]-i) % MOD;         cnt = cnt % MOD;     }     printf(\"%lld\\n\", cnt);     return 0; }       문제 링크    https://atcoder.jp/contests/abc209/tasks/abc209_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc209-c-upsolving/",
        "teaser": null
      },{
        "title": "STL binary search",
        "excerpt":" STL binary search    배열의 시작 위치, 배열의 크기, 찾으려는 값을 순서대로 넣는다.      예제 - int 배열    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int a[] = { 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; int N; int main(int argc, char* argv[]) {     N = sizeof(a) / sizeof(a[0]);     sort(a, a+N);      if (binary_search(a, a+N, 8)) {         printf(\"8 found\\n\");     } else {         printf(\"8 not found\\n\");     }      return 0; }       예제 - 구조체 배열에서 cmp함수 추가    typedef struct Node {     int y;     int x; } Node;  Node a[2020];  bool comp2(Node p1, Node p2) {     return (p1.y &lt; p2.y); }  int main(int argc, char* argv[]) { // ...     int cond1 = binary_search(a, a+N, tmp, comp2); // ...       참고자료    https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/    ","categories": [],
        "tags": ["STL"],
        "url": "/STL-binary-search/",
        "teaser": null
      },{
        "title": "E - Destruction",
        "excerpt":" D - Destruction    undirected graph가 주어졌을 때, edge를 삭제하면, edge의 가중치만큼을 보상받거나 벌금을 낼 때, Graph의 모든 vertex가 연결되면서, 최대의 보상을 받도록 edge를 삭제했을 때, 얼마의 보상을 받는지 구하는 문제      TODO 접근하기    Minimum Spanning Tree를 이용해서 푸는 문제      코드           문제 링크    https://atcoder.jp/contests/abc218/tasks/abc218_e    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc-e-upsolving/",
        "teaser": null
      },{
        "title": "C - Shapes",
        "excerpt":" C - Shapes    S map, T map을 주고 그 안에 #으로 이뤄진 도형을 줌 90도씩 회전했을때, S와 T가 같은지 판단하는 문제      접근하기    N의 범위가 작으므로, 완전탐색으로 해볼 수 있다. #의 개수를 세었을 때, 개수가 다르면 다른 도형 S도형은 그대로, T도형은 90, 180, 270, 360으로 회전해서 비교 처음 위치가 다를 수 있는데, offset만큼을 이동해서 비교한다.  offset이 양수, 음수와 무관하게 거리를 나타낸다.       코드    #include &lt;cstdio&gt;  #define ARR_SIZE 201  int N;  char S[ARR_SIZE][ARR_SIZE]; char T[ARR_SIZE][ARR_SIZE]; char tmp[ARR_SIZE][ARR_SIZE]; char str[ARR_SIZE];  void rot90(char map[][ARR_SIZE], char tmp[][ARR_SIZE]) {     for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;N;j++) {             tmp[j][N-i-1] = map[i][j];         }     }      for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;N;j++) {             map[i][j] = tmp[i][j];         }     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      // S map     int cnt1 = 0;     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             S[i][j] = str[j];             if (S[i][j] == '#') cnt1++;         }     }      // T map     int cnt2 = 0;     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             T[i][j] = str[j];             if (T[i][j] == '#') cnt2++;         }     }      if (cnt1 != cnt2) {         printf(\"No\\n\");         return 0;     }      int stop_x, stop_y;     int ttop_x, ttop_y;      stop_x = 0, stop_y = 0;      ttop_x = 0, ttop_y = 0;      for(int i=0;i&lt;4;i++) {          rot90(T, tmp);          // get top left         for(int j=0;j&lt;N;j++) {             for(int k=0;k&lt;N;k++) {                 if (S[j][k] == '#') {                     stop_y = j;                     stop_x = k;                     break;                 }             }         }          // get top left         for(int j=0;j&lt;N;j++) {             for(int k=0;k&lt;N;k++) {                 if (T[j][k] == '#') {                     ttop_y = j;                     ttop_x = k;                     break;                 }             }         }          int offset_y = ttop_y - stop_y;         int offset_x = ttop_x - stop_x;          bool found = true;         for(int j=0;j&lt;N;j++) {             for(int k=0;k&lt;N;k++) {                 if (j + offset_y &gt;= 0 &amp;&amp; j + offset_y &lt; N &amp;&amp; k + offset_x &gt;= 0 &amp;&amp; k + offset_x &lt; N) {                     if (S[j][k] != T[j + offset_y][k + offset_x]) {                         found = false;                         break;                     }                 }             }         }         if (found) {             printf(\"Yes\\n\");             return 0;         }     }         printf(\"No\\n\");     return 0; }       문제 링크    https://atcoder.jp/contests/abc218/tasks/abc218_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc218-c-upsolving/",
        "teaser": null
      },{
        "title": "D - Rectangles",
        "excerpt":" D - Rectangles    조건에 맞는 사각형의 개수를 구하는 문제      접근하기    사각형의 성질을 알아야 풀 수 있는 문제 N &lt;= 2000이므로, 2000*2000=40000000, 4백만으로 이중 for loop까지는 가능할 것. Editorial에서는 sort 후 binsearch를 통해 최적화함      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N;  typedef struct Node {     int y;     int x; } Node;  Node a[2020];  bool comp(Node&amp; p1, Node&amp; p2) // sort&#50640; &#49324;&#50857;&#46104;&#45716; compare {     if (p1.x == p2.x)     {         return (p1.y &lt; p2.y);     } else {         return (p1.x &lt; p2.x);     } }  bool comp2(Node p1, Node p2) // binary search&#50640; &#49324;&#50857;&#46104;&#45716; compare {     if (p1.x == p2.x)     {         return (p1.y &lt; p2.y);     } else {         return (p1.x &lt; p2.x);     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;a[i].x, &amp;a[i].y);     }     sort(a, a+N, comp);      int cnt = 0;     for(int i=0;i&lt;N;i++) {         for(int j=i+1;j&lt;N;j++) {             if (a[i].x &lt; a[j].x &amp;&amp; a[i].y &lt; a[j].y) {                 Node tmp1;                 tmp1.x = a[i].x;                 tmp1.y = a[j].y;                 bool cond1 = binary_search(a, a+N, tmp1, comp2);                  Node tmp2;                 tmp2.x = a[j].x;                 tmp2.y = a[i].y;                 bool cond2 = binary_search(a, a+N, tmp2, comp2);                  if (cond1 &amp;&amp; cond2)                     cnt++;             }         }     }     printf(\"%d\\n\", cnt);     return 0; }     181ms 걸림      TODO 최적 풀이 분석    20ms 이내의 최적 풀이가 있음      주의할 점    STL pair를 쓰지 않을 때, compare함수가 first, second값을 모두 compare해줘야 한다.      문제 링크    https://atcoder.jp/contests/abc218/tasks/abc218_d    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc218-d-upsolving/",
        "teaser": null
      },{
        "title": "E - Destruction",
        "excerpt":" E - Destruction    undirected graph가 주어졌을 때, edge를 지우면서, 그 가중치를 얻을 수 있음 큰 가중치를 지워야 하고, 작은 가중치는 연결해야 함. 음수의 가중치는 무조건 연결해야 함 (이게 안보였던 조건)      접근하기    모든 가중치를 처음에 더해서 sum에 저장 Minimum Spanning Tree를 약간 변경해서 풀이  Union Find와 크루스컬 알고리즘을 이용함  음수 가중치는 무조건 연결하고, 양수 가중치는 작은 순서로 추가  sort하고, 진행함       코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N, M; #define ARR_SIZE 200020 int parent[ARR_SIZE];  typedef struct Node {     int s;     int e;     int cost; } Node;  Node a[ARR_SIZE];  bool comp(Node&amp; p1, Node&amp; p2) {     return (p1.cost - p2.cost) &lt; 0;  }  int find(int num) {     if (num == parent[num])         return num;      else         return parent[num] = find(parent[num]); }  void unite(int n1, int n2) {     int num1 = find(n1);     int num2 = find(n2);      if (num1 != num2) {         if (num1 &gt; num2) {             parent[num1] = n2;         } else {             parent[num2] = n1;         }     } }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      for(int i=0;i&lt;=N;i++) {         parent[i] = i;     }      int s, e, cost;     long long sum = 0;     for(int i=0;i&lt;M;i++) {         scanf(\"%d %d %d\", &amp;s, &amp;e, &amp;cost);         a[i].s = s;         a[i].e = e;         a[i].cost = cost;          sum += cost;     }     sort(a, a+M, comp);       for(int i=0;i&lt;M;i++) {         int n1 = find(a[i].s);         int n2 = find(a[i].e);         int v = a[i].cost;          if (v &lt;= 0) {// cost&#44032; &#51020;&#49688;&#51060;&#47732; &#47924;&#51312;&#44148; &#52628;&#44032;             unite(n1, n2);             sum = sum - v;         } else {// cost&#44032; &#50577;&#49688;&#51060;&#47732; Minimum Spanning Tree&#47196; &#52628;&#44032;             if (n1 != n2) {                 unite(n1, n2);                 sum = sum - v;             }         }     }     printf(\"%lld\\n\", sum);     return 0; }       문제 링크    https://atcoder.jp/contests/abc218/tasks/abc218_e      참고자료    라이 Minimum Spanning Tree    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc218-e-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 1922 네트워크 연결",
        "excerpt":" 네트워크 연결    Minimum spanning tree를 구현하는 문제       문제 링크    https://www.acmicpc.net/problem/1922      코드    크루스컬 알고리즘을 이용해서 구현함    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  typedef struct Node {     int value;     int start;     int end;      bool operator&lt;(const Node &amp; b) {         return value &lt; b.value;     } } Node;  Node pool[100010]; int V, E;  // Union find int parent[10010];  int find(int num) {     if (num == parent[num])         return num;     else         return parent[num] = find(parent[num]);  }  void unite(int n1, int n2) {     int num1 = find(n1);     int num2 = find(n2);      if (num1 &gt; num2) {         parent[num1] = n2;     } else {         parent[num2] = n1;     } }  int main(int argc, char *argv[]) {     scanf(\"%d %d\", &amp;V, &amp;E);      for(int i=1;i&lt;10001;i++) {         parent[i] = i;      }      for(int i=0;i&lt;E;i++) {         scanf(\"%d %d %d\", &amp;pool[i].start, &amp;pool[i].end, &amp;pool[i].value);     }      sort(pool, pool+E);      long long ans = 0;     for(int i=0;i&lt;E;i++) {         int n1 = find(pool[i].start);         int n2 = find(pool[i].end);         int v = pool[i].value;         if (n1 != n2) {             unite(n1, n2);             ans += v;         }      }     printf(\"%lld\\n\", ans);     return 0; }       참고자료    유니온 파인드 Ries - Union Find Ries - Minimum Spanning Tree    ","categories": [],
        "tags": ["MST","UnionFind"],
        "url": "/boj-1922/",
        "teaser": null
      },{
        "title": "SpaceVim에 todo.txt 설치",
        "excerpt":" 새로운 custom plugin 추가    custom plugins 섹션을 하나씩 추가하면 된다. vim을 다시 켜면, 자동으로 설치한다.   [[custom_plugins]]    name = \"tomasiser/vim-code-dark\"    merged = 0  [[custom_plugins]]    name = \"freitass/todo.txt-vim\"    merged = 0      keymapping을 적어주기    적어야 하는 파일 위치   .SpaceVim/init.vim     F12로 매핑   syntax on filetype plugin on  \" todo.txt let maplocalleader = \"\\\\\" map &lt;F12&gt; &lt;ESC&gt;:e ~/Dropbox/todo/todo.txt &lt;CR&gt;    ","categories": [],
        "tags": ["SpaceVim"],
        "url": "/space-vim-todo-txt/",
        "teaser": null
      },{
        "title": "D - Strange Lunchbox",
        "excerpt":" D - Strange Lunchbox    도시락을 골라야 하는데, 두가지 메뉴가 있음 X, Y로 원하는 개수를 주고, 그 이상을 먹을 수 있는 도시락의 수 구하기      접근하기    메뉴가 하나 있는, 도시락을 고르는 DP문제로 생각하고 확장      코드 - 3차원 dp로 풀기    dp[i][j][k] : i번째 도시락을 먹었을 때, 메뉴1은 j만큼, 메뉴2는 k만큼  dp[0][0][0] = 0   #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  #define INF 987654321  int N; int X, Y;  int a[301]; int b[301]; int dp[301][301][301];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     scanf(\"%d %d\", &amp;X, &amp;Y);      for(int i=1;i&lt;=N;i++) {         scanf(\"%d %d\", &amp;a[i], &amp;b[i]);     }      for(int k=0;k&lt;=300;k++) {         for(int i=0;i&lt;=300;i++) {             for(int j=0;j&lt;=300;j++) {                 dp[k][i][j] = INF;             }          }      }      dp[0][0][0] = 0;      for(int k=1;k&lt;=N;k++) {         for(int i=0;i&lt;=300;i++) {             for(int j=0;j&lt;=300;j++) {                 int x = min(i + a[k], X);                 int y = min(j + b[k], Y);                 dp[k][x][y] = min(dp[k][x][y], dp[k-1][i][j] + 1); // &#46020;&#49884;&#46973; &#44256;&#47492;                 dp[k][i][j] = min(dp[k][i][j], dp[k-1][i][j]);             }          }      }      int minv = INF;     for(int i = X; i&lt;=300; i++){         for(int j = Y; j&lt;=300; j++){             minv = min(minv,dp[N][i][j]);         }     }     if(minv &gt;= INF) {         printf(\"-1\\n\");     } else {         printf(\"%d\\n\", minv);     }     return 0; }        코드 - 2차원 dp로 풀기    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  #define INF 987654321  int N; int X, Y;  int a[301]; int b[301]; int dp[301][301];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     scanf(\"%d %d\", &amp;X, &amp;Y);      for(int i=1;i&lt;=N;i++) {         scanf(\"%d %d\", &amp;a[i], &amp;b[i]);     }      for(int i=0;i&lt;=300;i++) {         for(int j=0;j&lt;=300;j++) {             dp[i][j] = INF;         }      }       dp[0][0] = 0;     for(int k=1;k&lt;=N;k++) {         for(int i=X;i&gt;=0;i--) {             for(int j=Y;j&gt;=0;j--) {                 int x = min(i + a[k], X);                 int y = min(j + b[k], Y);                 dp[x][y] = min(dp[x][y], dp[i][j] + 1);             }          }      }      int minv = INF;     for(int i = X; i&lt;=300; i++){         for(int j = Y; j&lt;=300; j++){             minv = min(minv,dp[i][j]);         }     }     if(minv &gt;= INF) {         printf(\"-1\\n\");     } else {         printf(\"%d\\n\", minv);     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc219/tasks/abc219_d u2dayo 분석    ","categories": [],
        "tags": ["AtCoder","DP"],
        "url": "/abc219-d-upsolving/",
        "teaser": null
      },{
        "title": "C - chokudai",
        "excerpt":" C - chokudai     접근하기    경우의 수를 구하는 DP 문제    dp[i][j] : S의 i번째 문자까지 str = \"chokudai\"의 j번째 문자까지를 만드는 경우의 수  dp[i+1][j+1] = dp[i][j+1]       (S[i] != S[j]이면, i문자일 때, j번째 문자를 선택X)  dp[i+1][j+1] = dp[i][j+1] + dp[i][j];    (S[i] == S[j]이면, i문자일 때,        j문자를 선택X ==&gt; dp[i][j+1] 이전 문자에서의 경우의 수      j문자를 선택O ==&gt; j일 때의 경우의 수를 더해준다.)      코드    #include &lt;cstdio&gt;  using namespace std;  char str[100010]; int dp[100010][9];  const char* T = \"chokudai\"; const int MOD = 1000000007;  int main(int argc, char* argv[]) {     scanf(\"%s\", str);     int len = 0;     for(;str[len];len++) {         dp[len][0] = 1;      }      for(int i=0;i&lt;len;i++) {         for(int j=0;j&lt;8;j++) {             if (str[i] != T[j]) {                 dp[i+1][j+1] = dp[i][j+1];             } else {                 dp[i+1][j+1] = (dp[i][j+1] + dp[i][j]) % MOD;             }         }     }     printf(\"%d\\n\", dp[len][8]);     return 0; }        참고자료    경우의 수  합의 법칙 : 사건 A,B가 각각 일어날 경우의 수 곱의 법칙 : 사건 A,B가 동시에 일어날 경우의 수       문제 링크    https://atcoder.jp/contests/abc211/tasks/abc211_c    ","categories": [],
        "tags": ["AtCoder","DP"],
        "url": "/abc211-c-upsolving/",
        "teaser": null
      },{
        "title": "C - Neo-lexicographic Ordering",
        "excerpt":" C - Neo-lexicographic Ordering     접근하기    문자열을 사전순 정렬하는 문제 정렬의 순서를 위한 lookup table을 지정해준다.      코드    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  char X[26]; int N; string str[50010]; int table[26];  bool comp(string&amp; s1, string&amp; s2) {     const char* p1 = s1.c_str();      const char* p2 = s2.c_str();       while(*p1 != '\\0' &amp;&amp; *p1 == *p2) {         p1++;         p2++;      }      int v1 = (int)*p1 - 'a';     int v2 = (int)*p2 - 'a';     return (table[v1] - table[v2]) &lt; 0;  // &#44033; &#50508;&#54028;&#48307;&#48324; &#44032;&#51473;&#52824;&#50640;&#49436; &#48708;&#44368; }  int main(int argc, char* argv[]) {     scanf(\"%s\", X);     for(int i=0;i&lt;26;i++) {         table[X[i] - 'a'] = i + 1; // a ~ z&#53580;&#51060;&#48660; &#50948;&#52824;&#50640; &#44032;&#51473;&#52824;&#47484; &#44592;&#47197;     }      scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; str[i];     }      sort(str, str+N, comp);      for(int i=0;i&lt;N;i++) {         cout &lt;&lt; str[i] &lt;&lt; endl;     }      return 0; }       문제 링크    https://atcoder.jp/contests/abc219/tasks/abc219_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc219-c/",
        "teaser": null
      },{
        "title": "C - Reorder Cards",
        "excerpt":" C - Reorder Cards     접근하기    좌표압축을 묻는 문제 입력받은 W, H는 사용하지 않아도 됨      코드1 - STL vector, erase, unique를 이용한 좌표압축    #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt;  using namespace std;  int H, W, N;  int a[100010]; int b[100010];  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;H, &amp;W, &amp;N);      vector&lt;int&gt; va(N);      vector&lt;int&gt; vb(N);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);          scanf(\"%d\", &amp;b[i]);           va.push_back(a[i]);          vb.push_back(b[i]);      }      sort(va.begin(), va.end());     va.erase(unique(va.begin(), va.end()), va.end());      sort(vb.begin(), vb.end());     vb.erase(unique(vb.begin(), vb.end()), vb.end());      for(int i=0;i&lt;N;i++) {         int p1 = lower_bound(va.begin(), va.end(), a[i]) - va.begin();         int p2 = lower_bound(vb.begin(), vb.end(), b[i]) - vb.begin();         printf(\"%d %d\\n\", p1, p2);     }     return 0; }       코드2 - 구조체를 이용해서 풀이    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int H, W, N;  typedef struct Node {     int val;     int idx;     int val2; } Node;  Node a[100020]; Node b[100020];  bool cmp1(Node&amp; p1, Node&amp; p2) {     return (p1.val &lt; p2.val); }  bool cmp2(Node&amp; p1, Node&amp; p2) {     return (p1.idx &lt; p2.idx); }  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;H, &amp;W, &amp;N);      for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;a[i].val, &amp;b[i].val);         a[i].idx = i;         a[i].val2 = 0;          b[i].idx = i;         b[i].val2 = 0;     }      sort(a, a+N, cmp1);     int cnt = 1;     for(int i=0;i&lt;N;i++) {         if (i!=0 &amp;&amp; a[i-1].val == a[i].val) {             a[i].val2 = cnt-1;         } else {             a[i].val2 = cnt++;         }     }      sort(b, b+N, cmp1);     cnt = 1;     for(int i=0;i&lt;N;i++) {         if (i!=0 &amp;&amp; b[i-1].val == b[i].val) {             b[i].val2 = cnt - 1;         } else {             b[i].val2 = cnt++;         }     }      sort(a, a+N, cmp2);     sort(b, b+N, cmp2);     for(int i=0;i&lt;N;i++) {         printf(\"%d %d\\n\", a[i].val2, b[i].val2);     }     return 0; }      참고자료    좌표압축기법 좌표압축 설명      문제 링크    https://atcoder.jp/contests/abc213/tasks/abc213_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc213-c-upsolving/",
        "teaser": null
      },{
        "title": "D - Takahashi Tour",
        "excerpt":" D - Takahashi Tour     접근하기    DFS 순서로 방문, enter를 출력 leave하는 순서를 출력함      코드    #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int N; vector&lt; vector&lt;int&gt; &gt; G; // &#51064;&#51217;&#47532;&#49828;&#53944;&#47484; &#51060;&#50857;&#54620; graph  void dfs(int idx, int pre) {     printf(\"%d \", idx);  // enter&#54616;&#45716; &#44221;&#47196;&#47484; &#52636;&#47141;     for(int next:G[idx]) {         if (next != pre) {             dfs(next, idx);             printf(\"%d \", idx); // leave&#54616;&#45716; &#44221;&#47196;&#47484; &#52636;&#47141;         }     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     G.resize(N+1);      int p1, p2;     for(int i=0;i&lt;N-1;i++) {         scanf(\"%d %d\", &amp;p1, &amp;p2);         G[p1].push_back(p2);         G[p2].push_back(p1);     }      // &#49707;&#51088;&#44032; &#51089;&#51008; node&#48512;&#53552; &#48169;&#47928;&#54616;&#44172; &#54632;     for(int i=1;i&lt;=N;i++) {         sort(G[i].begin(), G[i].end());     }     dfs(1, 0);     printf(\"\\n\");     return 0; }       문제 링크    https://atcoder.jp/contests/abc213/tasks/abc213_d    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc213-d-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 18870 좌표압축",
        "excerpt":" BOJ 188770 좌표압축     접근하기    좌표압축을 묻는 문제      코드 1    mespace std; int N;  typedef struct Node {     int val;     int idx;     int val2; } Node;  Node pool[1000010];  bool compare(Node p1, Node p2) {     return (p1.val &lt; p2.val); }  bool compare2(Node p1, Node p2) {     return (p1.idx &lt; p2.idx); }  int main(int argc, char* argv[]) {     ios_base::sync_with_stdio(false);     cin.tie(NULL);      scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;pool[i].val);         pool[i].idx = i;         pool[i].val2 = 0;     }     sort(pool, pool+N, compare);      int cnt = 0;     for(int i=0;i&lt;N;i++) {         if (i != 0 &amp;&amp; pool[i-1].val == pool[i].val) {             pool[i].val2 = cnt-1;         } else {             pool[i].val2 = cnt++;         }     }     sort(pool, pool+N, compare2); // &#51077;&#47141;&#48155;&#51008; index&#49692;&#49436;&#47196; &#51221;&#47148;&#54632;     for(int i=0;i&lt;N;i++) {         printf(\"%d \", pool[i].val2);     }     printf(\"\\n\");     return 0; }       코드 2 - STL    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N; vector&lt;int&gt; a; vector&lt;int&gt; b;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      a.resize(N);     b.resize(N);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);         b[i] = a[i];     }      sort(a.begin(), a.end());     a.erase(unique(a.begin(), a.end()), a.end());       for(auto&amp; c : b) {         cout &lt;&lt; lower_bound(a.begin(), a.end(), c) - a.begin() &lt;&lt; \" \"; // index&#47484; &#50619;&#51012; &#49688; &#51080;&#51020;     }      cout &lt;&lt; endl;     return 0; }      참고자료    좌표압축기법 좌표압축 설명      문제 링크    https://www.acmicpc.net/problem/18870    ","categories": [],
        "tags": ["좌표압축"],
        "url": "/boj-18870/",
        "teaser": null
      },{
        "title": "C - Secret Number",
        "excerpt":" C - Secret Number     접근하기    0~9999까지 loop를 돌면서, 각 숫자를 체크 o가 4개 있으면, 그 숫자로만 써야 한다. 0이 포함되지 않으면, 모두 제외해준다.      코드    #include &lt;stdio.h&gt;  char str[11];  int main(int argc, char* argv[]) {     scanf(\"%s\", str);      int cnt = 0;     for(int i=0;i&lt;=9999;i++) {          unsigned int table = 0;         for(int j=0;str[j];j++) {             if (str[j] == 'o') {                 table |= (1 &lt;&lt; j);             }         }         // 0001&#52376;&#47100; &#50526;&#50640; 0&#51060; &#51080;&#51004;&#47732;, table&#50640;&#49436; &#47560;&#53356;         if (table &amp; (1&lt;&lt;0)) {             if (i &lt; 1000) table &amp;= ~(1 &lt;&lt; 0);         }          int num = i;          int bok = true;         while(num) {             int k = num%10;             if (str[k] == 'x') {                 bok = false;                 break;             } else if (str[k] == 'o') {                 table &amp;= ~(1 &lt;&lt; k);             }             num = num / 10;         }          if (table == 0 &amp;&amp; bok) {             if (str[0] == 'x') {                 if (i &gt;= 1000) {                     cnt += 1;                 }             } else {                 cnt += 1;             }         }     }     printf(\"%d\\n\", cnt);      return 0; }       문제 링크    https://atcoder.jp/contests/abc201/tasks/abc201_c    ","categories": [],
        "tags": ["AtCoder","완전탐색"],
        "url": "/abc201-c-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 2951 숫자카드",
        "excerpt":" 숫자카드    경우의 수를 구하는 DP 문제      접근하기    i번째 숫자에서 1자리 숫자를 고르면, dp[i-1]의 경우의 수를 더한다. i번재 숫자에서 2자리 숫자를 고른면, dp[i-2]의 경우의 수를 더한다. 두자리 숫자에서 10의 자리가 0이 되는 경우는 제외한다.      코드    #include &lt;stdio.h&gt;  char str[50]; int dp[50];  int main(int argc, char* argv[]) {     scanf(\"%s\", str + 1);      int len = 1;        for(;str[len];len++);     len -= 1;       str[0] = '0';     dp[0] = 1;       for(int i=1;i&lt;=len;i++) {          // &#54620;&#51088;&#47532; &#49707;&#51088;&#47484; &#49324;&#50857;&#54616;&#45716; &#44221;&#50864;         // 0&#51060; &#50500;&#45768;&#47732; 1~9&#44620;&#51648;&#51032; &#49707;&#51088;&#51076;         if (str[i] != '0') dp[i] += dp[i-1];          // &#46160;&#51088;&#47532; &#49707;&#51088;&#47484; &#49324;&#50857;&#54616;&#45716; &#44221;&#50864;         // 34&#48372;&#45796; &#51089;&#44256;, &#50526;&#51088;&#47532;&#49688;&#44032; 0&#51060; &#50500;&#45784;                int num = (str[i-1]-'0')*10 + (str[i]-'0');         if (num &lt;= 34 &amp;&amp; str[i-1] != '0') {             dp[i] += dp[i-2];         }     }     printf(\"%d\\n\", dp[len]);      return 0; }       문제 링크    https://www.acmicpc.net/problem/2591    ","categories": [],
        "tags": ["DP","경우의수"],
        "url": "/boj-2591/",
        "teaser": null
      },{
        "title": "abc221 C - Select Mul",
        "excerpt":" C - Select Mul     접근하기    최대 9자리 숫자 순열을 만들어서 모두 해볼 수 있다. 두 구간으로 나눔, left, right 숫자의 길이가 홀수이면, left쪽이 1자리수 더 길게 구성. 숫자의 길이가 짝수이면, left, right같게 구성.      코드    #include &lt;stdio.h&gt;  char str[10]; char a[10]; int visit[10]; int len;  long long ans;  void bt(int idx) {     if (idx == len) {         int mid = (len %2 == 0) ? len/2 : (len/2)+1;          long long num1 = 0;         for(int i=0;i&lt;mid;i++) {             num1 = num1 * 10 + (a[i] - '0');         }         long long num2 = 0;         for(int i=mid;i&lt;len;i++) {             num2 = num2 * 10 + (a[i] - '0');         }         if (ans &lt; num1 * num2) ans = num1 * num2;                     return;     }      for(int i=0;i&lt;len;i++) {         if (visit[i] == 0) {             visit[i] = 1;              a[idx] = str[i];             bt(idx+1);             visit[i] = 0;          }         } }  int main(int argc, char* argv[]) {     ans = 0;     scanf(\"%s\", str);     for(len=0;str[len];len++);      bt(0);     printf(\"%lld\\n\", ans);     return 0; }       문제 링크    https://atcoder.jp/contests/abc221/tasks/abc221_c    ","categories": [],
        "tags": ["AtCoder","완전탐색"],
        "url": "/abc221-c-upsolving/",
        "teaser": null
      },{
        "title": "abc202 C - Made Up",
        "excerpt":" C - Made Up     접근하기    N이 100000까지이고, Ai, Bi, Ci가 N보다 작거나 같다  lookup table을 쓸 수 있음  모든 값을 누적할 때, int범위를 넘을 수 있다.     코드    #include &lt;cstdio&gt;  int N;  int B[100010]; int C[100010]; int table[100000];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int a;     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a);             table[a] += 1;     }     for(int i=1;i&lt;=N;i++)         scanf(\"%d\", &amp;B[i]);         for(int i=1;i&lt;=N;i++)         scanf(\"%d\", &amp;C[i]);          long long cnt = 0;     for(int i=1;i&lt;=N;i++) {         cnt += table[B[C[i]]];     }     printf(\"%lld\\n\", cnt);     return 0; }       문제 링크    https://atcoder.jp/contests/abc202/tasks/abc202_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc202-c-upsolving/",
        "teaser": null
      },{
        "title": "abc203 C - Friends and Travel costs",
        "excerpt":" C - Friends and Travel cost    0번에서 K만큼의 돈을 가지고 이동 A번 노드에서 B만큼의 돈을 보충 가능 노드 하나 이동할 때, 1씩 비용 듬 얼마나 갈 수 있을까?      접근하기    0번에서 A번 노드까지의 거리보다 현재 가진돈이 많거나 같아야 이동 마지막 노드에 왔을때, 돈이 남았으면, 돈 만큼 더 이동 가능 하나의 노드에서 여러번 돈을 보충할 수 있는 것에 주의      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N, K;  typedef struct Node {     long long A;     long long B; } Node;  Node pool[200020];  bool cmp(Node&amp; p1, Node&amp; p2) {     return (p1.A &lt; p2.A); }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;K);      for(int i=0;i&lt;N;i++) {         scanf(\"%lld %lld\", &amp;pool[i].A, &amp;pool[i].B);     }     sort(pool, pool+N, cmp);      long long pos = 0;     long long coin = K;     for(int i=0;i&lt;N;i++) {         if (coin - (pool[i].A - pos) &gt;= 0) {             coin -= (pool[i].A - pos);             pos += (pool[i].A - pos);             coin += pool[i].B;         } else {             break;         }     }     printf(\"%lld\\n\", pos + coin);     return 0; }       문제 링크    https://atcoder.jp/contests/abc203/tasks/abc203_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc203-c-upsolving/",
        "teaser": null
      },{
        "title": "abc221 D - Online games",
        "excerpt":" D - Online games     접근하기    날자의 구간(시작, 끝)을 각각 주고, 겹치는 구간을 세서, 배열에 저장하는 방법 시작날자에 1로 표기, 마지막날+1에 -1로 표기하면, 구간 표시가 가능함 sort해서 1과 -1로 counter의 index를 이동하면서, 시작일의 차를 더하면, 사람수를 세는게 된다.     코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt;  using namespace std;  int N;  typedef struct Node {     int start;     int len; } Node;  Node pool[200010*2]; int d[200010];  bool cmp(Node&amp; p1, Node&amp; p2) {     if (p1.start == p2.start) {         return p1.len &lt; p2.len;     } else {         return p1.start &lt; p2.start;     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);       int idx = 0;     for(int i=0;i&lt;N;i++) {         int a, b;         scanf(\"%d %d\", &amp;a, &amp;b);         pool[idx].start = a;         pool[idx].len = 1;         idx++;          pool[idx].start = a + b;         pool[idx].len = -1;         idx++;     }     sort(pool, pool+idx, cmp);      int cnt = 0;     for(int i=0;i&lt;idx-1;i++) {         cnt += pool[i].len;         d[cnt] += (pool[i+1].start - pool[i].start);     }     for(int i=1;i&lt;=N;i++) {         printf(\"%d \", d[i]);     }      printf(\"\\n\");     return 0; }       문제 링크    https://atcoder.jp/contests/abc221/tasks/abc221_c    ","categories": [],
        "tags": ["AtCoder","Greedy"],
        "url": "/abc221-d-upsolving/",
        "teaser": null
      },{
        "title": "TODO E - LEQ",
        "excerpt":" TODO E - LEQ    Binary Index Tree/Segment Tree공부하고 다시 보기      접근하기    코드           문제 링크    https://atcoder.jp/contests/abc221/tasks/abc221_e    ","categories": [],
        "tags": ["AtCoder","SegmentTree","BinaryIndexTree"],
        "url": "/abc221-e-upsolving/",
        "teaser": null
      },{
        "title": "abc200 C - Ringo's Favorite Numbers 2",
        "excerpt":" C - Ringo's Favorite Numbers 2     접근하기    수학적으로 접근하는 문제. 생각이 어렵다.  A if and only if B  A가 참이면 B도 참이고, B가 참이면, A도 참이다. A와 B가 동일하다. (A와 B는 동치) A는 B의 필요충분조건      생각하기 1    Ai - Aj가 200의 배수이다. Ai를 200으로 나눈 나머지와 Aj를 200으로 나눈 나머지는 같다.      생각하기 2    8개의 원소가 있을 때, 2개를 선택하여 가지는 경우의 수   - 8*7/2 --&gt; k*(k-1)/2       코드    #include &lt;stdio.h&gt;  int N; long long a[210];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);         a[num%200] += 1;     }      long long ans = 0;     for(int i=0;i&lt;200;i++) {         ans += (a[i] * (a[i]-1))/2;     }     printf(\"%lld\\n\", ans);     return 0; }       문제 링크    https://atcoder.jp/contests/abc200/tasks/abc200_c      참고자료    경우의 수 - 순열과 조합 순열,조합 공식정리 if and only if의 의미    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc200-c-upsolving/",
        "teaser": null
      },{
        "title": "abc200 D - Happy Birthday! 2",
        "excerpt":" D - Happy Birthday! 2    N이 최대 200까지 B배열과 C배열을 A배열에서 분리해낸다.  배열의 크기가 다르거나, 값이 달라야 한다.  비둘기집 원리를 문제에 적용해야 함. 생각이 쉽지 않다.      TODO 접근하기    N &lt;= 8까지 해도, 2^8-1 =255 경우를 찾을 수 있다. 그 사이 답을 1개만 찾아서 출력하면 된다.   bit연산 or재귀로 2^N 완전탐색 구현 1인 목록의 sum을 구하고 200으로 나머지셈 위치에 저장 (Hash table) 이후에 sum을 구해서 %200한 hash의 위치에 값이 있으면 출력하고, 자신도 출력      코드 - 완전탐색 이용    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int N; int n; int a[210]; int b[12]; int bend;  vector &lt; vector&lt;int&gt; &gt; v(200, vector&lt;int&gt;(0));  void bt(int idx) {     if (bend) return;      if (idx &gt;= n) {         int sum = 0;         vector &lt;int&gt; tmp;         for(int i=0;i&lt;n;i++) {             if(b[i]) {                 sum += a[i];                 sum = sum % 200;                 tmp.push_back(i+1);             }         }           if (v[sum].size() == 0) {             v[sum] = tmp;         } else {             printf(\"Yes\\n\");             cout &lt;&lt; tmp.size();             for(auto &amp;x : tmp) {                 cout &lt;&lt; \" \" &lt;&lt; x;             }             cout &lt;&lt; endl;              cout &lt;&lt; v[sum].size();             for(auto &amp;x : v[sum]) {                 cout &lt;&lt; \" \" &lt;&lt; x;             }             cout &lt;&lt; endl;             bend = 1;         }         return;     }      b[idx] = 0;     bt(idx+1);      b[idx] = 1;     bt(idx+1); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }      n = min(8, N);      bt(0);     if (bend == 0)         printf(\"No\\n\");     return 0; }       코드 - 비트연산 이용    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int N; int n; int a[210];  vector &lt; vector&lt;int&gt; &gt; v(200, vector&lt;int&gt;(0));  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }      n = min(8, N);       for(int i=1;i&lt;(1&lt;&lt;n);i++) {          int sum = 0;         vector &lt;int&gt; tmp;         for(int j=0;j&lt;n;j++) {             if (i &amp; (1&lt;&lt;j)) {                 sum += a[j];                 sum = sum % 200;                 tmp.push_back(j+1);             }             }          if (v[sum].size() == 0) {             v[sum] = tmp;         } else {             printf(\"Yes\\n\");             cout &lt;&lt; tmp.size();             for(auto &amp;x : tmp) {                 cout &lt;&lt; \" \" &lt;&lt; x;             }             cout &lt;&lt; endl;              cout &lt;&lt; v[sum].size();             for(auto &amp;x : v[sum]) {                 cout &lt;&lt; \" \" &lt;&lt; x;             }             cout &lt;&lt; endl;             return 0;          }     }     printf(\"No\\n\");     return 0; }      문제 링크    https://atcoder.jp/contests/abc200/tasks/abc200_d    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc200-d-upsolving/",
        "teaser": null
      },{
        "title": "TODO abc200 E - Patisserie ABC 2",
        "excerpt":" TODO E - Patisserie ABC 2     접근하기     코드           문제 링크    https://atcoder.jp/contests/abc200/tasks/abc200_e    ","categories": [],
        "tags": ["AtCoder","DP","TODO"],
        "url": "/abc200-e-upsolving/",
        "teaser": null
      },{
        "title": "동적계획법 문제 모음",
        "excerpt":" 동적계획법 문제 link    solved.ac dp 푼사람수 기준 LeetCode DP BOJ 역대 DP 연습셋 기출문제    ","categories": [],
        "tags": ["Bookmarks"],
        "url": "/dp-problem-links/",
        "teaser": null
      },{
        "title": "BOJ 2156 포도주 시식",
        "excerpt":" BOJ 2156 포도주 시식    세잔 연속 마실 수 없음 한잔 마시고, 건너뛰거나, 두잔 마시고 건너뛰기 두잔 연속 안마실 수 있음 (안보이는 조건)      접근하기     코드 - dp[i]    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N; int a[10010]; int dp[10010];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }      dp[0] = 0;     dp[1] = a[1];     dp[2] = a[1] + a[2];      for(int i=3;i&lt;=N;i++) {         dp[i] = max(dp[i], dp[i-2] + a[i]); // i&#48264;&#51704; &#54620;&#48264; &#47560;&#49900;         dp[i] = max(dp[i], dp[i-3] + a[i] + a[i-1]); // i&#48264;&#51704;, i-1&#48264;&#51704; &#46160;&#48264; &#50672;&#49549; &#47560;&#49900;         dp[i] = max(dp[i], dp[i-1]); // i&#48264;&#51704; &#49440;&#53469;&#50504;&#54632;     }     printf(\"%d\\n\", dp[N]);     return 0; }       코드 dp[i][j]    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N; int d[10020][3]; int a[10020];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }      d[1][0] = 0;    // 0&#44060; &#50672;&#49549; &#44256;&#47476;&#44592;     d[1][1] = a[1]; // 1&#44060; &#50672;&#49549; &#44256;&#47476;&#44592;     d[1][2] = 0;    // 2&#44060; &#50672;&#49549; &#44256;&#47476;&#44592;      for(int i=2;i&lt;=N;i++) {         d[i][0] = max(max(d[i-1][0], d[i-1][1]), d[i-1][2]);         d[i][1] = d[i-1][0] + a[i];         d[i][2] = d[i-1][1] + a[i];      }     printf(\"%d\\n\", max(max(d[N][0], d[N][1]), d[N][2]));      return 0; }       문제 링크    https://www.acmicpc.net/problem/2156    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-2156/",
        "teaser": null
      },{
        "title": "BOJ 2579 계단 오르기",
        "excerpt":" BOJ 2579 계단 오르기    한번에 두개 연속밝거나, 하나 밟고, 뛰어넘을 수 있음. 세개 연속 밟을 수 없음 마지막 도착 계단은 꼭 밟아야 함      접근하기 1    문제에 주어진 내용을 점화식(Recurrence relation)으로 나타내야 함     d[i] : i번째 계단 까지 뛰었을 때의 최대값  d[0] : 출발점  d[1] : a[1] 1번째 계단 밟음 d[2] : a[1] + a[2] 두개 연속 밟음  a[i] + a[i-1] + d[i-3] : 두개 연속 밟기 a[i] + d[i-2] : 현재 밟고, i-2에서 점프에서 오기     코드 - dp[i]로 풀기    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N; int a[310]; int dp[310];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);      }       dp[0] = 0;     dp[1] = a[1];     dp[2] = a[1]+a[2];      for(int i=3;i&lt;=N;i++) {         dp[i] = max(dp[i], a[i] + a[i-1] + dp[i-3]); // &#51216;&#54532; &#54980; &#46160;&#44060; &#50672;&#49549; &#48159;&#44592;         dp[i] = max(dp[i], a[i] + dp[i-2]); // &#51216;&#54532; &#54980; &#54616;&#45208; &#50672;&#49549; &#48159;&#44592;     }     printf(\"%d\\n\", dp[N]);     return 0; }        접근하기 2    d[i][1] : 1번 연속밟아서 i번쨰 옴 d[i][2] : 2번 연속밟아서 i번째 옴  dp[i][1] = max(dp[i-2][1], dp[i-2][2]) + a[i]; // i-2에서 점프해서 i번째 밟음(이전에 1번, 2번 무관 큰값 고르기)  dp[i][2] = dp[i-1][1] + a[i]; // i-1에서 1번연속 밟은 상태 -&gt;  점프해서 i번째 밟음      코드 - dp[i][1,2]로 풀기    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N; int a[310]; int dp[310][3]; //   // dp[i][1] : &#54616;&#45208; &#48159;&#51020; // dp[i][2] : &#46160;&#48264; &#48159;&#51020;  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);      for(int i=1;i&lt;=N;i++)         scanf(\"%d\", &amp;a[i]);      dp[1][1] = a[1];     dp[1][2] = a[1];      dp[2][1] = a[2];     dp[2][2] = dp[1][1] + a[2];      for(int i=3;i&lt;=N;i++) {         dp[i][1] = max(dp[i-2][1], dp[i-2][2]) + a[i]; // i-2&#50640;&#49436; &#51216;&#54532;&#54644;&#49436; i&#48264;&#51704; &#48159;&#51020;         dp[i][2] = dp[i-1][1] + a[i]; // i-1&#50640;&#49436; &#51216;&#54532;&#54644;&#49436; i&#48264;&#51704; &#48159;&#51020;     }       printf(\"%d\\n\", max(dp[N][1], dp[N][2]));     return 0; }      문제 링크    https://www.acmicpc.net/problem/2579    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-2579/",
        "teaser": null
      },{
        "title": "3234. 준환이의 양팔저울",
        "excerpt":" 3234. 준환이의 양팔저울    양팔저울에 N개의 추를 올림 올리는 순서의 경우의 수를 구하는 문제 N&lt;=9 로 작다. 완전탐색이 가능한 문제      접근하기    top-down DP로도 풀수 있다. 9개의 bit를 조합하기, left, right이용      코드    두 변수에 bit를 더하고도 선택되지 않은 bit일때 상태공간 확장 오른쪽에 추를 둘 때, 왼쪽보다 더 크지 않아야 한다. (작거나 같아야 함)   #include &lt;stdio.h&gt;  int T; int N; int a[10]; int memo[1&lt;&lt;9][1&lt;&lt;9];  int bt(int idx, int left, int right, int lsum, int rsum) {     if (idx == N) return 1;      if (memo[left][right]) return memo[left][right];      int cnt = 0;     for(int i=0;i&lt;N;i++) {         if ( ((left | right) &amp; (1&lt;&lt;i)) == 0) {             cnt += bt(idx+1, left | (1&lt;&lt;i), right, lsum + a[i], rsum);             if (lsum &gt;= rsum + a[i]) {                 cnt += bt(idx+1, left, right | (1&lt;&lt;i), lsum, rsum + a[i]);             }         }     }     memo[left][right] = cnt;     return memo[left][right]; }   void solve(int tc) {     scanf(\"%d\", &amp;N);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }      for(int i=0;i&lt;(1&lt;&lt;9);i++) {         for(int j=0;j&lt;(1&lt;&lt;9);j++) {             memo[i][j] = 0;         }     }      int ret = bt(0, 0, 0, 0, 0);     printf(\"#%d %d\\n\",tc, ret); } int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;T);      for(int tc=1;tc&lt;=T;tc++) {         solve(tc);        }     return 0; }       생각해보기    bottom-up DP로 풀 수 있을까?     문제 링크    문제로 가기    ","categories": [],
        "tags": ["SWEA","DP","완전탐색"],
        "url": "/swea-3234/",
        "teaser": null
      },{
        "title": "abc210 C - Colorful Candies",
        "excerpt":" C - Colorful Candies    N개의 캔디가 주어질 때, 각 요소는 캔디의 색을 의미 최대한 다른 색깔로 K개 고를 때, 가능한 숫자      접근하기    N의 범위가 30만이내, K를 범위로 잡고 다 찾아보면 된다.      코드 - hash를 구현해서 풀기    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;   #define HASH_SIZE 7701  int N; int K;  typedef struct Node {     int num;     int cnt;     Node* next; } Node;  int a[300010]; int idx; Node pool[300010]; Node* table[HASH_SIZE];  Node* CreateNode(int num) {     Node* ptr = &amp;pool[idx++];     ptr-&gt;num = num;     ptr-&gt;cnt = 1;     ptr-&gt;next = NULL;     return ptr; }  int HASH(int num) {     return num%HASH_SIZE; }  void hash_add(Node* ptr) {     int key = HASH(ptr-&gt;num);     ptr-&gt;next = table[key];     table[key] = ptr; }  Node* hash_find(int num) {     int key = HASH(num);     Node* ptr = table[key];     while(ptr) {         if (ptr-&gt;num == num) return ptr;         ptr = ptr-&gt;next;     }     return NULL; }  Node* hash_remove(int num) {     int key = HASH(num);     Node* ptr = table[key];     Node* prev = NULL;     while(ptr) {         if (ptr-&gt;num == num) {             if (prev == NULL) {                 table[key] = table[key]-&gt;next;             } else {                 Node* todel = ptr;                 prev-&gt;next = ptr-&gt;next;                 return todel;             }         }         prev = ptr;         ptr = ptr-&gt;next;     }     return NULL; }  int main(int argc, char* argv[]) {     idx = 0;     scanf(\"%d %d\", &amp;N, &amp;K);     int ans = 0;      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }       int maxv = 0;     for(int i=0;i&lt;K;i++) {         int val = a[i];         Node* ptr = hash_find(val);         if (ptr != NULL) {             ptr-&gt;cnt += 1;         } else {             Node* obj = CreateNode(val);              hash_add(obj);             ans += 1;         }     }     maxv = max(maxv, ans);      for(int i=K;i&lt;N;i++) {         int val = a[i];         Node* ptr = hash_find(val);         if (ptr != NULL) {             ptr-&gt;cnt += 1;         } else {             Node* obj = CreateNode(val);              hash_add(obj);             ans += 1;         }          int val2 = a[i-K];         ptr = hash_find(val2);         if (ptr != NULL) {             ptr-&gt;cnt -= 1;             if (ptr-&gt;cnt == 0) {                 ans -= 1;                 hash_remove(val2);             }         }         maxv = max(maxv, ans);     }     printf(\"%d\\n\", maxv);     return 0; }       코드 - STL map 이용    STL map을 잘 쓰기  key에 값 갱신 int, int로 map객체 만들기 erase로 노드 지우기 size로 count하기     #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;map&gt; using namespace std;  int N, K; map&lt; int, int &gt; mp; // int key&#47196; int value&#47484; &#47337;&#50629;&#54616;&#45716; &#48176;&#50676; int a[300010];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;K);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }      // 1&#48264;&#51704; &#51452;&#44592;&#47484; &#49884;&#51089;     for(int i=0;i&lt;K;i++) {         mp[a[i]] += 1; // &#52376;&#51020; K&#47564;&#53372; &#47337;&#50629;&#48176;&#50676; &#52292;&#50864;&#44592;     }     int ans = mp.size(); // size&#44032; &#44060;&#49688;  1 1 2 &#46972;&#47732; 2&#44032; &#46120;, 1 2 3&#51060;&#47732; 3&#51060; &#46120;      for(int i=K;i&lt;N;i++) { // &#46160;&#48264;&#51704; &#51452;&#44592;&#47484; &#49884;&#51089;         mp[a[i]]++;              mp[a[i-K]]--;      // i-K : &#51060;&#51204; &#51452;&#44592;&#51032; &#49884;&#51089;&#48512;&#53552;          if(mp[a[i-K]] == 0) mp.erase(a[i-K]); // &#44050;&#51060; 0&#51060;&#47732;, &#45432;&#46300;&#47484; &#49325;&#51228;         ans = max(ans, (int)mp.size());       // size&#44032; &#53356;&#47732; ans &#44081;&#49888;     }     printf(\"%d\\n\", ans);      return 0; }      문제 링크    https://atcoder.jp/contests/abc200/tasks/abc200_d    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc210-c-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 11478 서로 다른 부분문자열의 개수",
        "excerpt":" BOJ 11478 서로 다른 부분 문자열의 개수     접근하기 1    2중 loop로 문자열의 부분 문자열 나열하기    ababc a, b, a, b, c, ab, ba, ab, bc, aba, bab, abc, abab, babc, ababc 12개     코드 - 이중루프 + STL set    #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;set&gt;  using namespace std; char str[1010];  int main(int argc, char* argv[]) {     scanf(\"%s\", str);     int len = 0;     for(;str[len];len++);      set &lt;string&gt; sp;      for(int i=0;i&lt;len;i++) {         string tmp;         for(int j=i;j&lt;len;j++) {             tmp += str[j];              sp.insert(tmp);         }     }     printf(\"%d\\n\", (int)sp.size()); }       코드 - 이중루프 + STL unordered_set    #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;unordered_set&gt;  using namespace std; char str[1010];  int main(int argc, char* argv[]) {     scanf(\"%s\", str);     int len = 0;     for(;str[len];len++);      unordered_set &lt;string&gt; sp;      for(int i=0;i&lt;len;i++) {         string tmp;         for(int j=i;j&lt;len;j++) {             tmp += str[j];              sp.insert(tmp);         }     }     printf(\"%d\\n\", (int)sp.size()); }        TODO 접근하기 2 : Suffix Array + LCP     TODO 접근하기 3 : Trie    트라이에 모든 부분 문자열을 추가하면, 노드의 개수      TODO 접근하기 4 : Hashing    모든 부분문자열을 hash로 숫자로 변환, 추가하면서 uniq를 세기      문제 링크    https://www.acmicpc.net/problem/11478      참고자료    https://algoshipda.blogspot.com/2017/05/boj-11478.html    ","categories": [],
        "tags": ["서로다른부분문자열","STL"],
        "url": "/boj-11478/",
        "teaser": null
      },{
        "title": "BOJ 1302 베스트셀러",
        "excerpt":" BOJ 1302 베스트셀러    문자열 목록을 줌 가장 많은 제목 출력, 가장 많은 제목이 중복되었으면, 사전순 앞서는 것      접근하기    sort하면, 사전순으로 앞서는 것이 앞에 옴 숫자를 count한다. 가장 큰것을 ans 변수에 담을 것      코드    #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std;  int N; char str[60];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     vector &lt;string&gt; vp(N);         char str[60];     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         string s(str);         vp[i] = s;     }     sort(vp.begin(), vp.end());       int ans = 1;     int cnt = 1;     string out = vp[0];     for(int i=1;i&lt;(int)vp.size();i++) {         if (vp[i-1] == vp[i]) {             cnt++;         } else {             cnt = 1;         }         if (ans &lt; cnt) {             ans = cnt;             out = vp[i];         }     }     printf(\"%s\\n\", out.c_str());     return 0; }       문제 링크    https://www.acmicpc.net/problem/1302    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-1302/",
        "teaser": null
      },{
        "title": "BOJ 14425 문자열 집합",
        "excerpt":" BOJ 14425 문자열 집합     접근하기    집합 S에 같은 문자열이 여러 번 주어지는 경우는 없으므로, STL set을 에 넣었음. cnt를 이용해서 count함      코드    #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;set&gt; using namespace std;  int N, M; set&lt;string&gt; mp;  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      char str[510];     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         mp.insert(string(str));     }      int cnt = 0;     for(int i=0;i&lt;M;i++) {         scanf(\"%s\", str);         if (mp.find(string(str)) != mp.end()) cnt++;     }     printf(\"%d\\n\", cnt);     return 0; }       문제 링크    https://www.acmicpc.net/problem/14425    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-14425/",
        "teaser": null
      },{
        "title": "BOJ 1620 나는야 포켓몬 마스터 이다솜",
        "excerpt":" BOJ 1620 나는야 포켓몬 마스터 이다솜     접근하기    STL map key: string, value: int로 객체 이용 string 배열에 string을 각각 저장      코드    // &#49884;&#44036;&#52488;&#44284; &#54400;&#51060; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;map&gt; using namespace std;  int N, M; map &lt;string, int&gt; mp; string sa[1000010];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      char str[21];     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         string s(str);         mp[s] = (long long)i+1;         sa[i] = s;     }      for(int i=0;i&lt;M;i++) {         char str[21];         scanf(\"%s\", str);          if (str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') {             long long num = 0;             for(int j=0;str[j];j++) {                 num = num * 10 + (str[j] - '0');             }             printf(\"%s\\n\", sa[num-1].c_str());         } else {             printf(\"%d\\n\", mp[str]);         }     }     return 0; }       주의사항    iostream으로 in/out을 하면 시간초과가 발생함.      문제 링크    https://www.acmicpc.net/problem/1620    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-1620/",
        "teaser": null
      },{
        "title": "BOJ 17219 비밀번호 찾기",
        "excerpt":" BOJ 17219 비밀번호 찾기       접근하기    key, value가 모두 문자열로 된 데이터를 저장하고 검색 STL map을 써보는 문제      코드    #include &lt;cstdio&gt; #include &lt;map&gt; #include &lt;string&gt;  using namespace std; int N, M;  int main(int argc, char* argv[]) {     char s1[22], s2[22];      scanf(\"%d %d\", &amp;N, &amp;M);      map &lt;string, string&gt; mp;     for(int i=0;i&lt;N;i++) {         scanf(\"%s %s\", s1, s2);         mp[string(s1)] = string(s2);     }      char s3[22];     for(int i=0;i&lt;M;i++) {         scanf(\"%s\", s3);         printf(\"%s\\n\", mp[string(s3)].c_str());     }     return 0; }        문제 링크    https://www.acmicpc.net/problem/17219    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-17219/",
        "teaser": null
      },{
        "title": "BOJ 1764 듣보잡",
        "excerpt":" BOJ 1764 듣보잡     접근하기    STL을 이용해서 다양하게 풀어보자.       코드 - STL vector 이용하기 492 m/s    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int N, M;  int main(int argc, char* argv[]) {     cin &gt;&gt; N &gt;&gt; M;      vector &lt;string&gt; v(N+M);      string str;     // N&#47564;&#53372; vector&#50640; &#52628;&#44032;      for(int i=0;i&lt;N;i++) {         cin &gt;&gt; str;         v[i] = str;     }     // M&#47564;&#53372; &#46244;&#50640; &#51060;&#50612;&#49436; &#52628;&#44032;     for(int i=N;i&lt;N+M;i++) {         cin &gt;&gt; str;         v[i] = str;     }     // sort     sort(v.begin(), v.end());       // N+M&#47564;&#53372; &#48152;&#48373;&#54616;&#47732;&#49436;, &#50526;&#46244;&#47196; &#44057;&#51004;&#47732; ret&#50640; &#51200;&#51109;     vector &lt;string&gt; ret;     for(int i=1;i&lt;(int)v.size();i++) {         if (v[i-1] == v[i]) {             ret.push_back(v[i]);         }     }      // &#52636;&#47141;     cout &lt;&lt; ret.size() &lt;&lt; endl;     for(auto&amp; o:ret) {         cout &lt;&lt; o &lt;&lt; endl;     }     return 0; }      코드 - STL set 이용하기 500m/s    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;vector&gt; using namespace std;  int N, M; set &lt;string&gt; s;  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);     for(int i=0;i&lt;N;i++) {         string tmp;          cin &gt;&gt; tmp;         s.insert(tmp);     }      set &lt;string&gt; s2;     for(int i=0;i&lt;M;i++) {         string tmp;          cin &gt;&gt; tmp;         if (s.find(tmp) != s.end()) { // find&#54644;&#49436; &#50630;&#51004;&#47732;             s2.insert(tmp);         }     }      cout &lt;&lt; s2.size() &lt;&lt; endl;     for (auto&amp; o :s2) { // set&#44061;&#52404; iteration         cout &lt;&lt; o &lt;&lt; endl;      }     return 0; }       문제 링크    https://www.acmicpc.net/problem/1764    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-1764/",
        "teaser": null
      },{
        "title": "BOJ 7785 회사에 있는 사람",
        "excerpt":" BOJ 7785 회사에 있는 사람     접근하기    STL map을 연습할 수 있는 문제 STL 컨테이너를 역순으로 순회하기      코드    #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     char s1[10];     char s2[10];      map&lt;string, int&gt; mp;      for(int i=0;i&lt;N;i++) {         scanf(\"%s %s\", s1, s2);          string cmd(s2);         if (cmd == \"enter\") {             mp[string(s1)] += 1;         } else if (cmd == \"leave\") {             mp[string(s1)] -= 1;             if (mp[string(s1)] == 0) mp.erase(string(s1));         }     }      // container&#47484; &#50669;&#49692;&#51004;&#47196; &#49692;&#54924; (STL)     map&lt;string, int&gt;::reverse_iterator it;     for(it=mp.rbegin(); it!=mp.rend();it++) {         printf(\"%s\\n\", it-&gt;first.c_str());     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/7785    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-7785/",
        "teaser": null
      },{
        "title": "BOJ 1269 대칭 차집합",
        "excerpt":" BOJ 1269 대칭 차집합     접근하기    set1, set2에 각각 데이터를 저장 set1에서 B를 빼고 카운트 set2에서 A를 빼고 카운트      코드 - STL set이용    #include &lt;cstdio&gt; #include &lt;set&gt; #include &lt;algorithm&gt;  using namespace std;  int a[200020]; int b[200020];  int N, M; int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);     set&lt;int&gt; sa;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);         sa.insert(a[i]);     }      set&lt;int&gt; sb;     for(int i=0;i&lt;M;i++) {         scanf(\"%d\", &amp;b[i]);         sb.insert(b[i]);     }      vector&lt;int&gt; v;     for(int i=0;i&lt;N;i++) {         if (sb.find(a[i]) != sb.end()) {             sa.erase(a[i]);             v.push_back(a[i]);         }     }     int reta = sa.size();      for(auto &amp;o :v) {         sa.insert(o);     }      for(int i=0;i&lt;M;i++) {         if (sa.find(b[i]) != sa.end()) {             sb.erase(b[i]);         }     }      printf(\"%d\\n\", reta + (int)sb.size());     return 0; }       코드 - STL set + set_difference 알고리즘    #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;algorithm&gt; #include &lt;iterator&gt; using namespace std;  int N, M; std::set&lt;int&gt; s1, s2; set&lt;int&gt; result1; set&lt;int&gt; result2;  int main(int argc, char* argv[]) {     cin &gt;&gt; N &gt;&gt; M;      int num;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; num;         s1.insert(num);     }     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; num;         s2.insert(num);     }     set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result1, result1.end()));     set_difference(s2.begin(), s2.end(), s1.begin(), s1.end(), inserter(result2, result2.end()));     cout &lt;&lt; result1.size() + result2.size()&lt;&lt; \"\\n\";     return 0; }      문제 링크    https://www.acmicpc.net/problem/1269    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-1269/",
        "teaser": null
      },{
        "title": "BOJ 1351 무한 수열",
        "excerpt":" BOJ 1351 무한 수열     접근하기    점화식이 주어질 째, top-down으로 구성하기 수학 기호의 이해 STL map을 이용해서 dp 배열을 만들 수 있음      코드    #include &lt;cstdio&gt; #include &lt;map&gt; using namespace std;  map &lt;long long, long long&gt; dp;  long long N; int P, Q;  long long f(long long i) {     if (i == 0) return 1;     if (dp[i]) return dp[i];      dp[i] = f(i/P) + f(i/Q);     return dp[i]; }  int main(int argc, char* argv[]) {     scanf(\"%lld %d %d\", &amp;N, &amp;P, &amp;Q);      long long ret = f(N);     printf(\"%lld\\n\", ret);      return 0; }       문제 링크    https://www.acmicpc.net/problem/1351    ","categories": [],
        "tags": ["STL","DP"],
        "url": "/boj-1351/",
        "teaser": null
      },{
        "title": "BOJ 1354 무한 수열 2",
        "excerpt":" BOJ 1354 무한 수열 2     접근하기    점화식이 주어질 때, top down DP 작성하기 STL map을 이용해서, 큰 범위의 memoization이 가능      코드 - 8초가 넘는 풀이    좀 더 빨리 풀려면 어떻게?   #include &lt;cstdio&gt; #include &lt;map&gt; using namespace std;  long long N, P, Q, X, Y; map&lt;long long, long long&gt; dp;  long long f(long long i) {     if (i &lt;= 0) return 1;     if (dp[i]) return dp[i];       dp[i] = f(i/P-X) + f(i/Q-Y);     return dp[i]; }  int main(int argc, char* argv[]) {     scanf(\"%lld %lld %lld %lld %lld\", &amp;N, &amp;P, &amp;Q, &amp;X, &amp;Y);     long long ret = f(N);     printf(\"%lld\\n\", ret);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1354    ","categories": [],
        "tags": ["STL","DP"],
        "url": "/boj-1354/",
        "teaser": null
      },{
        "title": "BOJ 19583 싸이버개강총회",
        "excerpt":" BOJ 19583 싸이버개강총회     접근하기    STL map객체로 이름으로 enter/leave를 check한다. 채팅 메시지는 여러줄 출력할 수 있음. 한번만 count하기      코드    #include &lt;cstdio&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;algorithm&gt;  using namespace std;  int start_h, start_m; int end_h, end_m; int metube_h, metube_m;  int main(int argc, char* argv[]) {     scanf(\"%d:%d\", &amp;start_h, &amp;start_m);     scanf(\"%d:%d\", &amp;end_h, &amp;end_m);     scanf(\"%d:%d\", &amp;metube_h, &amp;metube_m);      int t1 = start_h * 60 + start_m;     int t2 = end_h * 60 + end_m;     int t3 = metube_h * 60 + metube_m;      int in_h, in_m;     char name[30];      map&lt;string, int&gt; mp1;       int cnt = 0;     while(scanf(\"%d:%d %s\", &amp;in_h, &amp;in_m, name) != EOF) {         int now = in_h * 60 + in_m;         if (now &lt;= t1) {             mp1[string(name)] = 1;         }          if (t2 &lt;= now &amp;&amp; now &lt;= t3) {             if (mp1[string(name)] == 1) {                 mp1[string(name)] = 2;                 cnt += 1;                 //printf(\"&gt;%s\\n\", name);             }         }     }     printf(\"%d\\n\", cnt);     return 0; }       문제 링크    https://www.acmicpc.net/problem/19583    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-19583/",
        "teaser": null
      },{
        "title": "BOJ 2910 빈도정렬",
        "excerpt":" BOJ 2910 빈도정렬    배열이 주어지고, 빈도순으로 정렬 빈도가 같다면 먼저 나온 것을 선택      접근하기    STL map객체를 써서 배열값으로 index 룩업/cnt 룩업 할 수 있게 구성.  map을 쓸 수 없다면, 구현이 까다로웠을 듯.  구조체의 idx, cnt를 각각 업데이트 cmp 함수대로 sort하면, 결과가 나옴      코드    #include &lt;cstdio&gt; #include &lt;map&gt; #include &lt;algorithm&gt; using namespace std;  typedef struct Node {     int num;     int idx;     int cnt; } Node;  int N, C; Node pool[1010];  bool cmp(Node&amp; p1, Node&amp; p2) {     if (p1.cnt == p2.cnt) {         return p1.idx &lt; p2.idx;     } else {         return p1.cnt &gt; p2.cnt;     } }  int main(int argc, char* argv[]) {     //freopen(\"input.txt\", \"r\", stdin);     map&lt;int, int&gt; mp;     map&lt;int, int&gt; mp_idx;     scanf(\"%d %d\", &amp;N, &amp;C);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;pool[i].num);         mp[pool[i].num]++;         if (mp_idx[pool[i].num] == 0) {             mp_idx[pool[i].num] = i + 1;         }     }      for(int i=0;i&lt;N;i++) {         pool[i].cnt = mp[pool[i].num];         pool[i].idx = mp_idx[pool[i].num];     }       sort(pool, pool+N, cmp);      for(int i=0;i&lt;N;i++) {         printf(\"%d \", pool[i].num);     }     printf(\"\\n\");     return 0; }       문제 링크    https://www.acmicpc.net/problem/2910    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-2910/",
        "teaser": null
      },{
        "title": "BOJ 9536 여우는 어떻게 울지?",
        "excerpt":" BOJ 9536 여우는 어떻게 울지?     접근하기    stdin의 처음부터 마지막까지 getline으로 입력받기 첫번재 줄 입력에서  공백으로 구분된 string 전체를 받기 string을 token으로 분리하기  두번째 줄 입력에서 3번째 단어만 vector에 저장      코드    #include &lt;sstream&gt; #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int T;  void solve() {     char split_char = ' ';     string s;     getline(cin &gt;&gt; ws, s);      istringstream split(s);     vector&lt;string&gt; tokens;     for(string each; getline(split, each, split_char);tokens.push_back(each));      string input;     vector&lt;string&gt; arr;     while(getline(cin &gt;&gt; ws, input)) {         if (input == string(\"what does the fox say?\")) break;          istringstream split2(input);         int i = 1;         for(string each; getline(split2, each, split_char);i++) {             if (i % 3 == 0) arr.push_back(each);         }     }     for(auto&amp; e:arr) {         while(1) {             auto it = find(tokens.begin(), tokens.end(), e);             if (it != tokens.end()) {                 tokens.erase(it);             } else {                 break;             }         }     }      for(auto&amp; e:tokens) {         cout &lt;&lt; e.c_str() &lt;&lt; \" \";     }     cout &lt;&lt; \"\\n\";  }  int main(int argc, char* argv[]) {     ios::sync_with_stdio(0);     cin.tie(0);     cin &gt;&gt; T;     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/9536    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-9536/",
        "teaser": null
      },{
        "title": "BOJ 11328 Strfry",
        "excerpt":" BOJ 11328 Strfry     접근하기    STL string을 sort로 정렬할 수 있음. 두 string을 sort한 후, 비교      코드    #include &lt;iostream&gt; //#include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std;  int N;  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     cin &gt;&gt; N;     string s1, s2;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; s1 &gt;&gt; s2;           sort(s1.begin(), s1.end());         sort(s2.begin(), s2.end());         if (s1 == s2)             cout &lt;&lt; \"Possible\" &lt;&lt; endl;         else             cout &lt;&lt; \"Impossible\" &lt;&lt; endl;     }      return 0; }       문제 링크    https://www.acmicpc.net/problem/11328    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-11328/",
        "teaser": null
      },{
        "title": "BOJ 1152 단어의 개수",
        "excerpt":" BOJ 1152 단어의 개수     접근하기    getline으로 줄 단위로 받아서 string에 저장 istringstream을 이용해서, token으로 분리 vector에 token을 저장하지 않고, cnt를 세면 된다.      코드    #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt;  using namespace std;   int main(int argc, char* argv[]) {     string s;     getline(cin &gt;&gt; ws, s);      char split_char = ' ';     istringstream split(s);     //vector&lt;string&gt; tok;     int cnt = 0;     for(string each; getline(split, each, split_char);cnt+=1);     cout &lt;&lt; cnt &lt;&lt; endl;     return 0; }       문제 링크    https://www.acmicpc.net/problem/1152    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-1152/",
        "teaser": null
      },{
        "title": "BOJ 11931 수 정렬하기 4",
        "excerpt":" BOJ 11931 수 정렬하기 4     접근하기    STL sort를 이용하기. 역순을 위해 cmp함수를 추가해주기      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt;  using namespace std;  int N; int a[1000010];  bool cmp(int&amp; p1, int&amp; p2) {     return p1 &gt; p2; }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);       for(int i=0;i&lt;N;i++)         scanf(\"%d\", &amp;a[i]);      sort(a, a+N, cmp);     for(int i=0;i&lt;N;i++)         printf(\"%d\\n\", a[i]);     return 0; }       문제 링크    https://www.acmicpc.net/problem/11931    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-11931/",
        "teaser": null
      },{
        "title": "BOJ 1253 좋다",
        "excerpt":" BOJ 1253 좋다.     접근하기 1    서로 다른 두 수의 합으로 나타내기 -&gt; 값 한개가 이미 답인 경우를 제외     코드 - map 객체에 index정보 저장    #include &lt;cstdio&gt; #include &lt;map&gt; using namespace std;  int N; int a[2020];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      map&lt;int, pair&lt;int, bool&gt;&gt; mp;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);         mp[a[i]] = {i, false};     }      for(int i=0;i&lt;N;i++) {         for(int j=i+1;j&lt;N;j++) {             int sum = a[i] + a[j];             if (mp.count(sum)) {                 // sum&#51060; &#50500;&#45772; &#54616;&#45208;&#47196; &#44396;&#49457;&#46108; &#44221;&#50864; skip                 if (mp[sum].first == i || mp[sum].first == j) continue;                  mp[sum].second = true;             }         }     }     int cnt = 0;     for(int i=0;i&lt;N;i++) {         if (mp[a[i]].second == true) cnt++;     }     printf(\"%d\\n\", cnt);     return 0; }       접근하기 2    투 포인터로 두수의 값이 K일 때를 찾아 카운트 for loop를 하면서, a[0] ~ a[N-1]까지를 K로 놓기     코드 - 투 포인터 이용 풀이    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N; int a[2020];  int find(int num, int i) {     int left = 0;     int right = N-1;      int ans = 0;     while(left &lt; right) {         if (a[left] + a[right] == num) {             if (i != left &amp;&amp; i != right){                 ans = 1;                 break;             }             if (left == i) left++;             else if ( right == i) right--;         } else if (a[left] + a[right] &lt; num) {             left++;         } else if (a[left] + a[right] &gt; num) {             right--;         }     }      return ans; }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+N);      int sum = 0;     for(int i=0;i&lt;N;i++) {         sum += find(a[i], i);      }     printf(\"%d\\n\", sum);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1253    ","categories": [],
        "tags": ["STL","투포인터"],
        "url": "/boj-1253/",
        "teaser": null
      },{
        "title": "BOJ 14225 부분수열의 합",
        "excerpt":" BOJ 14225      접근하기    완전탐색 tree를 재귀로 구현함 check배열에 진입한 상태에 1로 체크 1~부터 200만을 loop돌며, 처음 false위치 출력     코드    #include &lt;cstdio&gt; using namespace std;  int N; int a[21]; int b[2000010];  void bt(int k, int sum) {     b[sum] = 1;      if (k == N) {         return;     }     bt(k+1, sum);     bt(k+1, sum + a[k]); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }      bt(0, 0);      for(int i=1;i&lt;2000010;i++) {         if (b[i] == 0) {             printf(\"%d\\n\", i);             break;         }     }     return 0; }       TODO 생각    DP style로 좀 더 최적화해서 풀 수 있을 듯 싶다.      문제 링크    https://www.acmicpc.net/problem/14225    ","categories": [],
        "tags": ["완전탐색"],
        "url": "/boj-14225/",
        "teaser": null
      },{
        "title": "BOJ 1822 차집합",
        "excerpt":" BOJ 1822 차집합     접근하기    STL의 binary_search 이용하기 A - B는 A의 원소이면서, B의 원소가 아닌 경우를 센다.      코드    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N, M;  int a[500050]; int b[500050];  int main(int argc, char* argv[]) {     cin &gt;&gt; N &gt;&gt; M;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; a[i];     }     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; b[i];     }     sort(b, b+M);      vector&lt;int&gt; ans;     for(int i=0;i&lt;N;i++) {         if (!binary_search(b, b+M, a[i])) {             ans.push_back(a[i]);         }     }     cout &lt;&lt; ans.size() &lt;&lt; endl;     sort(ans.begin(), ans.end());     for(auto&amp; o:ans) {         cout &lt;&lt; o &lt;&lt; \" \";     }     cout &lt;&lt; endl;     return 0; }       문제 링크    https://www.acmicpc.net/problem/1822    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-1822/",
        "teaser": null
      },{
        "title": "BOJ 20001 고무오리 디버깅",
        "excerpt":" BOJ 20001 고무오리 디버깅     접근하기    STL stack 이용하기 pair를 맞추는 문제 문제가 없이 고무오리만 있으면, 문제 두개 추가 -&gt; 코드로 생각하기      코드    #include &lt;iostream&gt; #include &lt;stack&gt; #include &lt;stack&gt;  using namespace std;  int main(int argc, char* argv[]) {     //freopen(\"input.txt\", \"r\", stdin);         string line;     stack &lt;string&gt; st;     while(getline(cin, line)) {         //cout &lt;&lt; line &lt;&lt; endl;          if (line == \"&#47928;&#51228;\")  {             st.push(line);         } else if (line == \"&#44256;&#47924;&#50724;&#47532;\") {             if (st.size() == 0) {                 st.push(\"&#47928;&#51228;\");                 st.push(\"&#47928;&#51228;\");             } else {                 st.pop();             }         } else if (line == \"&#44256;&#47924;&#50724;&#47532; &#46356;&#48260;&#44613; &#45149;\") {             break;         }     }      if (st.size() == 0) {         cout &lt;&lt; \"&#44256;&#47924;&#50724;&#47532;&#50556; &#49324;&#46993;&#54644;\" &lt;&lt; endl;      } else {         cout &lt;&lt; \"&#55197;&#44396;\" &lt;&lt; endl;      }     return 0; }       문제 링크    https://www.acmicpc.net/problem/20001    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-20001/",
        "teaser": null
      },{
        "title": "BOJ 21939 문제 추천 시스템 Version 1",
        "excerpt":" BOJ 21939 문제 추천 시스템 Version 1     접근하기    set에 정렬된 순서로 데이터를 저장  set의 맨 처음 element 출력 set의 맨 마지막 element 출력  map에 id를 이용해서 난이도를 얻는 룩업테이블 구성 solve하면, set과 map 각각 지우기      코드    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;utility&gt; using namespace std;  int N, M; set&lt; pair&lt;int, int&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; sp; map&lt;int, int&gt; mp;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      int id, difficulty;     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;id, &amp;difficulty);         mp[id] = difficulty;         sp.insert(make_pair(difficulty, id));     }      scanf(\"%d\", &amp;M);     char cmd[20];     int order;      for(int i=0;i&lt;M;i++) {         scanf(\"%s\", cmd);          switch(cmd[0]) {         case 'a':   // add             scanf(\"%d %d\", &amp;id, &amp;difficulty);             mp[id] = difficulty;             sp.insert(make_pair(difficulty, id));             break;         case 'r':   // recommend             scanf(\"%d\", &amp;order);             if (order == 1) {                 auto it = sp.begin();                 printf(\"%d\\n\", it-&gt;second);             } else if (order == -1) {                 auto it = sp.end();                 it--;                 printf(\"%d\\n\", it-&gt;second);             }             break;         case 's':   // solved             scanf(\"%d\", &amp;id);              auto it = sp.find(make_pair((int)mp[id], id));             if (it != sp.end()){                 sp.erase(it);                 mp.erase(id);             }             break;         }     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/21939    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-21939/",
        "teaser": null
      },{
        "title": "BOJ 2696 중앙값 구하기",
        "excerpt":" BOJ 2696 중앙값 구하기     접근하기    Running Median 문제를 STL로 풀어보기 홀수 일때만 값을 출력하면 된다. max heap, min heap을 STL로 구성하기      코드    #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt;  using namespace std;  int T; int N;  void solve() {     priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;     priority_queue &lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; max_heap;     scanf(\"%d\", &amp;N);     vector &lt;int&gt; ans;      int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);          min_heap.push(num);   // &#52572;&#49548;&#55193;&#50640; &#44050;&#51012; &#47924;&#51312;&#44148; &#45347;&#46020;&#47197; &#54632;          // min heap&#51060; &#53356;&#47732; max heap&#51004;&#47196; &#54616;&#45208; &#51060;&#46041;         if (max_heap.size() &lt; min_heap.size()) {             int tmp = min_heap.top();             min_heap.pop();             max_heap.push(tmp);         } else if (max_heap.size() == min_heap.size()) {             int right = min_heap.top();             int left = max_heap.top();              if (left &gt; right) {                 min_heap.pop();                 max_heap.pop();                 max_heap.push(right);                 min_heap.push(left);             }         }          if ((max_heap.size() + min_heap.size()) %2 == 1) {             ans.push_back(max_heap.top());         }     }      printf(\"%d\\n\", (int)ans.size());     int cnt = 0;     for(auto&amp; o:ans) {         printf(\"%d \", o);         if (++cnt%10 == 0) printf(\"\\n\");     }     printf(\"\\n\"); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/2696    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-2696/",
        "teaser": null
      },{
        "title": "BOJ 3078 좋은 친구",
        "excerpt":" BOJ 3078 좋은 친구     접근하기    그냥 순서대로 K개씩 비교하면, 30만x30만으로 시간초과가 된다.     등수가 순서대로 들어옴    등수가 0에서 증가하는 순서로 입력이 들어온다는 성질을 이용한다.      이름의 길이가 같아야 좋은 친구가 된다. (제약)    이름의 길이는 2~20글자 -&gt; queue의 배열을 만든다. (index는 이름의 길이)      queue로 순서쌍을 count하는 방법 (중요!!)    Q의 노드들와 현재 노드의 등수차이가 K보다 크면 버린다.  Q에 1개 있으면, 1쌍이 가능 -&gt; cnt 증가 Q에 2개 있으면, 2쌍이 가능 -&gt; cnt 증가        코드 - 시간초과    300000 x 300000 -&gt; 2중 loop를 쓰면 안됨   #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; using namespace std;  int N, K; string a[300010];  int main(int argc, char* argv[]) {     //freopen(\"input.txt\", \"r\", stdin);     freopen(\"input2.txt\", \"r\", stdin);     cin &gt;&gt; N &gt;&gt; K;         for(int i=0;i&lt;N;i++) {         cin &gt;&gt; a[i];     }     int cnt = 0;     for(int i=0;i&lt;=N-K;i++) {         //cout&lt;&lt; a[i] &lt;&lt; \"----------\" &lt;&lt;  endl;         for(int j=i+1;j&lt;=i+K &amp;&amp; j&lt;N;j++) {             if (a[i].size() == a[j].size()) cnt++;         }     }     cout &lt;&lt; cnt &lt;&lt; \"\\n\";     return 0; }         코드 - queue 이용 풀이    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;string&gt; using namespace std;  int N, K; string a[300010]; queue&lt;int&gt; q[21];  int main(int argc, char* argv[]) {     //freopen(\"input2.txt\", \"r\", stdin);     freopen(\"input.txt\", \"r\", stdin);     cin &gt;&gt; N &gt;&gt; K;          string str;      long long cnt = 0;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; str;         int size = str.length();          while (!q[size].empty() &amp;&amp; i - q[size].front() &gt; K) {             q[size].pop();         }         cnt += q[size].size(); // queue&#50640; n&#44060; &#46308;&#50612;&#51080;&#51004;&#47732;, n&#49933;&#51060; &#47564;&#46308;&#50612;&#51664;         q[size].push(i);     }      printf(\"%lld\\n\", cnt);     return 0; }       문제 링크    https://www.acmicpc.net/problem/3078       참고링크    https://blog.junu.dev/30 https://sooooooyn.tistory.com/19    ","categories": [],
        "tags": ["STL","queue"],
        "url": "/boj-3078/",
        "teaser": null
      },{
        "title": "BOJ 3755 Double Queue",
        "excerpt":" BOJ 3755 Double Queue     접근하기    multiset에 데이터를 저장, begin 쪽에 우선순위 큰 값, end 쪽에 작은 값 map에 우선순위를 key로 id얻도록 구성     코드    #include &lt;cstdio&gt; #include &lt;set&gt; #include &lt;map&gt; using namespace std;  // priority, clientID multiset&lt;int, greater&lt;int&gt;&gt; sp;  map&lt;int, int&gt; mp;  int main(int argc, char* argv[]) {     int cmd;     int K, P;      while(1) {         scanf(\"%d\", &amp;cmd);          switch(cmd) {         case 0:             return 0;             break;         case 1:             scanf(\"%d %d\", &amp;K, &amp;P);             mp[P] = K;         // priority -&gt; K             sp.insert(P);             break;         case 2:             if (sp.size() != 0) {                 auto it = sp.begin();                 printf(\"%d\\n\", mp[*it]);                 sp.erase(it);             } else {                 printf(\"0\\n\");             }             break;         case 3:             if (sp.size() != 0) {                 auto it = sp.end();                 it--;                 printf(\"%d\\n\", mp[*it]);                 sp.erase(it);             } else {                 printf(\"0\\n\");             }             break;         }     }      return 0; }       문제 링크    https://www.acmicpc.net/problem/3755    ","categories": [],
        "tags": ["STL","multiset"],
        "url": "/boj-3755/",
        "teaser": null
      },{
        "title": "BOJ 4358 생태학",
        "excerpt":" BOJ 4358 생태학     접근하기    getline으로 줄단위 입력으로 string 객체 받음 map 객체에 이름을 key로 빈도를 value로 받음 오름차순 정렬의 set객체에 이름을 저장 set을 순회하면서, 빈도 출력      코드    #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;set&gt; #include &lt;map&gt; #include &lt;string&gt; using namespace std;  map&lt;string, int&gt; mp; set&lt;string, less&lt;string&gt;&gt; st; // &#51665;&#54633;&#44061;&#52404;, sorted&#49345;&#53468; &#50976;&#51648;  int main(int argc, char* argv[]) {     string line;     int sum = 0;     while(getline(cin, line)) {         st.insert(line);         mp[line] += 1;         sum += 1;     }      for(auto&amp; o:st) {         printf(\"%s %.4f\\n\", o.c_str(), 100* (float)mp[o]/sum);     }          return 0; }       문제 링크    https://www.acmicpc.net/problem/4358    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-4358/",
        "teaser": null
      },{
        "title": "BOJ 6996 에너그램",
        "excerpt":" BOJ 6996 에너그램     접근하기    에너그램 판단  STL string을 sort로 정렬할 수 있음. 두 string을 sort한 후, 비교       코드    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std;  int N;  int main(int argc, char* argv[]) {     cin &gt;&gt; N;     string s1, s2;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; s1 &gt;&gt; s2;             string t1 = s1;         string t2 = s2;         sort(t1.begin(), t1.end());         sort(t2.begin(), t2.end());          if (t1 == t2){             cout &lt;&lt; s1 &lt;&lt; \" &amp; \" &lt;&lt; s2 &lt;&lt; \" are anagrams.\" &lt;&lt; endl;         } else  {             cout &lt;&lt; s1 &lt;&lt; \" &amp; \" &lt;&lt; s2 &lt;&lt; \" are NOT anagrams.\" &lt;&lt; endl;         }     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/6996    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-6996/",
        "teaser": null
      },{
        "title": "BOJ 7662 이중 우선순위 큐",
        "excerpt":" BOJ 7662 이중 우선순위 큐     접근하기    STL multiset을 이용해서 풀이 정렬된 순서로 저장함. set과 달리 중복을 허용하는 자료구조      코드    #include &lt;cstdio&gt; #include &lt;set&gt; #include &lt;algorithm&gt; using namespace std;  int T; int N;  void solve() {     multiset&lt;int, greater&lt;int&gt;&gt; sp;      scanf(\"%d\", &amp;N);     char ch;     int num;     for(int i=0;i&lt;N;i++) {         scanf(\" %c %d\", &amp;ch, &amp;num);          if (ch == 'I') {             sp.insert(num);         } else if (ch == 'D') {             if (sp.size() != 0) {                 if (num == -1) {                     auto it = sp.end();                     it--;                     //cout &lt;&lt; \"min:\" &lt;&lt;  *it &lt;&lt; endl;                     sp.erase(it);                     //cout &lt;&lt; \"size:\" &lt;&lt;  sp.size() &lt;&lt; endl;                 } else if (num == 1) {                     auto it = sp.begin();                     //cout &lt;&lt; \"max:\" &lt;&lt;  *it &lt;&lt; endl;                     sp.erase(it);                     //cout &lt;&lt; \"size:\" &lt;&lt;  sp.size() &lt;&lt; endl;                 }             }         }     }       if (sp.size() == 0) {         printf(\"EMPTY\\n\");     } else {         auto left = sp.begin();         printf(\"%d \", (int)*left);         auto right = sp.end();         right--;          printf(\"%d\\n\", (int)*right);     } }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       생각    set을 이용해서 풀었는데, 틀림 같은 데이터가 여러번 들어올 수 있겠다.      TODO min heap / max heap을 조합해서 풀이    풀이방법 생각해보기      문제 링크    https://www.acmicpc.net/problem/7662    ","categories": [],
        "tags": ["STL","multiset"],
        "url": "/boj-7662/",
        "teaser": null
      },{
        "title": "BOJ 7795 먹을 것인가 먹힐 것인가",
        "excerpt":" BOJ 7795 먹을 것인가 먹힐 것인가?    lower bound를 적용하는 문제 잘 떠오르지 않는다.      접근하기    이중 loop로 찾을 수 있지만 느릴 것. lower bound : K보다 같거나 큰 값이 처음으로 나타나는 위치  1번째 예제   A = {8, 1, 7, 3, 1} sort(B) = {1, 3, 6}  lower_bound(B, 8) = B의 마지막 주소 - B시작주소 = 3 lower_bound(B, 1) = B시작 주소 - B시작주소 = 0 lower_bound(B, 7) = B마지막 주소 - B시작주소 = 3 lower_bound(B, 3) = 3의 위치 - B시작주소 = 1 lower_bound(B, 1) = B시작 주소 - B시작주소 = 0  3 + 0 + 3 + 1 + 0 = 7      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;iostream&gt; using namespace std;  int T; int N, M;  int a[20020]; int b[20020];  void solve() {     scanf(\"%d %d\", &amp;N, &amp;M);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     for(int i=0;i&lt;M;i++) {         scanf(\"%d\", &amp;b[i]);     }      sort(b, b+M);      int sum = 0;     for(int i=0;i&lt;N;i++) {         auto it = lower_bound(b, b+M, a[i]);         sum += (int)(it - b);     }     cout &lt;&lt; sum &lt;&lt; endl; }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);          for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/7795    ","categories": [],
        "tags": ["STL","이분탐색"],
        "url": "/boj-7795/",
        "teaser": null
      },{
        "title": "BOJ 9093 단어 뒤집기",
        "excerpt":" BOJ 9093 단어 뒤집기     접근하기    getline으로 한줄 입력받기 istringstream 이용 token으로 분리하기 std::reverse를 이용해서 string 뒤집기      코드    #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std;  int N;  int main(int argc, char* argv[]) {     cin &gt;&gt; N;     char split_char = ' ';     for(int i=0;i&lt;N;i++) {         string line;         getline(cin &gt;&gt; ws, line);         istringstream split(line);         for(string each; getline(split, each, split_char);) {             reverse(each.begin(), each.end());             cout &lt;&lt; each &lt;&lt; \" \";         }         cout &lt;&lt; endl;     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/9093    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-9093/",
        "teaser": null
      },{
        "title": "BOJ 2805 나무 자르기",
        "excerpt":" BOJ 2805 나무 자르기     접근하기    이분탐색을 배우는 문제      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N;  long long M; int a[1000010];  long long calc(int height) {     long long sum = 0;     for(int i=0;i&lt;N;i++) {         int val = a[i] - height;         if (val &lt; 0) val = 0;          sum += val;     }          return sum; }  int main(int argc, char* argv[]) {     //freopen(\"input.txt\", \"r\", stdin);     //freopen(\"input2.txt\", \"r\", stdin);     scanf(\"%d %lld\", &amp;N, &amp;M);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+N);      int left = 0;     int right = 1000000000;      int ans = 0;     while(left &lt;= right) {         int mid = (left + right) / 2;         long long ret = calc(mid);         //printf(\"mid %d ret : %lld\\n\", mid, ret);         if(ret &gt;= M) {             ans = mid;                 left = mid + 1;          } else {             right = mid-1;         }     }     printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2805      TODO 참고자료    이분탐색 헷갈리지 않게 구현하기    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-2805/",
        "teaser": null
      },{
        "title": "BOJ 12605 단어 순서 뒤집기",
        "excerpt":" BOJ 12605 단어 순서 뒤집기     접근하기    공백이 있는 문자열을 입력받기 토큰으로 분리 vector에 저장 vector를 역순으로 순회      코드    #include &lt;iostream&gt; #include &lt;sstream&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;vector&gt;  using namespace std; int T;  void solve(int tc) {     string s;     getline(cin &gt;&gt; ws, s);      // &#53664;&#53360;&#51004;&#47196; &#48516;&#47532;, vector&#50640; &#51200;&#51109;     char split_char = ' ';     istringstream split(s);     vector&lt;string&gt; tok;     for(string each; getline(split, each, split_char);) {         tok.push_back(each);     }      cout &lt;&lt; \"Case #\" &lt;&lt; tc &lt;&lt; \": \";     // vector&#47484; &#50669;&#49692;&#51004;&#47196; &#49692;&#54924;     for (auto it = tok.rbegin(); it != tok.rend(); it++) {         cout &lt;&lt; *it &lt;&lt; \" \";     }     cout &lt;&lt; endl; }  int main(int argc, char* argv[]) {     cin &gt;&gt; T;     for(int tc=1;tc&lt;=T;tc++) {         solve(tc);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/12605    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-12605/",
        "teaser": null
      },{
        "title": "BOJ 8595 히든넘버",
        "excerpt":" BOJ 8595 히든넘버     접근하기    숫자를 만나면, 배열에 담는다. 문자를 만나면, 배열에서 숫자를 꺼내서 sum한다. 맨 마지막 숫자를 처리가 안될 수 있믐을 주의      코드    #include &lt;cstdio&gt;  char str[5000050]; int arr[10]; int idx; int N; long long sum = 0;  void calc() {     if (idx != 0) {         int num = 0;             for(int i=0;i&lt;idx;i++) {             num = num * 10 + arr[i];         }         idx = 0;         sum += num;     }   }  int main(int argc, char* argv[]) {     sum = 0;     idx = 0;     scanf(\"%d\", &amp;N);      scanf(\"%s\", str);      for(int i=0;i&lt;N;i++) {         if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') {             arr[idx++] = str[i] - '0';          } else {             calc();         }      }      calc(); // &#47592; &#47560;&#51648;&#47561; &#49707;&#51088;&#45716; &#47924;&#49884;&#46104;&#48064;&#47196;, loop&#46244;&#50640; &#45796;&#49884; check     printf(\"%lld\\n\", sum); }        코드 - 배열 끝에 marker를 주기 - calc를 한번만 호출 가능    ...     scanf(\"%d\", &amp;N);      scanf(\"%s\", str);     str[N++] = 'X'; // marker     for(int i=0;i&lt;N;i++) {         if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') {             arr[idx++] = str[i] - '0';          } else {             calc();         }      }      printf(\"%lld\\n\", sum); }       문제 링크    https://www.acmicpc.net/problem/8595    ","categories": [],
        "tags": ["배열"],
        "url": "/boj-8595/",
        "teaser": null
      },{
        "title": "BOJ 11723 집합",
        "excerpt":" BOJ 11723 집합    STL bitset을 연습할 수 있는 문제 20bit이므로 uint를 이용해서 풀어도 됨      접근하기    STL bitset으로 20bit의 길이를 잡고, 풀이     코드 : STL bitset을 이용한 풀이    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;bitset&gt; using namespace std;  int main(int argc, char* argv[]) {     //freopen(\"input.txt\", \"r\", stdin);     ios_base::sync_with_stdio(false);     cin.tie(NULL);      int N;     cin &gt;&gt; N;     bitset&lt;20&gt; s;     s.reset();     for(int i=0;i&lt;N;i++) {         string cmd;         cin &gt;&gt; cmd;          int idx;         if (cmd == \"add\") {         cin &gt;&gt; idx;         s.set(idx-1, true);         } else if( cmd == \"check\") {             cin &gt;&gt; idx;             if (s.test(idx-1)) {                 cout &lt;&lt; 1 &lt;&lt; \"\\n\"; // endl&#51012; &#50416;&#47732; &#49884;&#44036;&#52488;&#44284;             } else {                 cout &lt;&lt; 0 &lt;&lt; \"\\n\";             }         } else if (cmd == \"remove\") {             cin &gt;&gt; idx;             s.set(idx-1, 0);         } else if (cmd == \"toggle\") {             cin &gt;&gt; idx;             s.flip(idx-1);         } else if (cmd == \"all\") {             s.set();         } else if (cmd == \"empty\") {             s.reset();         }     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/11723    ","categories": [],
        "tags": ["STL","bitest"],
        "url": "/boj-11723/",
        "teaser": null
      },{
        "title": "BOJ 12813 이진수 연산",
        "excerpt":" BOJ 12813 이진수 연산     접근하기    STL bitset을 이용하면, 긴 자리수의 bit연산을 할 수 있다.  100000 bit이므로 uint등으로는 안됨  각 자리수만 숫자가 바뀌므로, 문자열을 탐색하면서 푸는 것도 가능할 것임      코드 : STL bitset을 이용한 풀이    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;bitset&gt; #include &lt;string&gt;  using namespace std;  int main(int argc, char* argv[]) {     string str1, str2;     cin &gt;&gt; str1 &gt;&gt; str2;     bitset&lt;100000&gt; a(str1);     bitset&lt;100000&gt; b(str2);     cout &lt;&lt; (a &amp; b) &lt;&lt; endl;     cout &lt;&lt; (a | b) &lt;&lt; endl;     cout &lt;&lt; (a ^ b) &lt;&lt; endl;     cout &lt;&lt; (~a) &lt;&lt; endl;     cout &lt;&lt; (~b) &lt;&lt; endl;     return 0; }       문제 링크    https://www.acmicpc.net/problem/12813    ","categories": [],
        "tags": ["STL","bitest"],
        "url": "/boj-12813/",
        "teaser": null
      },{
        "title": "BOJ 13701 중복제거",
        "excerpt":" BOJ 13701 중복제거    메모리제한 8M      접근하기    배열로 선언하고, 각 bit를 숫자로 매핑하는 방법 써야 함 정수 A1, A2, &#x2026; An을 각 bit에 mapping하기      배열의 byte 크기 계산             단위 byte 수     1 byte 8 bits    1 Kb 2^10 bytes    1 Mb 2^20 bytes    1 Gb 2^30 bytes    1 Tb 2^40 bytes      unsigned int a[(1&lt;&lt;25)/32]; 크기 재기 (gdb) p sizeof(a) $1 = 4194304 (gdb) p sizeof(a) / 1048576 (1Mb를 bite로 표시) $3 = 4             # a배열크기 4MB  (gdb) p sizeof(a) / (1&lt;&lt;20) $4 = 4    그냥 int 배열을 쓰면, 4*32만큼의 크기가 필요하므로 메모리 제한에 걸림   &gt;&gt;&gt; # int배열 1&lt;&lt;25크기 ... 4*(1&lt;&lt;25) / 2**20 128.0    &gt;&gt;&gt; (4*(1&lt;&lt;25)/32)/2**20 4.0     코드 - 배열 이용 풀이    #include &lt;cstdio&gt;  unsigned int a[(1&lt;&lt;25)/32];  int main(int argc, char*argv[]) {     int num;     while(scanf(\"%d\", &amp;num) != EOF) {         if ((a[(num/32)] &amp; (1&lt;&lt; num%32)) == 0) {             a[(num/32)] = a[(num/32)] | (1&lt;&lt; num%32);             printf(\"%d \", num);         }     }     printf(\"\\n\");     return 0; }       코드 - STL bitset 이용 풀이    #include &lt;cstdio&gt; #include &lt;bitset&gt; using namespace std;  int main(int argc, char*argv[]) {     int num;     bitset&lt;(1&lt;&lt;25)&gt; s;     while(scanf(\"%d\", &amp;num) != EOF) {         if (s.test(num-1) == false) {             s.set(num-1, 1);             printf(\"%d \", num);         }     }     printf(\"\\n\");     return 0; }      문제 링크    https://www.acmicpc.net/problem/13701    ","categories": [],
        "tags": ["STL","bitset","비트연산","메모리최적화"],
        "url": "/boj-13701/",
        "teaser": null
      },{
        "title": "BOJ 1251 단어 나누기",
        "excerpt":" BOJ 1251 단어 나누기     접근하기    단어를 3개의 조각으로 나누기 처음과 끝을 제외하고, 중간에 두 점을 정한다.      코드 - STL string 이용    #include &lt;cstdio&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std;   string f(int s, int e, string ref) {     string tmp = ref.substr(s, e-s+1);     reverse(tmp.begin(), tmp.end());     return tmp; }  int main(int argc, char* argv[]) {     char str[60];     scanf(\"%s\", str);     string input(str);     int N = input.length();     string prev(N, 'z');     for(int i=1;i&lt;N-1;i++) {         for(int j=i+1;j&lt;N;j++) {             if (N-j&gt;=1) {                 string tmp = \"\";                 tmp += f(0, i-1, input);                 tmp += f(i, j-1, input);                 tmp += f(j, N-1, input);                 if (prev &gt; tmp) {                     prev = tmp;                 }             }         }     }     printf(\"%s\\n\", prev.c_str());     return 0; }      코드 - 그냥 구현    #include &lt;stdio.h&gt;  char str[60]; char a[60]; int idx; int N;   int my_strcmp(char* p1, char* p2) {     while(*p1 != '\\0' &amp;&amp; *p1 == *p2) {         p1++;         p2++;     }     return (int)*p1 - (int)*p2; }  void my_strcpy(char* p1, char* p2) {     while(*p2 != '\\0') {         *p1 = *p2;         p1++;         p2++;     }     *p1 = '\\0'; }  void f(int s, int e) {     for(int i=e;i&gt;=s;i--) {         a[idx++] = str[i];     }     a[idx] = '\\0'; }  int main(int argc, char* argv[]) {     scanf(\"%s\", str);     for(N=0;str[N];N++);      char ret[60];     bool first = true;     for(int i=1;i&lt;N-1;i++) {         for(int j=i+1;j&lt;N;j++) {             if (N-j&gt;=1) {                 idx = 0;                 f(0, i-1);                 f(i, j-1);                 f(j, N-1);                 if (first) {                     my_strcpy(ret, a);                     first = false;                 } else {                     if (my_strcmp(a, ret) &lt; 0) {                         my_strcpy(ret, a);                     }                               }             }         }     }     printf(\"%s\\n\", ret);     return 0; }        문제 링크    https://www.acmicpc.net/problem/1251    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-1251/",
        "teaser": null
      },{
        "title": "BOJ 1715 카드 정렬하기",
        "excerpt":" BOJ 1715 카드 정렬하기     접근하기    STL priority queue로 Min Heap을 선언해서 사용한다. 작은 값을 두개씩 꺼내서, 계속 더한다. 1개가 남을 때까지      코드    #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std;  int N; // int &#51088;&#47308;&#54805;&#51032; min heap priority_queue &lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);         q.push(num);     }      int sum = 0;     while(q.size() &gt;= 2) {         int n1 = q.top(); q.pop();         int n2 = q.top(); q.pop();         sum += n1 + n2;         q.push(n1+n2);     }      printf(\"%d\\n\", sum);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1715    ","categories": [],
        "tags": ["STL","priority_queue"],
        "url": "/boj-1715/",
        "teaser": null
      },{
        "title": "BOJ 20501 Facebook",
        "excerpt":" BOJ 20501 Facebook     접근하기    bit의 길이가 2000으로 길어서, STL의 bitset을 이용함 AND 연산으로 1의 개수를 세면 된다.      코드    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;bitset&gt;  using namespace std;  int N, Q;  bitset&lt;2001&gt; a[2001];  int main(int argc, char* argv[]) {     ios::sync_with_stdio(false);     cin.tie(nullptr);     cin &gt;&gt; N;     string str;      for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; str;          bitset&lt;2001&gt; tmp(str);         a[i] = tmp;     }      cin &gt;&gt; Q;     int n1, n2;     for(int i=1;i&lt;=Q;i++) {         cin &gt;&gt; n1 &gt;&gt; n2;         cout &lt;&lt; (a[n1] &amp; a[n2]).count() &lt;&lt; \"\\n\";     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/20501    ","categories": [],
        "tags": ["STL","bitset"],
        "url": "/boj-20501/",
        "teaser": null
      },{
        "title": "BOJ 13913 숨바꼭질 4",
        "excerpt":" BOJ 13913 숨바꼭질 4     접근하기    BFS 순서로 점을 이동하여, 목표 위치에 제일먼저 닿으면, 최단거리 1, -1 이동은 왔다갔다를 무한반복할 수 있음. visit배열로 중복 처리를 제외함 path출력은 stack 순서로 출력    #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std;  int N, K;  typedef struct Node {     int pos;     int depth; } Node;  queue&lt;Node&gt; q; int const MV = 100000; bool visit[100010]; int path[100010];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;K);      for(int i=0;i&lt;=100000;i++) path[i] = -1;      q.push({N, 0});     path[N] = N;     visit[N] = true;      stack &lt;int&gt; sp;     while(!q.empty()) {         Node cur = q.front(); q.pop();          if (cur.pos == K) {             printf(\"%d\\n\", cur.depth);              int pos = cur.pos;             while(pos != N) {                 sp.push(pos);                 pos = path[pos];             }             sp.push(pos);              while(!sp.empty()) {                 int val = sp.top(); sp.pop();                 printf(\"%d \", val);             }             printf(\"\\n\");             break;         }          int pos = cur.pos;         int depth = cur.depth;          if (pos + 1 &lt;= MV &amp;&amp; visit[pos+1] == false) {             Node next = {pos + 1, depth + 1};             path[pos + 1] = pos;             visit[pos + 1] = true;             q.push(next);         }         if (pos - 1 &gt;= 0 &amp;&amp; visit[pos-1] == false) {             Node next = {pos - 1, depth + 1};             path[pos - 1] = pos;             visit[pos - 1] = true;             q.push(next);         }         if (pos * 2 &lt;= MV &amp;&amp; visit[pos*2] == false) {             Node next = {pos * 2, depth + 1};             path[pos * 2] = pos;             visit[pos * 2] = true;             q.push(next);         }     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/13913    ","categories": [],
        "tags": ["STL","BFS"],
        "url": "/boj-13913/",
        "teaser": null
      },{
        "title": "달의 연인(보보경심 려)",
        "excerpt":" 달의 연인(보보경심 려)     메시지    \"지키고 싶은 걸 지켰는데, 대가는 치뤄야죠.\"  \"지나치게 앞일에 메여, 지금 가진 걸 잃진 마라.\"  \"상황이 바뀌지 않으면, 내가 바뀌어야지.\"  \"부생\"  \"직접 겪은 것도 아님, 좋아하는 분을 믿어드려야 하는거 아니냐?\"  \"누굴 좋아하는 마음은 절대 햇갈리지 않습니다.\"  \"니가 어떤 결정을 하냐에 따라, 나도 마음을 정하마.\"  \"황궁의 주인이 되고 싶으면, 뭔가는 포기를 해야지?\"  \"후회하지 않아요. 무슨 일을 할만한 가치가 있는지 없는지는, 자기만 아는 것이니까요.\"  \"좋은 날이 있으면, 나쁜 날도 있는 거니까요. 그런 날도 다 지나가고요.\"      얻은 것 vs 잃은 것    닥칠 미래를 알기에 지금이 불안한 해수 미래를 아는건 축복만은 아닌 듯 하다.     황제의 자리에 올랐으나 사랑하는 여인을 부인으로 삼지 못하고 수연을 외치며 죽어간 태조     왕실의 막강한 권력을 가졌으나 정작 왕건의 사랑을 얻지 못했던 황후     정윤이라는 모두가 갖고자 했던 자리를 업이라 여겼던 무     엄마의 야망을 자신의 것이라 생각했으나 마지막 순간 아들로 위로받고자 했던 요     가문과 여동생을 지키느라 위해 해수의 마음을 지키지 못한 욱     사모하는 황자를 얻었으나 끝까지 은애한다는 말을 듣지 못하고 죽은 해씨부인     미남으로 태어나, 고려 여인들의 인기를 얻었으나 해씨부인을 평생 연모하기만 했던 백아     황제의 자리를 얻었으나 해수를 잃은 소     철없고 순수하기만 하다 어린 나이에 죽은 은     첫사랑을 이뤘지만, 사랑을 지키려고 죽음을 받아들였던 순덕     딸의 선택을 존중하고, 딸의 시신을 받았던 박수경 장군       누구도 믿어서는 안된다.    왕실안의 권력암투를 재미있게 그려냈다.     나의 선의가 누군가의 악의에 이용될 때, 너무 무서운 결과가 나온다는 걸 드라마에서 계속 보여준다.     결국 철저히 혼자여야 하고, 누군도 믿어선 안된다는 드라마 초반의 대사는 복선이었다.     친구에게 배신당한 현대의 고하진은 고려로 와서도 비슷한 일을 겪는다.       링크    명대사       줄거리    1회 2회 3회 4회 5회 6회 7회 8회 9회 10회 11회 12회 13회 14회 15회 16회 17회 18회 19회    ","categories": [],
        "tags": ["culture"],
        "url": "/MoonLovers/",
        "teaser": null
      },{
        "title": "abc224 C - Triangle?",
        "excerpt":" C - Triangle?     접근하기    N이 300이하, 3중 루프로 다른 세점을 뽑아서, 삼각형판별 조건을 확인해도 됨 300 x 300 x 300 = 27000000 (2700만)  삼각형 판별은 editorial로 확인함 삼각형 면적 공식에서 이용함   1/2 * | (x2 - x1)(y3 - y1) - (x3 - x1)(y2 - y1) |    value가 0이면, 세개의 점이 같은 라인에 있음을 의미한다.      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N;  typedef struct Node {     int x;     int y; } Node;  Node pool[310];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;pool[i].x, &amp;pool[i].y);     }      int ans = 0;     for(int i=0;i&lt;N-2;i++) {         for(int j=i+1;j&lt;N-1;j++) {             for(int k=j+1;k&lt;N;k++) {                 if (((pool[j].x - pool[i].x) * (pool[k].y - pool[i].y) -                   (pool[k].x - pool[i].x) * (pool[j].y - pool[i].y)) != 0) {                     ans++;                 }             }         }     }     printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://atcoder.jp/contests/abc224/tasks/abc224_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc224-c-upsolve/",
        "teaser": null
      },{
        "title": "BOJ 16956 늑대와 양",
        "excerpt":" BOJ 16956 늑대와 양     접근하기    S 주위에 동서남북으로 W가 없으면, D를 넣는다. W가 있으면, 0을 출력하고 종료     코드    #include &lt;cstdio&gt;  int R, C; int map[501][501];  int dy[4] = {1, -1, 0,  0}; int dx[4] = {0,  0, 1, -1};  bool safe(int y, int x) {     return (0&lt;=y &amp;&amp; y&lt;R) &amp;&amp; (0&lt;=x &amp;&amp; x&lt;C); }  bool check(int y, int x) {     bool bok = true;     for(int i=0;i&lt;4;i++) {         int ny = y + dy[i];         int nx = x + dx[i];         if (safe(ny, nx) &amp;&amp; map[ny][nx] == 2) {             bok = false;         }      }     return bok; }  void draw(int y, int x) {     for(int i=0;i&lt;4;i++) {         int ny = y + dy[i];         int nx = x + dx[i];         if (safe(ny, nx) &amp;&amp; map[ny][nx] == 0) {             map[ny][nx] = 3;         }      } }   int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;R, &amp;C);     char str[510];      for(int i=0;i&lt;R;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             if (str[j] == 'S') {                 map[i][j] = 1;             } else if (str[j] == 'W') {                 map[i][j] = 2;             }         }     }  #if 0     for(int i=0;i&lt;R;i++) {         for(int j=0;j&lt;C;j++) {             printf(\"%d\", map[i][j]);         }         printf(\"\\n\");     } #endif      for(int i=0;i&lt;R;i++) {         for(int j=0;j&lt;C;j++) {             if (map[i][j] == 1) {                 bool bok = check(i, j);                  if (bok) {                     // draw map;                     draw(i, j);                 } else {                     printf(\"0\\n\");                     return 0;                 }             }         }     }      printf(\"1\\n\");     for(int i=0;i&lt;R;i++) {         for(int j=0;j&lt;C;j++) {             if (map[i][j] == 0)                 printf(\".\");             else if (map[i][j] == 1)                 printf(\"S\");             else if (map[i][j] == 2)                 printf(\"W\");             else if (map[i][j] == 3)                 printf(\"D\");         }         printf(\"\\n\");     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/16956    ","categories": [],
        "tags": ["구현"],
        "url": "/boj-16956/",
        "teaser": null
      },{
        "title": "BOJ 2295 세 수의 합",
        "excerpt":" BOJ 2295 세 수의 합     접근하기    a + b + c = D로 하고 a, b, c를 3중 loop로 하면, 시간초과 a + b = D - c이면, 1000x1000 = 100만      코드           문제 링크    https://www.acmicpc.net/problem/2295    ","categories": [],
        "tags": ["구현"],
        "url": "/boj-2295/",
        "teaser": null
      },{
        "title": "BOJ 5567 결혼식",
        "excerpt":" BOJ 5567 결혼식     접근하기    DFS로 두 단계를 내려간다. BFS에서 depth를 잰다.      코드 - DFS    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt;  using namespace std;  int N, M; int visit[501]; vector&lt; int &gt; vp[501]; //int ans;  void dfs(int k, int depth) {     if (depth &gt;= 2) return;      for(auto&amp; next:vp[k]) {         //if (visit[next] == 0) { // &#53952;&#47548;         visit[next] = 1;         dfs(next, depth + 1);         //}     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     scanf(\"%d\", &amp;M);      int p1, p2;     for(int i=0;i&lt;M;i++) {         scanf(\"%d %d\", &amp;p1, &amp;p2);         vp[p1].push_back(p2);         vp[p2].push_back(p1);     }      dfs(1, 0);     int cnt = 0;     for(int i=2;i&lt;=N;i++) {         if(visit[i]) cnt++;     }     printf(\"%d\\n\", cnt);     return 0; }       코드 - BFS    visit[1] = 1 이면 1번 visit[2] = visit[1] + 1 = 2   // depth 1 : 친구 visit[3] = visit[1] + 1 = 2   // depth 1 : 친구 visit[4] = visit[3] + 1 = 3   // depth 2 : 친구의 친구 visit[5] = visit[4] + 1 = 4   2와 3을 세면 된다.    #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt;  using namespace std;  int N; int M;  vector &lt;int&gt; G[501]; // &#51064;&#51217; &#47532;&#49828;&#53944;&#47196; &#44396;&#54788; queue &lt;int&gt; q;        int idx; int visit[501];  void bfs(int start) {     idx = 0;     visit[1] = 1;     q.push(start);       // 1&#48264;&#51012; Q&#50640; &#45347;&#44592;      while(!q.empty()) {         int current = q.front();         q.pop();          for(auto&amp; next:G[current]) {             if (visit[next] == 0) {                 visit[next] = visit[current] + 1;                 q.push(next);             }              }     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     scanf(\"%d\", &amp;M);      for(int i=0;i&lt;M;i++) {         int p1, p2;             scanf(\"%d %d\", &amp;p1, &amp;p2);         G[p1].push_back(p2);         G[p2].push_back(p1);     }      bfs(1);         int cnt = 0;     for(int i=2;i&lt;=N;i++) {         if (visit[i] == 2 || visit[i] == 3) {             cnt += 1;         }     }     printf(\"%d\\n\", cnt);     return 0; }        문제 링크    https://www.acmicpc.net/problem/5567    ","categories": [],
        "tags": ["DFS"],
        "url": "/boj-5567/",
        "teaser": null
      },{
        "title": "org-babel로 script 구동하기",
        "excerpt":" 환경설정    C-c C-c 누르면 됨    C, python, shell을 활성화    .emacs에 다음을 넣어준다.   (org-babel-do-load-languages  'org-babel-load-languages  '((emacs-lisp . t)    (C . t)    (python . t)    (shell . t)    ))       yes/no 질문없이 code블록 실행하기    (defun my-org-confirm-babel-evaluate (lang body)   (not (string= lang \"ditaa\"))   (not (string= lang \"C\"))   (not (string= lang \"python\"))   (not (string= lang \"shell\")) )  ;don't ask for ditaa (setq org-confirm-babel-evaluate #'my-org-confirm-babel-evaluate)    Code Evaluation Security shell은 그래도 yes/no prompt가 뜬다.       python - hello world 출력    코드    #+BEGIN_SRC python :results output :exports both print(\"Hello\") #+END_SRC  #+RESULTS: : Hello    소스 export    print(\"Hello\")     결과    Hello       bash - hello world 출력    #+begin_src shell :results output :exports both   echo \"Hello World\" #+end_src  #+RESULTS: : Hello World     echo \"Hello World\"     Hello World       dot graph 만들기    파일 위치를 저장하고, export하는 config 작성 필요             참고자료    Babel: Active Code in Org Mode    ","categories": [],
        "tags": ["org-mode"],
        "url": "/org-bable-test/",
        "teaser": null
      },{
        "title": "BOJ 10822 바구니 순서 바꾸기",
        "excerpt":" BOJ 10822 바구니 순서 바꾸기     접근하기    begin, begin + 1, &#x2026; , mid -1 , mid, &#x2026; , end-1, end mid, mid+1, &#x2026;, end-1, end, begin, begin+1, mid-1 로 변경 뒷부분을 앞으로 가져오고, 앞부분을 뒤로 보냄      코드 - 배열로 풀기    #include &lt;stdio.h&gt;  int N, M; int a[101]; int temp[101];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);     for(int i=1;i&lt;=N;i++) {         a[i] = i;     }       int left, right, mid;     for(int i=0;i&lt;M;i++) {         scanf(\"%d %d %d\", &amp;left, &amp;right, &amp;mid);          int k = 1;         for(int j=mid;j&lt;=right;j++) {             temp[k++] = a[j];         }         for(int j=left;j&lt;mid;j++) {             temp[k++] = a[j];         }          for(int j=left, x=1;j&lt;=right;j++) {             a[j] = temp[x++];         }     }      for(int i=1;i&lt;=N;i++) {         printf(\"%d \", a[i]);     }     printf(\"\\n\");     return 0; }       코드 - STL rotate로 풀기    vector 생성자에서 N을 주면, 배열처럼 사용 std::rotate로 바꿈 오른쪽으로 회전   #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int main(int argc, char* argv[]) {     int N, M;     scanf(\"%d %d\", &amp;N, &amp;M);     vector &lt;int&gt; v(N);       for(int i=1;i&lt;=N;i++) {         v[i-1] = i;     }     for(int i=0;i&lt;M;i++) {         int left, right, mid;         scanf(\"%d %d %d\", &amp;left, &amp;right, &amp;mid);         rotate(v.begin() + (left-1) , v.begin() + (mid-1), v.begin() + right);      }      for(auto e :v) {         printf(\"%d \", e);     }     printf(\"\\n\");     return 0; }       문제 링크    https://www.acmicpc.net/problem/10812    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-10812/",
        "teaser": null
      },{
        "title": "abc231 C - Counting 2",
        "excerpt":" C - Counting 2    배열이 주어지고, 질문의 x보다 크거나 같은 숫자의 개수 세기      접근하기    이중 loop로 그냥 찾으면, TLE가 날 것 sort + lower_bound를 이용함      코드    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N, Q;  int a[200020]; int q[200020];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;Q);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+N);     int val;     for(int i=0;i&lt;Q;i++) {         scanf(\"%d\", &amp;val);         cout &lt;&lt; N- (lower_bound(a, a+N, val) - a) &lt;&lt; \"\\n\";     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc231/tasks/abc231_c    ","categories": [],
        "tags": ["AtCoder","최적화"],
        "url": "/abc231-c/",
        "teaser": null
      },{
        "title": "D - Neighbors",
        "excerpt":" D - Neighbors    N명의 사람의 줄세울 때, 서로 인접하게 줄 세우기       접근하기    인접은 서로다른 두명만 있어야 조건에 만족    1 2 3 3 2 1   cycle이 있어서도 안됨. -&gt; UnionFind나 Dfs로 Cycle을 만드는지 확인하기       코드1 - UnionFind 이용    #include &lt;cstdio&gt; #include &lt;iostream&gt;  using namespace std;  int N, M;  #define ARRSIZE 100010 int table[ARRSIZE];  // Union Find int parent[ARRSIZE];  void Init() {     for(int i=0;i&lt;=N;i++) {         parent[i] = -1;     } }  int Find(int a) {     if (parent[a] &lt; 0) return a;     return parent[a] = Find(parent[a]); }  void Union(int a, int b) {     a = Find(a);     b = Find(b);      if (a == b) return;      if (parent[a] &lt;= parent[b]) {         parent[a] += parent[b];         parent[b] = a;     } else {         parent[b] += parent[a];         parent[a] = b;     } }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      int n1, n2;      Init();     for(int i=0;i&lt;M;i++) {         scanf(\"%d %d\", &amp;n1, &amp;n2);          int tmp1 = Find(n1);         int tmp2 = Find(n2);         if (tmp1 == tmp2) {             printf(\"No\\n\");             return 0;         }         Union(n1, n2);         table[n1]++;         table[n2]++;     }      for(int i=0;i&lt;=N;i++) {         if (table[i] &gt; 2) {             printf(\"No\\n\");             return 0;         }     }     printf(\"Yes\\n\");     return 0; }       문제 링크    https://atcoder.jp/contests/abc231/tasks/abc231_d    ","categories": [],
        "tags": ["AtCoder","UnionFind"],
        "url": "/abc231-d-upsolving/",
        "teaser": null
      },{
        "title": "TODO E - Minimal payments",
        "excerpt":" TODO E - Minimal payments    DP로 풀이할 것. 생각 조합이 잘 안됨      접근하기     코드           문제 링크    https://atcoder.jp/contests/abc231/tasks/abc231_e    ","categories": [],
        "tags": ["AtCoder","DP","TODO"],
        "url": "/abc231-e/",
        "teaser": null
      },{
        "title": "BOJ 11052 카드 구매하기",
        "excerpt":" BOJ 11052 카드 구매하기    카드팩의 종류가 있음 P1 : 카드 1장 들어있음 P2 : 카드 2장 들어있음 지불해야 하는 금액의 최대값     접근하기    예제 분석하기 5 10 9 8 7 6  1장 살때 10 2장 살때 9 3장 살때 8 4장 살때 7 5장 살때 6  dp[0] = 0 dp[1] = max(dp[1], dp[1-1] + a[1] = 10) = 10  dp[2] = max(dp[2], dp[2-1] + a[1]                    dp[2-2] + a[2]) = 20, 9 = 20,   dp[2] = 20  dp[3] = max(dp[3], dp[3-1] + a[1],                     dp[3-2] + a[2],                     dp[3-3] + a[3]) = 30, 18, 8,    dp[3] = 30  dp[4] = max(dp[4], dp[4-1] + a[1]   30 + 10 = 40                    dp[4-2] + a[2]   20 + 9  = 29                    dp[4-3] + a[3]   10 + 8  = 18                    dp[4-4] + a[4]   0 + 6  = 6     dp[4] = 40  dp[5] = max(dp[5], dp[5-1] + a[1]    50                    dp[5-2] + a[2]    29                    dp[5-3] + a[3]    28                    dp[5-4] + a[4]    17                    dp[5-5] + a[5]    6             dp[5] = 50             점화 관계 dp[i] = max(dp[i], dp[i-j] + a[j])      코드    #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; using namespace std;  int N; char str[60];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     vector &lt;string&gt; vp(N);         char str[60];     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         string s(str);         vp[i] = s;     }     sort(vp.begin(), vp.end());       int ans = 1;     int cnt = 1;     string out = vp[0];     for(int i=1;i&lt;(int)vp.size();i++) {         if (vp[i-1] == vp[i]) {             cnt++;         } else {             cnt = 1;         }         if (ans &lt; cnt) {             ans = cnt;             out = vp[i];         }     }     printf(\"%s\\n\", out.c_str());     return 0; }       문제 링크    https://www.acmicpc.net/problem/11052    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-11052/",
        "teaser": null
      },{
        "title": "BOJ 16194 카드 구매하기 2",
        "excerpt":" BOJ 16194    N개의 카드를 갖기 위해 지불해야 하는 최솟값      접근하기    4 1 5 6 7    --&gt; 4   dp[k] = k장의 카드를 갖기 위해 지불해야 하는 최소값  dp[0] = 0  dp[1] = MIN(dp[1], dp[1-1] + a[1]) = 1,    dp[1] = 1   dp[2] = MIN(dp[2], dp[2-1] + a[1], 2                     dp[2-2] + a[2], 5       dp[2] = 2  dp[3] = MIN(dp[3], dp[3-1] + a[1], 3                    dp[3-2] + a[2], 7                    dp[3-2] + a[3], 8       dp[3] = 3   dp[4] = MIN(dp[4], dp[4-1] + a[1], 4                     dp[4-2] + a[2], 7                    dp[4-3] + a[3], 7                    dp[4-4] + a[4], 7       dp[4] = 4  이중 루프 형태로 구성됨  점화식 dp[i] = min(dp[i], dp[i-j] + a[j])       코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N;  int a[1001]; int dp[1001];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }      for(int i=1;i&lt;=N;i++)         dp[i] = 987654321;      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=i;j++) {             dp[i] = min(dp[i], dp[i-j] + a[j]);         }     }     printf(\"%d\\n\", dp[N]);     return 0; }       문제 링크    https://www.acmicpc.net/problem/16194    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-16194/",
        "teaser": null
      },{
        "title": "BOJ 16194 1,2,3 더하기 5",
        "excerpt":" BOJ 16194 1,2,3 더하기 5    1,2,3 을 이용해서 정수 N을 만드는 경우의 수를 구함 같은 수를 두번 이상 사용하면 안된다는 조건이 있음     접근하기     점화식 아이디어  dp[숫자][1로끝나는경우] dp[숫자][2로끝나는경우] dp[숫자][3로끝나는경우]   1을 만드는 경우 1 dp[1][1] = 1 dp[1][2] = 0 dp[1][3] = 0  2를 만드는 경우 1 dp[2][1] = 0 dp[2][2] = 1 dp[2][3] = 0   3을 만드는 경우 3 1 + 1 + 1     dp[3][1] = 1 1 + 2         dp[3][2] = 1 3             dp[3][3] = 1  dp[7][1] = dp[6][2] + dp[6][3] dp[7][2] = dp[5][1] + dp[5][3] dp[7][3] = dp[4][1] + dp[4][2]      코드    // https://jdselectron.tistory.com/71 #include &lt;cstdio&gt; using namespace std;  #define MOD 1000000009  int T; int N; unsigned int dp[100010][3];  // 10&#50613;&#50473; 3&#48264; &#45908;&#54616;&#45716; &#44221;&#50864;&#44032; &#51080;&#51020; - uint&#45208; long long  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);   //   dp[0][1] = 0;   //   dp[0][2] = 0;   //   dp[0][3] = 0;       dp[1][1] = 1;   //   dp[1][2] = 0;   //   dp[1][3] = 0;    //   dp[2][1] = 0;      dp[2][2] = 1;   //   dp[2][3] = 0;       dp[3][1] = 1;      dp[3][2] = 1;      dp[3][3] = 1;       for(int i=4;i&lt;=100000;i++) {         dp[i][1] = (dp[i-1][2]%MOD + dp[i-1][3]%MOD)%MOD;          dp[i][2] = (dp[i-2][1]%MOD + dp[i-2][3]%MOD)%MOD;         dp[i][3] = (dp[i-3][1]%MOD + dp[i-3][2]%MOD)%MOD;     }      while(T--) {         int num;         scanf(\"%d\", &amp;num);         printf(\"%u\\n\", (dp[num][1]%MOD + dp[num][2]%MOD + dp[num][3]%MOD)%MOD);     }      return 0; }       문제 링크    https://www.acmicpc.net/problem/15990      풀이/설명 참고    velog.io/@jkh9615    ","categories": [],
        "tags": ["DP","2차원DP"],
        "url": "/boj-15990/",
        "teaser": null
      },{
        "title": "BOJ 2230 수 고르기",
        "excerpt":" BOJ 2230 수 고르기    수열에서 두 수를 골랐을 때, 차이가 M이상이면서, 제일 작은 경우      접근하기    투 포인터를 응용해서 풀기   3 3 1 5 3  M=3 정렬을 한다. a = 1 3 5  left = 0 right = 0  while(left &lt; N &amp;&amp; right &lt; N)    &lt;= 이 조건 생각이 여러움  1. 두수의 차이 &lt;  M   -&gt; right++ (N보다 작을때까지)  2. 두수의 차이 &gt;= M   -&gt; ans에 최소값 저장 ( ans는 초기에 큰 값으로 지정 )   -&gt; left++ (N보다 작을 때까지)       코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N, M; int a[100010];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+N);     int left = 0;      int right = 0;       long long ans = 2000000010;     while(left &lt; N &amp;&amp;  right &lt; N) {         long long diff = a[right] - a[left];         if (diff &lt; M) {              if (right &lt; N) right++;           } else if (diff &gt;= M) {             if (ans &gt; diff) {                 ans = diff;             }              if (left &lt; N) left++;          }     }     printf(\"%lld\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2230    ","categories": [],
        "tags": ["투포인터"],
        "url": "/boj-2230/",
        "teaser": null
      },{
        "title": "BOJ 2965 캥거루 세마리",
        "excerpt":" BOJ 2965 캥거루 세마리    정수 좌표에 3마리의 캥거루가 다른 점에 있을때, 바깥쪽 캥거루가 이동 가능할 때 최대한 이동하는 수 구하기      접근하기    차이를 세고 -1 하면 된다는 성질 발견     코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int a, b, c;  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c);     int val = max(abs(a-b), abs(b-c));     printf(\"%d\\n\", val-1);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2965    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-2965/",
        "teaser": null
      },{
        "title": "BOJ 1662 압축",
        "excerpt":" BOJ 1662 압축     접근하기    33(562(71(9))) 33(562(79)) 33(567979) 3567979567979567979 -&gt; 19      코드 - 메모리 초과    tmp string에 계속 값을 저장하고, stack에 push한 후, stack size를 재면 된다. 메모리 초과 발생   // &#47700;&#47784;&#47532; &#52488;&#44284; &#54400;&#51060; #include &lt;cstdio&gt; #include &lt;stack&gt; #include &lt;string&gt; using namespace std;  stack&lt;char&gt; st; char str[60]; string tmp;  int main(int argc, char* argv[]) {     scanf(\"%s\", str);     for(int i=0;str[i];i++) {          if (str[i] == ')') {             tmp = \"\";             while(st.top() != '(') {                 char ch = st.top();st.pop();                 tmp += ch;             }             st.pop(); // remove '('              char num = st.top(); st.pop();             int len = tmp.size();             for(int i=0;i&lt;(num-'0');i++) {                 for(int j=len-1;j&gt;=0;j--) {                     st.push(tmp[j]); // &#47700;&#47784;&#47532;&#47484; &#47566;&#51060; &#49548;&#47784;                 }             }         } else {             st.push(str[i]);         }     }     printf(\"%d\\n\", (int)st.size());     return 0; }       코드 - 숫자의 길이를 저장하고 따로 계산    #include &lt;cstdio&gt; #include &lt;stack&gt; using namespace std;  typedef struct Node {     int num;     int len;     } Node;  stack&lt;Node&gt; st; char str[60];  int main(int argc, char* argv[]) {     scanf(\"%s\", str);     for(int i=0;str[i];i++) {          if (str[i] == ')') {             int len = 0;              while(st.top().num != -1) {                 int l = st.top().len;                 st.pop();                 len += l;             }             st.pop();             int num = st.top().num;             st.pop();             st.push({num, len * num});         } else {             if (str[i] == '(') {                 st.push({-1, 1});             } else {                 st.push({str[i] - '0', 1});             }         }     }     int ans = 0;     while(!st.empty()) {         ans += st.top().len;         st.pop();     }     printf(\"%d\\n\", ans);     return 0; }      TODO 코드 - DFS 풀이    참고 https://hwan-shell.tistory.com/305     문제 링크    https://www.acmicpc.net/problem/1662    ","categories": [],
        "tags": ["스택"],
        "url": "/boj-1662/",
        "teaser": null
      },{
        "title": "BOJ 2358 평행선",
        "excerpt":" BOJ 2358 평행선    n개의 점(x,y)이 주어질 때, 가로,세로 평행선의 수를 세기      접근하기    xmap과 ymap에 각각 x, y 좌표를 key로 하고, 값을 1씩 증가 2보다 크면, (두점 이상이면), 수평선, 수직선이 된다.    4 0 0 10 10 0 10 10 0  mx[0] = 2    -&gt; 1 mx[10] = 2   -&gt; 1 my[0] = 2    -&gt; 1 my[10] = 2   -&gt; 1 --&gt; 4      코드    #include &lt;cstdio&gt; #include &lt;map&gt;  using namespace std;  int N;  map&lt;int, int&gt; mx; map&lt;int, int&gt; my;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int x, y;     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;x, &amp;y);         mx[x]++;         my[y]++;     }      int cnt = 0;     for(auto val:mx) {         if (val.second &gt;= 2) cnt++;      }      for(auto val:my) {         if (val.second &gt;= 2) cnt++;      }     printf(\"%d\\n\", cnt);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2358    ","categories": [],
        "tags": ["자료구조"],
        "url": "/boj-2358/",
        "teaser": null
      },{
        "title": "BOJ 10818 최소, 최대",
        "excerpt":" 최소, 최대    배열에서 최소, 최대값 구하기 (STL)       코드 - STL max_element / STL min_element 이용    #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     vector&lt;int&gt; v(N);     int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);         v[i] = num;     }     auto minv = min_element(v.begin(), v.end());     auto maxv = max_element(v.begin(), v.end());     printf(\"%d %d\\n\", *minv, *maxv);     return 0; }       코드 - 그냥 구현    #include &lt;stdio.h&gt;  int N; int main(int argc, char *argv[]) {     scanf(\"%d\", &amp;N);         int minv = 1000000;     int maxv = -1000000;     int a;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a);                 if (a &lt; minv) minv = a;         if (a &gt; maxv) maxv = a;     }     printf(\"%d %d\\n\", minv, maxv);     return 0; }       문제 링크    https://www.acmicpc.net/problem/10818    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-10818/",
        "teaser": null
      },{
        "title": "BOJ 5635 생일",
        "excerpt":" BOJ 5635    생일과 이름을 같이 저장, 정렬 앞뒤 노드 얻기      접근하기    구조체를 선언하고 vector에 담기 STL pair를 이용      코드 - 구조체 선언 + vector    #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  typedef struct Node {     int cnt;     string name; } Node;  bool cmp(const Node&amp; p1, const Node&amp; p2) {     return (p1.cnt &lt; p2.cnt); }  int main(int argc, char* argv[]) {     int N;     cin &gt;&gt; N;     vector&lt;Node&gt; v(N);     int day, month, year;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; v[i].name &gt;&gt; day &gt;&gt; month &gt;&gt; year;             v[i].cnt = (year*365) + (month*30) + day;      }     sort(v.begin(), v.end(), cmp);     cout &lt;&lt; v.back().name &lt;&lt; \"\\n\";     cout &lt;&lt; v.front().name &lt;&lt; \"\\n\";     return 0; }       코드 - STL pair를 이용    #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; using namespace std;  int main(int argc, char* argv[]) {     int N;     cin &gt;&gt; N;      vector&lt;pair&lt;int, string&gt;&gt; v(N);     int day, month, year;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; v[i].second &gt;&gt; day &gt;&gt; month &gt;&gt; year;             v[i].first = (year*365) + (month*30) + day;      }     sort(v.begin(), v.end());     cout &lt;&lt; v.back().second &lt;&lt; \"\\n\";     cout &lt;&lt; v.front().second &lt;&lt; \"\\n\";     return 0; }       문제 링크    https://www.acmicpc.net/problem/5635    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-5635/",
        "teaser": null
      },{
        "title": "BOJ 15688 수 정렬하기 5",
        "excerpt":" BOJ 15688 수 정렬하기 5    절대값이 100만인 숫자 N이 백만인 배열 정렬하기      접근하기    STL sort이용 200만 배열 만들어서 음수/양수 나눠서 저장      코드 - STL sort    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     vector&lt;int&gt; v(N);     int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);         v[i] = num;      }     sort(v.begin(), v.end());     for(auto item:v) {         printf(\"%d\\n\", item);     }     return 0; }       코드 - 200만 배열 이용    // 6632 ms #include &lt;cstdio&gt;  int N;  #define OFFSET 1000000 int a[2000001];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);         a[OFFSET+num]++;     }      for(int i=0;i&lt;=2000000;i++) {         for(int j=0;j&lt;a[i];j++) {             if (i &lt;= OFFSET)                 printf(\"%d\\n\", -1*(OFFSET-i));             else                 printf(\"%d\\n\", i-OFFSET);         }     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/15688    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-11536/",
        "teaser": null
      },{
        "title": "BOJ 22885 Reversort",
        "excerpt":" BOJ 22885 Reversort    Google Code Jam 2021 QR A번 문제      접근하기    N이 100이므로, 이중 forloop를 써도 무방 설명대로 푼다.      코드    #include &lt;cstdio&gt;  int T; int a[110];  void solve(int tc) {     int ans = 0;     int N;     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }      for(int i=1;i&lt;=N-1;i++) {         int vj = 0;         int idx = 0;         int arr[110];         for(int j=i;j&lt;=N;j++) {             arr[idx++] = a[j];             if (i == a[j]) {                 vj = j;                 ans += vj-i+1;                 break;             }         }         for(int j=vj, k=0;j&gt;=i;j--) {             a[j] = arr[k++];           }     }     printf(\"Case #%d: %d\\n\", tc, ans); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve(tc);     }      return 0; }        문제 링크    https://www.acmicpc.net/problem/22885 https://codingcompetitions.withgoogle.com/codejam/round/000000000043580a/00000000006d0a5c    ","categories": [],
        "tags": ["구현"],
        "url": "/boj-22885/",
        "teaser": null
      },{
        "title": "BOJ 14469 소가 길을 건너간 이유 3",
        "excerpt":" BOJ 14469 소가 길을 건너간 이유 3    소가 순서대로 길을 건너야함 앞의 소가 모두 건널때까지 기다려야 함      접근하기    앞의 끝시간 &gt; 지금의 시작시간일 때를 찾아서 뒤로 미루는 코드 생각하기      코드 - 구조체 이용    // &#44396;&#51312;&#52404; s, e&#51060;&#50857; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int N;  typedef struct Node {     int s;     int e; }Node;  bool cmp(const Node&amp; p1, const Node&amp; p2) {     return p1.s &lt; p2.s; }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     vector&lt;Node&gt; v(N);      int s, len;     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;s, &amp;len);         v[i].s = s;         v[i].e = s + len;     }     sort(v.begin(), v.end(), cmp);     for(int i=1;i&lt;N;i++) {         int len = v[i].e - v[i].s;         if (v[i-1].e &gt; v[i].s) {             v[i].s = v[i-1].e;             v[i].e = v[i].s + len;         }     }     printf(\"%d\\n\", v[N-1].e);      return 0; }       코드 - STL pair 이용    // &#44396;&#51312;&#52404; s, e&#51060;&#50857; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; using namespace std;  int N;  bool cmp(const pair&lt;int, int&gt;&amp; p1, const pair&lt;int, int&gt;&amp; p2) {     return p1.first &lt; p2.first; }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     vector&lt;pair&lt;int, int&gt;&gt; v(N);      int s, len;     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;s, &amp;len);         v[i].first = s;         v[i].second = s + len;     }     sort(v.begin(), v.end(), cmp);     for(int i=1;i&lt;N;i++) {         int len = v[i].second - v[i].first;         if (v[i-1].second &gt; v[i].first) {             v[i].first = v[i-1].second;             v[i].second = v[i].first + len;         }     }     printf(\"%d\\n\", v[N-1].second);      return 0; }       문제 링크    https://www.acmicpc.net/problem/14469    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-14469/",
        "teaser": null
      },{
        "title": "BOJ 1464 뒤집기 3",
        "excerpt":" BOJ 1464 뒤집기 3    조건대로 문자열 뒤집어서, 사전순으로 최소가 되도록 출력 완전탐색으로 하면 시간초과가 남  그리디하게 성질을 발견해야 하는 문제 (이해가 어렵다) 다른 블로그 풀이를 참고      접근하기    s = BCDAF  ans = B  if (ans [0] &lt; s[1]) // C     ans = C B  if (ans [1] &lt; s[2]) // D     ans = D C B  if (ans [2] &lt; s[3]) // A     ans = D C B A  if (ans [3] &lt; s[4]) // F     ans = F D C B A  reserse(ans) =&gt; A B C D F       코드    #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt;  using namespace std;  char str[51];  int main(int argc, char* argv[]) {     scanf(\"%s\", str);     int len;     for(len = 0;str[len];len++);     string ans = \"\";     ans += str[0];     for(int i=1;i&lt;len;i++) {         if (ans[i-1] &lt; str[i]) {             ans = str[i] + ans;         } else {             ans = ans + str[i];         }     }      reverse(ans.begin(), ans.end());     cout &lt;&lt; ans &lt;&lt; \"\\n\";     return 0; }       문제 링크    https://www.acmicpc.net/problem/1464      풀이참고    https://kangminjun.tistory.com/entry/BOJ-1464-번-뒤집기-3    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1464/",
        "teaser": null
      },{
        "title": "C - Final Day",
        "excerpt":" C - Final Day    3일까지 시험을 본 상태에서, 마지막 시험점수를 통해 K등에 들 수 있는지 알아보기      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N, K;  typedef struct Node {     int score;     int idx;     int state; } Node;  Node a[100010];  bool cmp1(const Node&amp; p1, const Node&amp; p2) {     return (p1.score &gt; p2.score); }  bool cmp2(const Node&amp; p1, const Node&amp; p2) {     return (p1.idx &lt; p2.idx); }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;K);      int p1, p2, p3;     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d %d\", &amp;p1, &amp;p2, &amp;p3);         a[i].score = p1 + p2 + p3;         a[i].idx = i;         a[i].state = 0;     }     sort(a, a+N, cmp1);      for(int i=0;i&lt;N;i++) {         if (i &lt; K) {             a[i].state = 1;         } else {             if (a[i].score + 300 &gt;= a[K-1].score) {                 a[i].state = 1;             }         }     }     sort(a, a+N, cmp2);     for(int i=0;i&lt;N;i++) {         if(a[i].state) {             printf(\"Yes\\n\");         } else {             printf(\"No\\n\");         }     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc228/tasks/abc228_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc228-c-upsolving/",
        "teaser": null
      },{
        "title": "abc231 E - Minimal payments",
        "excerpt":" E - Minimal payments     접근하기    X = 87 A = (1,10,100)  100 - 87 = 13     // 100내기(1), 13받기 10                // 10받기(1) 1 1 1                // 3받기(3)  총 5개가 답     코드 - 반복문 풀이    #include &lt;cstdio&gt;  typedef long long ll;  int N; ll x; ll a[65];  int main(int argc, char* argv[]) {     scanf(\"%d %lld\", &amp;N, &amp;x);     for(int i=1;i&lt;=N;i++) {         scanf(\"%lld\", &amp;a[i]);     }       ll ans = 0;     for(int i=N;i&gt;=1;i--)     {         ll k = x%a[i];     // 87         ll r = a[i]-k;   // 13         if (k-r &lt; a[i-1]) {             ans += x/a[i];             x = k;         } else {             ans += x/a[i] + 1;             x = r;         }     }      printf(\"%lld\\n\", ans);     return 0; }      코드 - dfs이용    #include &lt;cstdio&gt; typedef long long ll;  int N; ll x; ll a[65];  ll dfs(int idx, ll x) {     if (idx == 1) return x;      ll   cnt = x / a[idx];         // &#54788;&#51116;yen &#47751;&#44060;&#46300;&#45716;&#51648;     ll case1 = x % a[idx];         // 87 % 100 = 87     ll case2 = a[idx] - case1;     // 100 - 87 = 13      if (case1 - case2 &lt; a[idx-1])       // &#51060; &#49885;&#51012; &#49373;&#44033;&#54616;&#44592; &#50612;&#47140;&#50880;         return dfs(idx-1, case1) + cnt;     else         return dfs(idx-1, case2) + cnt + 1; }  int main(int argc, char* argv[]) {     scanf(\"%d %lld\", &amp;N, &amp;x);     for(int i=1;i&lt;=N;i++) {         scanf(\"%lld\", &amp;a[i]);     }       ll ret = dfs(N, x);     printf(\"%lld\\n\", ret);     return 0; }       TODO 코드 - DP풀이    문제 링크    https://atcoder.jp/contests/abc231/tasks/abc231_e    ","categories": [],
        "tags": ["DP","dfs"],
        "url": "/abc231-e-upsolving/",
        "teaser": null
      },{
        "title": "Atcoder / Codeforces 문제 list",
        "excerpt":" Atcoder 문제 table    https://kenkoooo.com/atcoder/#/table       Codeforces 문제 table    https://tom0727.github.io/cf-problems/     ","categories": [],
        "tags": ["ProblemList"],
        "url": "/atcoder-and-cf-problems/",
        "teaser": null
      },{
        "title": "AtCoder Library",
        "excerpt":" Atcoder Library    공식 사이트  https://atcoder.jp/posts/518  한글 설명자료  https://blog.solarmagic.dev/algorithm/2020/09/08/aclibrary/   ac-library를 파일 하나로 합치는 방법  https://github.com/TumoiYorozu/single-file-ac-library       사용법    g++ -o code code.cpp -std=c++14 -I. python expander.py code.cpp  $ ls atcoder  code.cpp  combined.cpp  document_en  expander.py code     combined  combined.o    document_ja  try1   combinded.cpp에 code가 copy됨 atcoder/all을 include하면, header의 모든 내용이 copy됨 (코드가 길어짐)      AtCoder Library Practice Contest    https://atcoder.jp/contests/practice2/tasks 여기 나오는 문제들을 모두 library로 풀 수 있다.     A. Disjoint Set Union B. Fenwick Tree C. Floor Sum D. Maxflow E. MinCostFlow F. Convolusion G. SCC H. Two SAT I. Number of Substrings J. Segment Tree K. Range Affine Range Sum L. Lazy Segment Tree    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/atcoder-lib-usage/",
        "teaser": null
      },{
        "title": "BOJ 10569 다면체",
        "excerpt":" BOJ 10569 다면체    주어진 공식 변형      코드    #include &lt;stdio.h&gt;  int N; int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int a, b;     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;a, &amp;b);         printf(\"%d\\n\", b + 2 - a);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/10569    ","categories": [],
        "tags": ["최적화"],
        "url": "/boj-10569/",
        "teaser": null
      },{
        "title": "BOJ 11966 2의 제곱인가?",
        "excerpt":" BOJ 11966 2의 제곱인가?     접근하기    N의 음수는 2의 보수인 성질을 이용하기   N = 8        -N = 8의 2의보수  1000 -&gt; 0111 (1의보수) -&gt; 1000 (2의보수)  N &amp; (-N) == N  --&gt; 2의 제곱수     N &amp; N-1 == 0이면 2의 보수인 성질 이용하기   N = 8     N-1=7   1000   0111  ------   0000  N &amp; (N-1) == 0   --&gt; 2의 제곱수     코드1    #include &lt;stdio.h&gt;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     if (0 == (N &amp; (N-1)))         printf(\"1\\n\");     else         printf(\"0\\n\");     return 0; }       코드2    #include &lt;stdio.h&gt;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     if (N == (N &amp; -N)) // -N : N&#51032; 2&#51032; &#48372;&#49688;         printf(\"1\\n\");     else         printf(\"0\\n\");     return 0; }        문제 링크    https://www.acmicpc.net/problem/11966    ","categories": [],
        "tags": ["비트연산"],
        "url": "/boj-11966/",
        "teaser": null
      },{
        "title": "BOJ 16561 3의 배수",
        "excerpt":" BOJ 16561 3의 배수    3의 배수 3개를 조합해서 N만드는 경우의 수 구하기      접근하기    a + b + c = N 형태로 3중 loop로 가능  &gt;&gt;&gt; (3000*3000*3000)/(3*3*3) 1000000000 십억만큼 반복 -&gt; 시간초과     c = N - a - b  c가 3의 배수이어야 함 3보다 같거나 커야 함 N보다 작아야 함      시간초과 코드    // &#49884;&#44036;&#52488;&#44284; &#54400;&#51060; #include &lt;stdio.h&gt;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int ans = 0;     int cnt = 0;     for(int i=3;i&lt;=N;i+=3) {         for(int j=3;j&lt;=N;j+=3) {             for(int k=3;k&lt;=N;k+=3) {                 ans = i + j + k;                   if (ans == N) cnt += 1;             }         }     }     printf(\"%d\\n\", cnt);     return 0; }      코드 - 2중 for loop    #include &lt;stdio.h&gt;  int N; int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int cnt = 0;     for(int i=3;i&lt;=N;i+=3) {         for(int j=3;j&lt;=N;j+=3) {             int c = N - i - j;               if (c &gt;= 3 &amp;&amp; c%3 == 0 &amp;&amp; c &lt; N) cnt += 1;         }     }     printf(\"%d\\n\", cnt);     return 0; }       문제 링크    https://www.acmicpc.net/problem/16561    ","categories": [],
        "tags": ["최적화"],
        "url": "/boj-16561/",
        "teaser": null
      },{
        "title": "BOJ 17069 파이프 옮기기 2",
        "excerpt":" BOJ 17069 파이프 옮기기 2    오른쪽 방향으로 가로,세로,대각선 이동하고 N,N에 도착가능한 경우의 수 세기      접근하기    dp[i][j][3]  // 0가로 1세로 2대각선으로 생각하기  a[i][j] == 0 일때만 전 상태에서 현재 상태로 이동하도록 함  dp 테이블에 여분을 두어서 N+1등의 예외처리 조심하기      코드    #include &lt;stdio.h&gt;  int N;  int a[33][33]; long long dp[33][33][3];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             scanf(\"%d\", &amp;a[i][j]);         }      }      dp[1][2][0] = 1;    // &#50812;&#51901;&#50640;&#49436; &#50672;&#44208;      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             if (i == 1 &amp;&amp; j == 1) continue;             if (a[i][j] == 1) continue;              // &#50724;&#47480;&#51901;&#51004;&#47196;             if (a[i][j+1] == 0)                 dp[i][j+1][0] = dp[i][j][0] + dp[i][j][2];              // &#50500;&#47000;&#47196;             if (a[i+1][j] == 0)                 dp[i+1][j][1] = dp[i][j][1] + dp[i][j][2];              // &#45824;&#44033;&#49440; &#50500;&#47000;&#47196;             if (a[i+1][j+1] == 0 &amp;&amp; a[i][j+1] == 0 &amp;&amp; a[i+1][j] == 0)                 dp[i+1][j+1][2] = dp[i][j][0] + dp[i][j][1] + dp[i][j][2];         }     }   #if 0     for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             printf(\"%d \", dp[i][j][0] + dp[i][j][1] + dp[i][j][2]);          }          printf(\"\\n\");      } #endif      printf(\"%lld\\n\", dp[N][N][0] + dp[N][N][1] + dp[N][N][2]);      return 0; }       문제 링크    https://www.acmicpc.net/problem/17069    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-17069/",
        "teaser": null
      },{
        "title": "TODO abc225 D - Play Train",
        "excerpt":" C - Counting 2      접근하기     코드           문제 링크    https://atcoder.jp/contests/abc225/tasks/abc225_d    ","categories": [],
        "tags": ["AtCoder","TODO"],
        "url": "/abc-225-upsolving/",
        "teaser": null
      },{
        "title": "abc225 C - Calendar Validator",
        "excerpt":" C - Calendar Validator     접근하기    (시작점-1)%7 + M &lt;=7 이어야 범위 안에 들어온다. (놓치기 쉬운 조건) 가로로 이동할때 왼쪽 값과 1만큼 차이 세로로 이동할 때 위 값과 7만큼 차이      코드    #include &lt;cstdio&gt;  int N, M;  int a[10010][8];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);     for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=M;j++) {             scanf(\"%d\", &amp;a[i][j]);         }      }       bool ok = true;      // &#49884;&#51089;&#51216;&#51032; &#44050; &#48276;&#50948;     if ((a[1][1] -1)%7 + M &gt; 7) ok = false;      for(int j=1;j&lt;=M;j++) {         for(int i=1;i&lt;=N;i++) {             if (i&gt;=2 &amp;&amp; a[i][j] - a[i-1][j] != 7) {                 ok = false;                 break;             }             if (j&gt;=2 &amp;&amp; a[i][j] - a[i][j-1] != 1) {                 ok = false;                 break;             }         }      }       if (ok)         printf(\"Yes\\n\");     else         printf(\"No\\n\");     return 0; }       문제 링크    https://atcoder.jp/contests/abc225/tasks/abc225_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc225-c-upsolving/",
        "teaser": null
      },{
        "title": "abc225 D - Play Train",
        "excerpt":" D - Play Train     접근하기    - 두 노드의 연결 O(1) - 연결된 두 노드 분리 O(1) - 번호를 이용해서 연결된 노드 출력하기 O(N) - N이 10만이므로 list를 구성해서 풀이 가능      코드    #include &lt;cstdio&gt;  int N, Q;  typedef struct Node {     int front;     int rear; } Node;  Node a[100010];  int out[100010]; void print_func(int num) {      int k = num;     while(a[k].front != 0) {         int prev = a[k].front;         k = prev;     }      int idx = 0;      while(a[k].rear != 0) {         out[idx++] = k;         int next = a[k].rear;         k = next;     }     out[idx++] = k;      printf(\"%d \", idx);     for(register int i=0;i&lt;idx;i++) {         printf(\"%d \", out[i]);     }      printf(\"\\n\"); }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;Q);      int cmd;     int num1, num2;     for(int i=0;i&lt;Q;i++) {         scanf(\"%d\", &amp;cmd);         switch(cmd) {         case 1:             scanf(\"%d %d\", &amp;num1, &amp;num2);             a[num1].rear = num2;             a[num2].front = num1;             break;         case 2:             scanf(\"%d %d\", &amp;num1, &amp;num2);             a[num1].rear = 0;             a[num2].front = 0;             break;         case 3:             scanf(\"%d\", &amp;num1);             print_func(num1);             break;         }     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc225/tasks/abc225_d    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc225-d-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 9440 숫자 더하기",
        "excerpt":" BOJ 9440 숫자 더하기    한자리 숫자 2~14개를 주고, 두 숫자를 만들어서 더할 때, 가장 작은 수 만들기      접근하기    완전 탐색으로 풀어서 시간초과를 받음  최소 힙에서 숫자를 하나씩 빼서, 숫자 배열을 만들기 0이 여러개일 때 예외처리를 해줘야 한다.  0이 짝수개일 때 0이 홀수개일 때   문제가 되는 testcase를 찾기 어렵다.    문제 case : 1 9 0 0 0 0 0 0 0 0 0 0 0  0 0 0 0 0 0 1 0 0 0 0 0 9  1 0 0 0 0 0 0  &lt;- 0을 앞에 넣어준다.   9 0 0 0 0 0  1 9 0 0 0 0 0     코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt;  using namespace std; int N; int main(int argc, char* argv[]) {     priority_queue&lt;char, vector&lt;char&gt;, greater&lt;char&gt;&gt; pq;     while(1) {         scanf(\"%d\", &amp;N);         if (N == 0) break;          int zero = 0;         char num;         for(int i=0;i&lt;N;i++) {             scanf(\" %c\", &amp;num);             if (num == '0') zero += 1;             pq.push(num);         }         char a[2][14] = {0};         int cnt[2] = {0};          int idx = 0;         char backup;          // zero&#44032; 1&#51060; &#50500;&#45772; &#54848;&#49688;&#44060;&#51060;&#47732;, &#54616;&#45208;&#47484; &#48764;&#49436; a[0]&#47196; &#48372;&#45236;&#44592;         if ( zero != 1 &amp;&amp; zero %2 == 1) {             backup = pq.top(); pq.pop();             a[0][cnt[0]++] = backup;          }          while(!pq.empty()) {             char val = pq.top(); pq.pop();             a[idx%2][cnt[idx%2]++] = val;              idx++;         }          for(int k=0;k&lt;2;k++) {             for(int i=0;i&lt;cnt[k];i++) {                 if (a[k][0] == '0' &amp;&amp; a[k][i] != '0') {                     char tmp = a[k][0];                     a[k][0] = a[k][i];                     a[k][i] = tmp;                     break;                 }             }         }          int ans[2] = {0,};         for(int k=0;k&lt;2;k++) {             for(int i=0;i&lt;cnt[k];i++) {                 ans[k] = ans[k] * 10 + (a[k][i] - '0');             }         }         printf(\"%d\\n\", ans[0]+ans[1]);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/9440      TC 참고    https://kwanghyuk.tistory.com/76    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-9440/",
        "teaser": null
      },{
        "title": "D - Weak Takhashi",
        "excerpt":" TODO D - Weak Takahashi    HxW 크기의 배열에 .빈공간과 #막힌곳이 있을때, 1,1에서 얼마나 많이 움직일 수 있는지 세기     접근하기    BFS를 이용해서 풀이함 dp style의 bottom up으로 풀이 가능할 것     코드1 - BFS    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std;  int H, W; int map[110][110]; int visit[110][110];  typedef struct Node {     int y;     int x;     int len; } Node;  bool safe(int y, int x) {     return (0&lt;=x &amp;&amp; x&lt;W) &amp;&amp; (0&lt;=y &amp;&amp; y&lt;H); }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;H, &amp;W);     char str[110];     for(int i=0;i&lt;H;i++) {         scanf(\"%s\", str);                  for(int j=0;str[j];j++) {             if (str[j] == '.') {                 map[i][j] = 0;             } else if (str[j] == '#') {                  map[i][j] = 1;             }         }     }      queue&lt;Node&gt; q;     q.push({0, 0, 1});      visit[0][0] = 1;      int ans = 0;     while(!q.empty()) {         Node cur = q.front(); q.pop();         ans = cur.len;         if (safe(cur.y, cur.x + 1) &amp;&amp; map[cur.y][cur.x + 1] == 0 &amp;&amp; visit[cur.y][cur.x + 1] == 0) {             visit[cur.y][cur.x + 1] = 1;             q.push({cur.y, cur.x + 1, cur.len+1});         }          if (safe(cur.y+1, cur.x) &amp;&amp; map[cur.y + 1][cur.x] == 0 &amp;&amp; visit[cur.y + 1][cur.x] == 0) {             visit[cur.y + 1][cur.x] = 1;              q.push({cur.y+1, cur.x, cur.len+1});         }     }     printf(\"%d\\n\", ans);     return 0; }       TODO 코드2 - DP style?     문제 링크    https://atcoder.jp/contests/abc232/tasks/abc232_d    ","categories": [],
        "tags": ["AtCoder","Graph"],
        "url": "/abc232-d/",
        "teaser": null
      },{
        "title": "BOJ 10451 순열 사이클",
        "excerpt":" BOJ 10451 순열 사이클    graph 가 주어질 때, 순열 사이클의 개수 세기 dfs에서 cycle의 개수를 센다.      접근하기    dfs에서 visit배열과 함께 finish 배열을 유지함  f(1) -&gt; f(2) -&gt; f(3)  visit  1 1 1 finish 1 1 1  f(1) -&gt; f(2) -&gt; f(3) -&gt; f(1) 형태 cycle이 있으면  visit  1 1 1 finish 0 0 0      코드    #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std;  int T; int N;  int a[1001]; int visit[1001]; int done[1001];  int ans;  void dfs(int k) {     visit[k] = 1;      int nextval = a[k];     if (!visit[nextval]) {         dfs(nextval);     } else if (!done[nextval]) {         ans += 1;     }     done[k] = 1; }  void solve() {     ans = 0;     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         visit[i] = 0;         done[i] = 0;     }     int num;     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;num);         a[i] = num;     }      for(int i=1;i&lt;=N;i++) {         if(!visit[i]) dfs(i);     }     printf(\"%d\\n\", ans); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/10451    ","categories": [],
        "tags": ["DFS"],
        "url": "/boj-10451/",
        "teaser": null
      },{
        "title": "BOJ 1417 국회의원 선거",
        "excerpt":" BOJ 1417 국회의원 선거    N명의 후보중 1번 후보가 당선되기 위해, 다른 후보들에게 가져와야 할 표의 총 수     접근하기    우선순위 큐에 2~N번까지를 넣는다. 1번보다 많으면, 1씩 뺀다.     코드    #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std;  int N; priority_queue&lt;int&gt; pq;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      int num;     int first, org;     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;num);         if (i == 1) {             org = first = num;         } else {             pq.push(num);         }     }      while(!pq.empty()) {         int num = pq.top(); pq.pop();             if (first &lt;= num) {             first += 1;             pq.push(num-1);         } else { //first &gt; num             break;         }     }     printf(\"%d\\n\", first - org);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1417    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1417/",
        "teaser": null
      },{
        "title": "BOJ 9466 텀 프로젝트",
        "excerpt":" BOJ 9466 텀프로젝트    DFS를 이용해서 cycle을 detect하기      접근하기    dfs에서 visit배열과 함께 finish 배열을 유지함  f(1) -&gt; f(2) -&gt; f(3)  visit  1 1 1 finish 1 1 1  f(1) -&gt; f(2) -&gt; f(3) -&gt; f(1) 형태 cycle이 있으면  visit  1 1 1 finish 0 0 0      코드    #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std;  int T; int N;  #define ARRSIZE 100010 int a[ARRSIZE];  vector&lt;int&gt; G[ARRSIZE];  int visit[ARRSIZE]; int finish[ARRSIZE]; int ans; int cnt;  void dfs(int num) {     visit[num] = cnt++;      for(int next: G[num]) {         if (visit[next] == 0) {             dfs(next);         } else if (!finish[next]) {             ans += visit[num] - visit[next] + 1;         }     }     finish[num] = 1; }  void solve() {     cnt = 0;     ans = 0;     int num;     scanf(\"%d\", &amp;N);      for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;num);         G[i].push_back(num);     }      for(int i=1;i&lt;=N;i++) {         if (visit[i]) dfs(i);     }     printf(\"%d\\n\", N-ans);      for(int i=1;i&lt;=N;i++) {         visit[i] = 0;         finish[i] = 0;         G[i].clear();     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);      for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }     1초 가까운 시간이 걸림      TODO 최적 풀이 300ms이내    boj 답 참고할 것      문제 링크    https://www.acmicpc.net/problem/9466    ","categories": [],
        "tags": ["DFS"],
        "url": "/boj-9466/",
        "teaser": null
      },{
        "title": "정수의 bit표현에서 1의 개수 세기",
        "excerpt":" 두 정수의 비트 표현에서 다른 자리수가 몇개인지 세기     접근하기    다른 비트의 개수를 세기    10110   01111   -----   11001(25)  -&gt; 3       코드 - countSetBits - log2(N)    #include &lt;cstdio&gt;  int countSetBits(unsigned int n) {     // base case     if (n == 0)         return 0;     else         // if last bit set add 1 else add 0         return (n &amp; 1) + countSetBits(n &gt;&gt; 1); }  int main(int argc, char* argv[]) {     unsigned int first = 22;     unsigned int second = 15;       printf(\"%u\\n\", first ^ second); // 25     printf(\"%d\\n\", countSetBits(first ^ second));  // 3     return 0; }        TODO 코드 - Table 기반 최적화    링크 참조      참고자료    https://www.geeksforgeeks.org/count-set-bits-in-an-integer/    ","categories": [],
        "tags": ["Bit연산"],
        "url": "/count-set-bint-in-an-int/",
        "teaser": null
      },{
        "title": "BOJ 2160 그림 비교",
        "excerpt":" BOJ 2160 그림 비교    5X7 배열 여러개를 비교해서 가장 차이가 작은 번호쌍을 구하기     접근하기     코드 - 2차원 배열을 비교    #include &lt;cstdio&gt; #include &lt;algorithm&gt;  using namespace std;  unsigned int a[51]; int map[51][5][7];  inline void input_one(int idx) {     char str[10];      a[idx] = 0;     for(int i=0;i&lt;5;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             if(str[j] == 'X') {                 map[idx][i][j] = 1;             }         }     } }  int comp(int n1, int n2) {     int diff = 0;     for(int i=0;i&lt;5;i++) {         for(int j=0;j&lt;7;j++) {             if (map[n1][i][j] != map[n2][i][j]) diff += 1;         }     }     return diff; }  int main(int argc, char* argv[]) {     int N;     scanf(\"%d\", &amp;N);      for(int i=0;i&lt;N;i++) {         input_one(i);     }     int ans_cnt = 987654321;     int pic1 = 0;     int pic2 = 0;     for(register int i=0;i&lt;N-1;i++) {         for(register int j=i+1;j&lt;N;j++) {             int tmp = comp(i, j);             if (ans_cnt &gt; tmp) {                 ans_cnt = tmp;                 pic1 = i;                 pic2 = j;             }             //printf(\"%d\\n\", tmp);         }     }     printf(\"%d %d\\n\", pic1+1, pic2+1);     return 0; }        코드 - bit 연산으로 풀이    5x7 = 35 35개의 bit로 나타낸 숫자를 이용 64 bit로 shift할 때는 1이 아니라 1ULL을 써야 함(unsigned long long)   #include &lt;cstdio&gt; #include &lt;algorithm&gt;  using namespace std;  unsigned long long a[60];  inline unsigned int count_bit(unsigned long long n) {     if (n == 0)         return 0;     else         // if last bit set add 1 else add 0         return (n &amp; 1ULL) + count_bit(n &gt;&gt; 1ULL); }  // 5*7 = 35 inline void input_one(int idx) {     a[idx] = 0ULL;     char str[20];      for(int i=0;i&lt;5;i++) {         scanf(\"%s\", str);         for(int j=0;j&lt;7;j++) {             if(str[j] == 'X') {                 a[idx] |= (1ULL &lt;&lt; ((7*i) + j));             }         }     } }  int main(int argc, char* argv[]) {     int N;     scanf(\" %d\", &amp;N);      for(int i=0;i&lt;N;i++) {         input_one(i);     }     unsigned int ans_cnt = 987654321;     int pic1 = 0;     int pic2 = 0;     for(int i=0;i&lt;N-1;i++) {          for(int j=i+1;j&lt;N;j++) {             unsigned int cnt = count_bit(a[i]^a[j]);              if (ans_cnt &gt; cnt) {                 ans_cnt = cnt;                 pic1 = i;                 pic2 = j;             }         }     }     printf(\"%d %d\\n\", pic1+1, pic2+1);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2160    ","categories": [],
        "tags": ["구현","비트연산"],
        "url": "/boj-2160/",
        "teaser": null
      },{
        "title": "BOJ 10972 다음 순열",
        "excerpt":" BOJ 10972 다음 순열    다음으로 나오는 순열 구하기      접근하기    STL next_permutation을 이용      코드 - STL next permutation 이용함    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     vector&lt;int&gt; a(N);     int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);         a[i] = num;     }     if (next_permutation(a.begin(), a.end())) {         for(auto&amp; o:a) {             printf(\"%d \", o);         }          printf(\"\\n\");     } else {         printf(\"-1\\n\");     }     return 0; }       TODO 코드 - 그냥 구현하기     문제 링크    https://www.acmicpc.net/problem/10972    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-10972/",
        "teaser": null
      },{
        "title": "BOJ 10973 이전 순열",
        "excerpt":" BOJ 10973 이전 순열    이전에 나오는 순열 구하기      접근하기    STL prev_permutation을 이용      코드 - STL prev permutation 이용함    #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; using namespace std;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     vector&lt;int&gt; a(N);     int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);         a[i] = num;     }     if (prev_permutation(a.begin(), a.end())) {         for(auto&amp; o:a) {             printf(\"%d \", o);         }          printf(\"\\n\");     } else {         printf(\"-1\\n\");     }     return 0; }       TODO 코드 - 그냥 구현하기     문제 링크    https://www.acmicpc.net/problem/10973    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-10973/",
        "teaser": null
      },{
        "title": "ABC233 C - Product",
        "excerpt":" C - Product    N개의 가방에서 하나씩 공을 꺼내서 곱해서 값 X를 만드는 경우의 수 구하기     코드    dfs스타일로 풀이 가능함 (에디토리얼 보고 생각함)   #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std;  typedef long long ll;  int N; ll X; ll cnt;  vector&lt; vector&lt;ll&gt; &gt; G;  void dfs(int idx, ll ans) {     if (idx == N) {         if (ans == X) {             cnt += 1;         }         return;     }      for(ll val:G[idx]) {         if (ans*val &gt; X) continue;         dfs(idx+1, ans*val);     } }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     cnt = 0;     scanf(\"%d %lld\", &amp;N, &amp;X);     G.resize(N);         int num;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;num);          G[i].resize(num);         for(int j=0;j&lt;num;j++) {             ll val;             scanf(\"%lld\", &amp;val);             G[i][j] = val;         }     }     dfs(0, 1);     printf(\"%lld\\n\", cnt);     return 0; }       문제 링크    https://atcoder.jp/contests/abc233/tasks/abc233_c    ","categories": [],
        "tags": ["AtCoder","DFS"],
        "url": "/abc233-c-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 1673 치킨 쿠폰",
        "excerpt":" BOJ 1673 치킨 쿠폰    쿠폰과 도장 두 변수를 잘 컨트롤하기      코드    #include &lt;cstdio&gt;  int N, K;  int main(int argc, char* argv[]) {     //freopen(\"input.txt\", \"r\", stdin);     while(scanf(\"%d %d\", &amp;N, &amp;K) != EOF) {          int coupon = N;         int stamp = 0;          int ans = 0;         while(coupon) {         ans += coupon;       // &#52824;&#53416; &#53216;&#54256; N&#51109; &#45813;&#50640; &#54252;&#54632;             stamp += coupon; // &#52824;&#53416; &#53216;&#54256; N&#51109;&#51008; &#46020;&#51109; &#48155;&#51020;              coupon = stamp / K; // &#46020;&#51109;&#51032; &#49688;/K =&gt; &#49352;&#47196; &#47784;&#51008; &#53216;&#54256;&#49688;             stamp = stamp % K;  // &#46020;&#51109;&#51032; &#49688;%K =&gt; &#49352;&#47196; &#47784;&#51008; &#46020;&#51109;&#49688;          }         printf(\"%d\\n\", ans);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/1673      풀이참고    https://codecollector.tistory.com/901    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-1673/",
        "teaser": null
      },{
        "title": "온라인 컴파일러 (replit)",
        "excerpt":" replit.com    C/C++을 비롯한 다양한 언어를 실행해볼 수 있음 input.txt파일을 넣어서 구동이 되므로, Problem Solving에도 사용하기 편리  내 PC가 아닌 곳에서 Problem solving환경이 필요할 때, 임시로 사용하기  https://replit.com/    ","categories": [],
        "tags": ["repl.it"],
        "url": "/replit-com/",
        "teaser": null
      },{
        "title": "BOJ 1003 피보나치 함수",
        "excerpt":" BOJ 1003 피보나치 함수     접근하기    피보나치 함수에서 0과 1의 개수 세기  규칙성을 보고 점화식을 찾기  -------------------------           0개수    1개수 f(0)        1        0 f(1)        0        1 f(2)        1        1 f(3)        1        2 ------------------------- f(3) 0일때 = f(3) = f(2) + f(1) f(3) 1일때 = f(3) = f(2) + f(1)  인 규칙 발견 -&gt; dp[n][2] 배열에 점화식 넣기  dp[n][0] = dp[n-1][0] + dp[n-2][0] dp[n][1] = dp[n-1][1] + dp[n-2][1]      코드    #include &lt;cstdio&gt;  int T;  typedef long long ll;  ll dp[41][2];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);      dp[0][0] = 1;     dp[1][0] = 0;         dp[2][0] = 1;      dp[0][1] = 0;     dp[1][1] = 1;     dp[2][1] = 1;          for(int i=3;i&lt;=40;i++) {         dp[i][0] = dp[i-1][0] + dp[i-2][0];          dp[i][1] = dp[i-1][1] + dp[i-2][1];              }      while(T--) {         int num;         scanf(\"%d\", &amp;num);         printf(\"%lld %lld\\n\", dp[num][0], dp[num][1]);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/1003    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-1003/",
        "teaser": null
      },{
        "title": "BOJ 1149 RBG 거리",
        "excerpt":" BOJ 1149 RGB 거리    DP용 문제      접근하기    dp[N][0] dp[N][1] dp[N][2]   -&gt; 각 집마다의 색깔  N+1이 0이면 N에서는 1, 2만 가능  N+1이 1이면 N에서는 0, 2만 가능  N+1이 2이면 N에서는 1, 2만 가능  점화식으로 나타내면 된다.      코드 - dp 배열 쓰기    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N;  int a[1010][3]; int dp[1010][3];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d %d\", &amp;a[i][0], &amp;a[i][1], &amp;a[i][2]);     }     dp[0][0] = a[0][0];     dp[0][1] = a[0][1];     dp[0][2] = a[0][2];      for(int i=1;i&lt;N;i++) {         dp[i][0] = min(dp[i-1][1], dp[i-1][2]) + a[i][0];         dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + a[i][1];         dp[i][2] = min(dp[i-1][0], dp[i-1][1]) + a[i][2];             }     printf(\"%d\\n\", min(min(dp[N-1][0], dp[N-1][1]), dp[N-1][2]));     return 0; }       코드 - 변수를 적게 쓰기    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int N;  int a[2][3]; int dp[2][3];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {           if (i == 0) {           scanf(\"%d %d %d\", &amp;a[0][0], &amp;a[0][1], &amp;a[0][2]);            dp[0][0] = a[0][0];           dp[0][1] = a[0][1];           dp[0][2] = a[0][2];         } else {                 scanf(\"%d %d %d\", &amp;a[1][0], &amp;a[1][1], &amp;a[1][2]);                  dp[1][0] = min(dp[0][1], dp[0][2]) + a[1][0];                 dp[1][1] = min(dp[0][0], dp[0][2]) + a[1][1];                 dp[1][2] = min(dp[0][0], dp[0][1]) + a[1][2];                          a[0][0] = a[1][0];                 a[0][1] = a[1][1];                 a[0][2] = a[1][2];                  dp[0][0] = dp[1][0];                 dp[0][1] = dp[1][1];                                 dp[0][2] = dp[1][2];                                         }     }      if (N %2 == 0)         printf(\"%d\\n\", min(min(dp[0][0], dp[0][1]), dp[0][2]));     else         printf(\"%d\\n\", min(min(dp[1][0], dp[1][1]), dp[1][2]));         return 0; }       문제 링크    https://www.acmicpc.net/problem/1149    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-1149/",
        "teaser": null
      },{
        "title": "BOJ 1904 01타일",
        "excerpt":" BOJ 1904 01타일    00, 1을 이용해서 N자리 숫자를 만드는 경우의 수 구하기      접근하기    00,1 로만 숫자를 만들기  N = 1     1                           1  N = 2     00 11                       2 N = 3     001 100 111                 3 N = 4     0011 0000 1001 1100 1111    5  피보나치 수열 점화식이 나옴      코드    #if 0 N = 1     1                           1  N = 2     00 11                       2 N = 3     001 100 111                 3 N = 4     0011 0000 1001 1100 1111    5 #endif  #include &lt;cstdio&gt;  int N; int dp[1000010];  #define MOD 15746  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     dp[1] = 1;     dp[2] = 2;      for(int i=3;i&lt;=N;i++) {         dp[i] = dp[i-1]%MOD + dp[i-2]%MOD;         dp[i] %= MOD;     }     printf(\"%d\\n\", dp[N]);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1904    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-1904/",
        "teaser": null
      },{
        "title": "BOJ 20040 사이클 게임",
        "excerpt":" BOJ 20040 사이클 게임    Union Find를 이용해서 cycle을 탐지하는 문제      접근하기    union(a, b) : a점과 b점을 연결하는 것을 의미  Find(a) == Find(b) -&gt; 선분이 이미 연결되어 있음  Find(a) != Find(b) -&gt; 선분이 연결되어 있지 않음       코드    #include &lt;cstdio&gt;  int N, M; int p[500010];  int Find(int a) {     if (p[a] &lt; 0) return a;     return p[a] = Find(p[a]); }  void Union(int a, int b) {        a = Find(a);     b = Find(b);      if (a != b) {         if (p[a] &lt; p[b]) {             p[a] += p[b];             p[b] = a;         } else {             p[b] += p[a];             p[a] = b;                     }     } }  void uf_init(int n) {     for(int i=0;i&lt;=n ;i++) {         p[i] = -1;     } }  int main(int argc, char* argv[]) {     freopen(\"input2.txt\", \"r\", stdin);     scanf(\"%d %d\", &amp;N, &amp;M);     uf_init(N);     int p1, p2;     int ans = 0;     for(int i=0;i&lt;M;i++) {         scanf(\"%d %d\", &amp;p1, &amp;p2);         p1++;         p2++;         int parent1 = Find(p1);         int parent2 = Find(p2);          if (parent1 != parent2) {             Union(p1, p2);         } else {             ans = i + 1;              printf(\"%d\\n\", ans);                         return 0;         }     }     printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/20040    ","categories": [],
        "tags": ["UnionFind"],
        "url": "/boj-20040/",
        "teaser": null
      },{
        "title": "BOJ 2635 수 이어가기",
        "excerpt":" BOJ 2635 수 이어가기    첫번째 수 주어짐 두번째 수 고름 세번째 수 = 첫번째 - 두번째 네번째 수 - 두번째 - 세번째 &#x2026; 순서로 계속 음수가 나올 때까지      코드 - dfs style로 풀이    #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std;  int N;  int ans = 0; int tmp[30000/2]; vector&lt;int&gt; v; void dfs(int idx, int num1, int num2) {     if (num1 &lt; 0) {         if (ans &lt; idx) {             ans = idx;             v.clear();             for(int i=0;i&lt;ans;i++) {                 v.push_back(tmp[i]);             }         }         return;     }     tmp[idx+1] = num2;     dfs(idx+1, num2, num1-num2); }  int main(int argc, char* argv[]) {     ans = 0;     scanf(\"%d\", &amp;N);      tmp[0] = N;     for(int i=0;i&lt;=N;i++) {         dfs(0, N, N-i);     }     printf(\"%d\\n\", (int)v.size());     for(auto o:v) {         printf(\"%d \", o);     }     printf(\"\\n\");     return 0; }       문제 링크    https://www.acmicpc.net/problem/2635    ","categories": [],
        "tags": ["수학","dfs"],
        "url": "/boj-2635/",
        "teaser": null
      },{
        "title": "BOJ 2909 캔디 구매",
        "excerpt":" BOJ 2909 캔디 구매     접근하기    주어진 식대로 구현      코드    #include &lt;cstdio&gt; int C, K; int main(int argc, char* argv[]) {     freopen(\"input3.txt\", \"r\", stdin);     scanf(\"%d %d\", &amp;C, &amp;K);      // K&#49707;&#51088;&#47564;&#53372; 00 &#48537;&#51060;&#44592;     // 1 -&gt; 10     // 2 -&gt; 100     int n10 = 1;     for(int i=0;i&lt;K;i++)         n10 *= 10;     if (C%n10 &lt; (n10/2)) {         C = C - (C%n10);     } else {         C = C + n10 - (C%n10);     }     printf(\"%d\\n\", C);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2909    ","categories": [],
        "tags": ["수학","구현"],
        "url": "/boj-2909/",
        "teaser": null
      },{
        "title": "BOJ 4195 친구 네트워크",
        "excerpt":" BOJ 4195 친구 네트워크    Union Find를 이용하는 문제      접근하기    집합의 크기를 어떻게 사용하는지 배우는 문제      코드    #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;map&gt; using namespace std;  int T; int N;  int p[200010];  void Union_find_init(int n) {     for(int i=0;i&lt;n*2;i++) {         p[i] = -1;     } }  int Find(int a) {     if (p[a] &lt; 0) return a;     return p[a] = Find(p[a]); }  void Union(int a, int b) {     a = Find(a);     b = Find(b);      if (a != b) {         if (p[a] &lt;= p[b]) {             p[a] += p[b];            p[b] = a;         } else {             p[b] += p[a];             p[a] = b;                 }     } }  void solve() {     map&lt;string, int&gt; mp;     cin &gt;&gt; N;     Union_find_init(N);          string name1, name2;     int idx = 0;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; name1 &gt;&gt; name2;         if (mp[name1] == 0) {             mp[name1] = ++idx;         }          if (mp[name2] == 0) {             mp[name2] = ++idx;         }          int n1 = mp[name1];         int n2 = mp[name2];         Union(n1, n2);         int cnt1 = Find(n1);         cout &lt;&lt; -p[cnt1]  &lt;&lt; '\\n';     } }  int main(int argc, char* argv[]) {     ios::sync_with_stdio(0);     cin.tie(0);     cin &gt;&gt; T;      for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/4195      참고자료    https://greatzzo.tistory.com/52    ","categories": [],
        "tags": ["UnionFind"],
        "url": "/boj-4195/",
        "teaser": null
      },{
        "title": "BOJ 9184 신나는 함수 실행",
        "excerpt":" BOJ 9184 신나는 함수 실행    재귀함수 의사코드를 주고, 그대로 구현하는 문제 메모이제이션을 해줘야 함     접근하기    long long dp[21][21][21]로 메모이제이션      코드    #include &lt;cstdio&gt;  int a, b, c; typedef long long ll; ll dp[21][21][21];  long long f(int a, int b, int c) {     if (a &lt;=0 || b&lt;=0 || c&lt;= 0) return 1;     if (a &gt; 20 || b&gt;20 || c&gt;20) return f(20, 20, 20);      if (dp[a][b][c] !=0) return dp[a][b][c];      if (a &lt;b &amp;&amp; b &lt; c)         return dp[a][b][c] = f(a, b, c-1) + f(a, b-1, c-1) - f(a, b-1, c);      return dp[a][b][c] = f(a-1, b, c) + f(a-1, b-1, c) + f(a-1, b, c-1) - f(a-1, b-1, c-1); }  int main(int argc, char* argv[]) {     while(1) {         scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c);         if (a == -1 &amp;&amp; b == -1 &amp;&amp; c == -1) {             break;         }         printf(\"w(%d, %d, %d) = %lld\\n\", a, b, c, f(a, b, c));     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/9184    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-9184/",
        "teaser": null
      },{
        "title": "BOJ 9461 파도반 수열",
        "excerpt":" BOJ 9461 파도반 수열    파도반 수열 규칙으로 DP 문제 풀기 규칙성을 찾는 DP문제     접근하기    dp[0] = 0 dp[1] = 1 dp[2] = 1 dp[3] = 1 dp[4] = 2 dp[5] = 2 dp[6] = 3 dp[7] = 4 dp[8] = 5 dp[9] = 7 dp[10] = 9  dp[i] = dp[i-2] + dp[i-3] 점화식이 쉽게 보인다.      코드    #include &lt;cstdio&gt;  int N;  long long dp[110];  int main(int argc, char* argv[]) {     dp[0] = 0;     dp[1] = 1;     dp[2] = 1;      for(int i=3;i&lt;=100;i++) {         dp[i] = dp[i-2] + dp[i-3];     }      scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         int num;         scanf(\"%d\", &amp;num);         printf(\"%lld\\n\", dp[num]);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/9461    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-9461/",
        "teaser": null
      },{
        "title": "BOJ 11660 구간 합 구하기 5",
        "excerpt":" BOJ 11660 구간 합 구하기 5     접근하기    누적합 자체가 DP 점화식으로 표현된다.    1 2 3 4     (1)   3    6  (10) 2 3 4 5      3    8   15   24 3 4 5 6     (6)  15   27   42 4 5 6 7     10   24   42   64  42 - 10 - 6 + 1 = 27   1은 가로/세로가 공유하므로 두번 더한 셈 한번 빼줘야 함.      코드    #include &lt;cstdio&gt;  int dp[1026][1026]; int N, M;  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      int val;     for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             scanf(\"%d\", &amp;val);             dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + val;          }             }      int x1, y1, x2, y2;     for(int i=0;i&lt;M;i++) {         scanf(\"%d %d %d %d\", &amp;y1, &amp;x1, &amp;y2, &amp;x2);         printf(\"%d\\n\", dp[y2][x2] - dp[y2][x1-1] - dp[y1-1][x2] + dp[y1-1][x1-1]);     }        return 0; }       문제 링크    https://www.acmicpc.net/problem/11660    ","categories": [],
        "tags": ["DP","누적합"],
        "url": "/boj-11660/",
        "teaser": null
      },{
        "title": "BOJ 13305 주유소",
        "excerpt":" BOJ 13305 주유소    N개의 도시마다 기름값이 다를때, 주어진 도시간 이동거리를 모두 이동할 때 최소비용      접근하기    기름값이 싼 도시에서 미리 하는게 이익을 최대화 하는 방법   Case1)  2 3 1 5 2 4 1  2     -&gt;    min(5) * 2           = 10 3     -&gt;    min(2 , 5) * 3       = 6 1     -&gt;    min(2 , 5, 4) * 1    = 2                                  = 18    Case2)  3 3 4  1 1 1 1  3     -&gt; min(1) * 3              = 3 3     -&gt; min(1, 1) * 3           = 3  4     -&gt; min(1, 1, 1) * 4        = 4                                  = 1      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  typedef long long ll;  int N;  ll load[100010]; ll cost[100010];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;N;i++) scanf(\"%lld\", &amp;load[i]);      for(int i=0;i&lt;N;i++) scanf(\"%lld\", &amp;cost[i]);       ll minv = cost[0];     ll ans = 0;      for(int i=1;i&lt;N;i++) {         ans += minv * load[i];          minv = min(minv, cost[i]);     }     printf(\"%lld\\n\", ans);     return 0;  }       문제 링크    https://www.acmicpc.net/problem/13305    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-13305/",
        "teaser": null
      },{
        "title": "BOJ 1541 잃어버린 괄호",
        "excerpt":" BOJ 1541 잃어버린 괄호     접근하기    마이너스 기호가 나오면, 그 뒤에 모든 +를 마이너스로 바꾸면, 작은 수가 됨.      코드    맨 앞의 숫자는 그냥 ans에 더해야 하는 것을 생각하기 어려웠음  is_minus로 마이너스 기호가 나왔다는 표시를 함 맨 앞의 마이너스가 나와도 한번은 더하게 하기    #include &lt;cstdio&gt; char str[100];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%s\", str);      int num = 0;     int ans = 0;      bool is_minus = false;     int len;         for(len = 0;str[len];len++);      for(int i=0;i&lt;=len;i++)     {         if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9')             num = num * 10 + (str[i]-'0');         else if (str[i] == '-' || str[i] == '+' || len == i) {              if (is_minus)             {                 ans -= num;                 num = 0;             } else {                 ans += num;                 num = 0;                             }            }         if (str[i] == '-') is_minus = true;             }     printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1541    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1541/",
        "teaser": null
      },{
        "title": "BOJ 5430 AC",
        "excerpt":" BOJ 5430 AC    R : reverse 배열 뒤집기 D : delete 맨 앞 요소 제거      접근하기    배열을 매번 reverse하는 것은 O(N)만큼 시간이 든다. -&gt; 시간 초과가 날 것 STL deque를 이용해서, front/back을 사용하도록 하면, reverse를 하지 않아도 된다는 점에 착안         코드 - STL deque 이용    #include &lt;cstdio&gt; #include &lt;deque&gt; using namespace std;  int T; char str[100010]; int N; char arr[500000];  void solve() {     int mode = 0;   // 0 : &#50812;&#51901; --&gt; &#50724;&#47480;&#51901;    1 : &#50724;&#47480;&#51901; --&gt; &#50812;&#51901;     scanf(\"%s\", str);     scanf(\"%d\", &amp;N);     scanf(\"%s\", arr);      int num = 0;     int idx = 0;     int len = 0;     for(;arr[len];len++);      deque&lt;int&gt; dq;     for(int i=1;i&lt;len-1;i++) {         if (arr[i] &gt;= '0' &amp;&amp; arr[i] &lt;= '9') {             num = num * 10 + (arr[i] - '0');         } else {             //a[idx++] = num;             dq.push_back(num);             num = 0;         }     }     if (num) dq.push_back(num);        // R / D command&#47484; &#48152;&#48373;     for(int i=0;str[i];i++) {         if (str[i] == 'R') {             mode = (!mode) ? 1 : 0;         } else if (str[i] == 'D') {             if (mode == 0) {                 if (!dq.empty())                     dq.pop_front();                 else {                     printf(\"error\\n\");                     return;                 }              } else {                 if (!dq.empty())                     dq.pop_back();                 else {                     printf(\"error\\n\");                     return;                 }             }         }     }     printf(\"[\");     int size = dq.size();     if (mode == 0) {         for(int i=0;i&lt;size;i++) {             printf(\"%d\", dq.at(i));             if (i&lt;size-1)             printf(\",\");         }         printf(\"]\\n\");     } else {         for(int i=size-1;i&gt;=0;i--) {             printf(\"%d\", dq.at(i));             if (i&gt;0)             printf(\",\");         }         printf(\"]\\n\");             } }  int main(int argc, char* argv[]) {     freopen(\"input2.txt\", \"r\", stdin);     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       TODO 코드 - STL 없이 deque 만들기     문제 링크    https://www.acmicpc.net/problem/5430    ","categories": [],
        "tags": ["STL","deque"],
        "url": "/boj-5430/",
        "teaser": null
      },{
        "title": "BOJ 5557 1학년",
        "excerpt":" BOJ 5557 1학년    N 100의 수식 사이에 + -를 넣어서 값이 나오도록 하기 0보다 크고 20보다 작아야 한다. 올바른 등식의 수 구하기      접근하기    DP로 접근   DP[N][21]   11 N이 10이고 마지막 8은 답을 찾을 때 쓴다. 1 2 3 4 5 6 7 8 9 10 8 3 2 4 8 7 2 4 0  8  8   -&gt; DP[N-1][8]을 찾아야 함  dp[1][8] = 1;    // 초기값 지정  dp[i][j+a[i]] += dp[i-1][j];  dp[i][j-a[i]] += dp[i-1][j];       코드    #include &lt;cstdio&gt;  int N; typedef long long ll; int a[110]; ll dp[110][21];    // 0 ~ 20  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     N = N - 1;     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }      int ans;     scanf(\"%d\", &amp;ans);     dp[1][a[1]] = 1;      for(int i=2;i&lt;=N;i++) {         for(int j=0;j&lt;=20;j++) {             if (dp[i-1][j]) {                 if (j+a[i] &lt;=20) dp[i][j+a[i]] += dp[i-1][j];                 if (j-a[i] &gt;=0) dp[i][j-a[i]] += dp[i-1][j];             }         }     }      printf(\"%lld\\n\", dp[N][ans]);     return 0; }       문제 링크    https://www.acmicpc.net/problem/5557    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-5557/",
        "teaser": null
      },{
        "title": "BOJ 6359 만취한 상범",
        "excerpt":" BOJ 6349 만취한 상범     접근하기    N이 작으므로, O(N^2)으로 직접 풀어도 된다.   2 5 100  Case1) 5   1 2 3 4 5 1 1 1 1 1 1 2 1 0 1 0 1 3 1 0 0 0 1 4 1 0 0 1 1 5 1 0 0 1 0   -&gt; 2      코드    #include &lt;cstdio&gt; int T;  void solve() {     int N;     int a[101] = {0};     scanf(\"%d\", &amp;N);      for(int i=1;i&lt;=N;i++){         for(int j=i;j&lt;=N;j=j+i){             a[j] = a[j] ^ 1;         }     }      int cnt = 0;     for(int i=1;i&lt;=N;i++){         if (a[i]) cnt++;     }     printf(\"%d\\n\", cnt); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }      TODO 64 bit 연산    두개의 uint64 type을 이용해서 풀이해볼 것      sqrt 풀이    #include &lt;cstdio&gt; #include &lt;cmath&gt; using namespace std;  int T;  void solve() {     int N;     scanf(\"%d\", &amp;N);     printf(\"%d\\n\", (int)sqrt(N)); }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }    https://burningjeong.tistory.com/61 약수의 개수 성질 이용한 풀이     STL bitset    #include &lt;cstdio&gt; #include &lt;bitset&gt; using namespace std;  int T;  void solve() {     int N;     bitset&lt;101&gt; a;      scanf(\"%d\", &amp;N);      for(int i=1;i&lt;=N;i++){         for(int j=i;j&lt;=N;j=j+i){             a[j] = a[j] ^ 1;         }     }      int cnt = 0;     for(int i=1;i&lt;=N;i++){         if (a[i]) cnt++;     }     printf(\"%d\\n\", cnt); }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/6359    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-6539/",
        "teaser": null
      },{
        "title": "BOJ 1357 뒤집힌 덧셈",
        "excerpt":" BOJ 1357 뒤집힌 덧셈     접근하기    숫자를 입력받아, 뒤집는 함수 만들기      코드    #include &lt;cstdio&gt;  int rev(int tmp) {     int ret = 0;     while(tmp) {         ret = ret * 10 + (tmp%10);         tmp = tmp/10;     }     return ret; }  int main(int argc, char* argv[]) {     int n1, n2;     scanf(\"%d %d\", &amp;n1, &amp;n2);     printf(\"%d\\n\", rev(rev(n1) + rev(n2)));     return 0; }      문제 링크    https://www.acmicpc.net/problem/1357    ","categories": [],
        "tags": ["구현"],
        "url": "/boj-1357/",
        "teaser": null
      },{
        "title": "BOJ 16929 Two Dots",
        "excerpt":" BOJ 16929 Two Dots     접근하기    2차원 맵에서 dfs를 하면서, cycle을 찾는다. dfs로 4번 이상 이동했는데, 처음 위치로 돌아올 수 있으면, cycle인 성질에 착안 visit 대신 stack변수로 cycle을 찾을 수 있음      코드- dfs(y, x, color, nmove) 이용    #include &lt;cstdio&gt;  int N, M;  char map[52][52]; int stack[52][52];  int dy[4] = {1, -1, 0, 0}; int dx[4] = {0, 0, 1, -1};  int org_x, org_y;  bool safe(int y, int x) {     return (0&lt;=y &amp;&amp; y&lt;N) &amp;&amp; (0&lt;=x &amp;&amp; x&lt;M); }  int loop;  void dfs(int y, int x, char color, int nmove) {     stack[y][x] = 1;     for(int i=0;i&lt;4;i++) {         int ny = y + dy[i];         int nx = x + dx[i];         if (safe(ny, nx) &amp;&amp; map[ny][nx] == color &amp;&amp; stack[ny][nx] == 0)         {             dfs(ny, nx, color, nmove+1);         } else if(org_y == ny &amp;&amp; org_x == nx &amp;&amp; nmove &gt;= 4) {             loop += 1;             // exit(0) &#54616;&#47732;, 16m/s&#50640; &#51333;&#47308;, &#50504;&#54616;&#47732; 600m/s         }     }      stack[y][x] = 0; }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     loop = 0;     scanf(\"%d %d\", &amp;N, &amp;M);     char str[52];     int cnt = 0;     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             map[i][j] = str[j];         }     }      for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;M;j++) {             if (stack[i][j] == 0) {                 org_y = i;                 org_x = j;                 dfs(i, j, map[i][j], 1);                 stack[i][j] = 1;             }         }             }     if (loop)         printf(\"Yes\\n\");     else         printf(\"No\\n\");      return 0; }      문제 링크    https://www.acmicpc.net/problem/16929    ","categories": [],
        "tags": ["dfs"],
        "url": "/boj-16929/",
        "teaser": null
      },{
        "title": "BOJ 2583 영역 구하기",
        "excerpt":" BOJ 2583 영역 구하기     접근하기    dfs로 0인 영역을 구하고, sort해서 출력      코드    #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;  int M, N, K; int map[101][101]; int visit[101][101]; int x1, y1, x2, y2;  int dy[4] = {1, -1, 0,  0}; int dx[4] = {0,  0, 1, -1};  bool safe(int y, int x) {     return (0&lt;=x &amp;&amp; x&lt;N) &amp;&amp; (0&lt;=y &amp;&amp; y&lt;M); }  vector&lt;int&gt; v;  int dfs(int y, int x) {     int cnt = 1;     visit[y][x] = 1;     for(int i=0;i&lt;4;i++) {         int ny = y + dy[i];         int nx = x + dx[i];          if (safe(ny, nx) &amp;&amp; visit[ny][nx] == 0 &amp;&amp; map[ny][nx] == 0) {             cnt += dfs(ny, nx);             }             }     return cnt; }  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;M, &amp;N, &amp;K);      for(int i=0;i&lt;K;i++) {         scanf(\"%d %d %d %d\", &amp;x1, &amp;y1, &amp;x2, &amp;y2);         for(int y=y1;y&lt;y2;y++) {             for(int x=x1;x&lt;x2;x++) {                 map[y][x] = 1;             }         }     }      for(int i=0;i&lt;M;i++) {         for(int j=0;j&lt;N;j++) {                if (visit[i][j] == 0 &amp;&amp; map[i][j] == 0) {                 int ret = dfs(i, j);                 v.push_back(ret);                 //printf(\"ret:%d\\n\", ret);             }         }             }     sort(v.begin(), v.end());     printf(\"%d\\n\", (int)v.size());     for(auto&amp; o:v) {         printf(\"%d \", o);     }     printf(\"\\n\");         return 0; }      문제 링크    https://www.acmicpc.net/problem/2583    ","categories": [],
        "tags": ["dfs"],
        "url": "/boj-2583/",
        "teaser": null
      },{
        "title": "BOJ 9742 순열",
        "excerpt":" BOJ 9742 순열     접근하기    STL next_permutation을 이용해서 풀기      코드 STL next_permutation 이용    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  char str[20]; char bak[20]; int N;  int main(int argc, char* argv[]) {     while(scanf(\"%s %d\", str, &amp;N) != EOF)   {          int len = 0;         for(;str[len];len++) {             bak[len] = str[len];         }         bak[len] = '\\0';          int cnt = 0;         bool ok = false;         do {             if (N == ++cnt){                 printf(\"%s %d = %s\\n\",bak, N, str);                 ok = true;                 break;             }         } while(next_permutation(str, str+len));          if (!ok) {             printf(\"%s %d = No permutation\\n\",bak, N);         }     }     return 0; }      문제 링크    https://www.acmicpc.net/problem/9742    ","categories": [],
        "tags": ["STL","완전탐색"],
        "url": "/boj-9742/",
        "teaser": null
      },{
        "title": "BOJ 15681 트리와 쿼리",
        "excerpt":" BOJ 15681    정점 U를 root로 하는 sub tree에 속한 정점 수 구하기      접근하기    트리에 DP를 적용해서 풀기 dfs로 tree를 탐색하면서, dp 배열의 값을 점화 규칙에 맞게 채운다.               5          /   \\         4      6         |    / | \\         3   7  8  9        / \\       1   2  U-&gt;5, 9 U-&gt;4, 4 U-&gt;9, 1  tree의 모든 정점에 대해서 dp[parent] = dp[parent] + dfs(child)      코드    #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std;  int N, R, Q; int U; vector&lt;int&gt; G[100010]; int dp[100010]; int visit[100010];  int dfs(int num) {     if (visit[num]) return dp[num];     visit[num] = 1;     for(auto&amp; next:G[num]) {         if (visit[next] == 0) {             dp[num] = dp[num] + dfs(next);           }     }     return dp[num]; }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d %d %d\", &amp;N, &amp;R, &amp;Q);      int p1, p2;     for(int i=0;i&lt;N-1;i++) {         scanf(\"%d %d\", &amp;p1, &amp;p2);         G[p1].push_back(p2);         G[p2].push_back(p1);     }      for(int i=1;i&lt;=N;i++) {         dp[i] = 1;     }      dfs(R);      for(int i=0;i&lt;Q;i++) {         scanf(\"%d\", &amp;U);          printf(\"%d\\n\", dp[U]);     }     return 0; }      문제 링크    https://www.acmicpc.net/problem/15681      참고자료    DP on Trees Tutorial https://justicehui.github.io/hard-algorithm/2019/01/18/treeDP/ https://chanhuiseok.github.io/posts/algo-56/    ","categories": [],
        "tags": ["DP","Tree"],
        "url": "/boj-15681/",
        "teaser": null
      },{
        "title": "BOJ 1676 팩토리얼 0의 개수",
        "excerpt":" BOJ 1676 팩토리얼 0의 개수    N!에서 처음 0이 아닌 숫자가 나올때까지 0의 개수 구하기     접근하기    소인수로 2,5 가 만나는 만큼 0이 생긴다. (이 성질을 알아야 풀 수 있는 문제)   1 2 3 4 5 6 7 8 9 10 --------------------   2   2 5     2   2       2       2   5                2 5 2개 2 7개  이중 작은 개수가 답 2       코드    #include &lt;cstdio&gt;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      int n2 = 0;     int n5 = 0;      for(int i=2;i&lt;=N;i*=2) { // 2 4 8 16 32         n2 += N/i;     }      for(int i=5;i&lt;=N;i*=5) { // 5 25 125 ..         n5 += N/i;     }     if (n5 &gt; n2)          printf(\"%d\\n\", n2);     else         printf(\"%d\\n\", n5);         return 0; }      문제 링크    https://www.acmicpc.net/problem/1676      풀이 참고    https://sihyungyou.github.io/baekjoon-1676/    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-1676/",
        "teaser": null
      },{
        "title": "BOJ 1722 순열의 순서",
        "excerpt":" BOJ 1722 순열의 순서    K번째 정렬된 순열을 출력하기 순열이 주어지면, 몇번째인지 출력하기      접근하기    정렬된 순열의 성질을 파악하고, fact만큼 이동하는 규칙을 찾기     K번째 수열 찾기    N = 4 K = 3  1 ... 6번 나옴 = 3x2 = 3!      1 ~  6 2 ... 6번 나옴                 7 ~ 12 3 ... 6번 나옴                13 ~ 18 4 ... 6번 나옴                19 ~ 24  K가 3!보다 작다는 것은 맨 앞 숫자가 1이라는 것을 의미 K = 3 ans = {1}  K(3) &gt; 2! K가 2!보다 크다는 것은 앞서 선택한 1제외, 2제외 K = K - 2! = 1  1 2 3 4 -&gt; 제외 1 2 4 3 -&gt; 제외 1 3 2 4 1 3 4 2 1 4 2 3 1 4 3 2  K(1) == 1! ans = {1, 3} // 3추가  K(1) == 1 ans = {1, 3, 2}  K(1) == 1 ans = {1, 3, 2, 4}      몇번째 수열인지 출력    4 2 1 3 2 4  1 x x x = 0 1 3 x x =&gt; 1 2 x x = 2! 1 3 2 x =&gt; 1!             2! + 1! = 3       코드    #include &lt;cstdio&gt;  int N; int cmd; typedef long long ll;  ll fact[21];  int a[21]; int visit[21];  int main(int argc, char* argv[]) {      fact[0] = 1;     for(int i=1;i&lt;=20;i++) {         fact[i] = fact[i-1] * i;     }     scanf(\"%d\", &amp;N);     scanf(\"%d\", &amp;cmd);      if (cmd == 1) {         long long K;         scanf(\"%lld\", &amp;K);         for(int i=0;i&lt;N;i++)         {             for(int j=1;j&lt;=N;j++) {                 if (visit[j]) continue;                  if (K &gt; fact[N-1-i]) {                     K -= fact[N-1-i];       // 3 --&gt; 1 --&gt; 0 --&gt; 0                 } else {                     a[i] = j;                     visit[j] = 1;                     break;                 }             }         }          for(int i=0;i&lt;N;i++) {             printf(\"%d \", a[i]);         }         printf(\"\\n\");     } else {  // cmd 2         for(int i=0;i&lt;N;i++) {             scanf(\"%d\", &amp;a[i]);         }          ll ans = 0;         for(int i=0;i&lt;N;i++) {             for(int j=1;j&lt;a[i];j++) {                 if (visit[j]) continue;                 ans += fact[N-i-1];             }             visit[a[i]] = 1;         }         printf(\"%lld\\n\", ans+1);     }      return 0; }        문제 링크    https://www.acmicpc.net/problem/1722      참고자료    https://kosaf04pyh.tistory.com/211    ","categories": [],
        "tags": ["조합"],
        "url": "/boj-1722/",
        "teaser": null
      },{
        "title": "BOJ 13975 파일 합치기 3",
        "excerpt":" BOJ 2213 트리의 독립집합    그리디 방법으로 문제의 성질을 파악하는 문제      접근하기    - 작은 값 두개씩 더하기를 반복하면, 최적임을 발견해야 한다. - 쉽게 보이지 않았음. - 값의 범위가 int를 넘을 수 있음. long long으로 변경  40 30 30 50  30 + 30 = 60  ......... (1)  40 60 50  40 + 50 = 90  ......... (2)  90 60   90 60 = 150   ......... (3)  150        // 하나 남으면 종료  60 + 90 + 150 = 300  ans = 150       코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int T; int N;  typedef long long ll;  void solve() {     priority_queue &lt; ll, vector&lt;ll&gt;, greater&lt;ll&gt; &gt; pq;     ll num;     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%lld\", &amp;num);         pq.push(num);     }      long long sum = 0;     while((int)pq.size() &gt;= 2){         ll n1 = pq.top(); pq.pop();         ll n2 = pq.top(); pq.pop();         sum += n1+n2;         pq.push(n1+n2);     }     printf(\"%lld\\n\", sum); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/13975    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-13975/",
        "teaser": null
      },{
        "title": "BOJ 1949 우수 마을",
        "excerpt":" BOJ 1949 우수 마을    tree 구조에서 DP를 적용하는 문제      접근하기    1. Graph를 인접 리스트로 구성한다 -&gt; Tree가 나옴  2. 1번부터 dfs로 이동한다.  3. 방문한 노드에서 우수마을일때/아닐때를 나눠서 우수마을 주민수를 count한다      dp[k][0] : k 노드가 일반마을이라고 생각했을때, 최대 우수마을 주민수 총합                -&gt; 다음 방문할 마을은 일반마을/우수마을 모두 가능함.                -&gt; 두 경우에서 max의 값을 누적하면 된다.      dp[k][1] : k 노드가 우수마을이라고 생각했을때, 최대 우수마을 주민수 총합                -&gt; 인접한 마을은 모두 '일반'마을 이어야 한다.                -&gt; 우수마을일 수 없음(조건에 위배)  4. dfs가 마무리되면, 1번의 dp[1][1], dp[1][0]에    각각 1번 노드가 우수마을 or 일반마을로 지정했을 때    값이 들어있음. max값을 출력      코드    #include &lt;bits/stdc++.h&gt; //#include &lt;cstdio&gt; //#include &lt;vector&gt; using namespace std;  int N; int a[10010];         // &#51452;&#48124;&#49688; vector&lt;int&gt; G[10010]; // &#47560;&#51012;&#44036; &#50672;&#44288;&#51012; graph &#54364;&#49884; int done[10010]; int dp[10010][2];  void dfs(int num) {     done[num] = 1;      // &#49884;&#51089;     dp[num][0] = 0;         // &#51068;&#48152;&#47560;&#51012;&#51060;&#47732; 0     dp[num][1] = a[num];    // &#50864;&#49688;&#47560;&#51012;&#51060;&#47732; &#51064;&#44396;&#49688; &#52628;&#44032;      for(auto&amp; next:G[num]) {         if (!done[next]) {             dfs(next);             dp[num][0] += max(dp[next][0], dp[next][1]);             dp[num][1] += dp[next][0];         }     } }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }     for(int i=0;i&lt;N;i++) {         int p1, p2;         scanf(\"%d %d\", &amp;p1, &amp;p2);         G[p1].push_back(p2);         G[p2].push_back(p1);     }     dfs(1);     printf(\"%d\\n\", max(dp[1][0], dp[1][1]));     return 0; }       문제 링크    https://www.acmicpc.net/problem/1949    ","categories": [],
        "tags": ["DP","dfs","Tree"],
        "url": "/boj-1949/",
        "teaser": null
      },{
        "title": "BOJ 2213 트리의 독립집합",
        "excerpt":" BOJ 2213 트리의 독립집합    tree 구조에서 DP를 적용하는 문제      접근하기                   1 3 5 7을 선택하면    1            10 + 40 + 20 + 70 = 140   |   2  / \\ 3   6  |   | 4   7 | 5        코드    i#include &lt;bits/stdc++.h&gt;  using namespace std;  int N; int a[10010]; int done[10010]; int dp[10010][2]; vector&lt;int&gt; G[10010];   // &#51064;&#51217;&#47532;&#49828;&#53944; vector&lt;int&gt; ans;  void dfs(int num) {     done[num] = 1;     dp[num][0] = 0;     // &#46021;&#47549; X     dp[num][1] = a[num];// &#46021;&#47549; O      for(auto&amp; next:G[num]) {         if (!done[next]) {             dfs(next);             dp[num][1] += dp[next][0];                  // &#46021;&#47549; -&gt; &#45796;&#51020;&#51008; &#51068;&#48152;             dp[num][0] += max(dp[next][0], dp[next][1]);// &#51068;&#48152; -&gt; &#45796;&#51020;&#51008; &#46021;&#47549;/&#51068;&#48152;         }     } }  // path&#47484; &#52636;&#47141;&#54616;&#44592; void walk(int num, int prev)  {     if (dp[num][1] &gt; dp[num][0] &amp;&amp; !done[prev]) {         done[num] = 1;         ans.push_back(num);     }      for(auto&amp; next:G[num]) {         if (next != prev) {             walk(next, num);         }     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }      for(int i=0;i&lt;N-1;i++) {         int p1, p2;         scanf(\"%d %d\", &amp;p1, &amp;p2);         G[p1].push_back(p2);         G[p2].push_back(p1);     }     dfs(1);             // 1&#48264;&#51012; root&#47196; dfs&#47196; dp table &#52292;&#50864;&#44592;     printf(\"%d\\n\", max(dp[1][0], dp[1][1]));     for(int i=1;i&lt;=N;i++) done[i] = 0;      walk(1, 0);     sort(ans.begin(), ans.end());     for(auto o:ans) {         printf(\"%d \", o);     }     printf(\"\\n\");     return 0; }       문제 링크    https://www.acmicpc.net/problem/2213      풀이 참고    https://kth990303.tistory.com/158    ","categories": [],
        "tags": ["DP","dfs","Tree"],
        "url": "/boj-2213/",
        "teaser": null
      },{
        "title": "BOJ 2533 사회망 서비스(SNS)",
        "excerpt":" BOJ 2533 사회망 서비스(SNS)    tree 구조에서 DP를 적용하는 문제      접근하기    1. Graph를 인접 리스트로 구성한다 -&gt; Tree가 나옴  2. 1번부터 dfs로 이동한다.  3. 방문한 노드에서 얼리아답터/일반인 일때를 나눠서 dp 배열을 채움      dp[k][0] : k 노드가 일반인일 때 sub tree에서 얼리아답터 수의 총합               -&gt; 자식노드가 무조건 얼리아답터여야 한다      dp[k][1] : k 노드가 얼리아답터일 때 sub tree에서 얼리아답터 수의 총합               -&gt; 자식 노드가 얼리아답터 or 일반인  4. dfs가 마무리되면, 1번의 dp[1][1], dp[1][0]에    각각 1번 노드가 일반인/얼리아답터 일 때,  최소 수가 들어있음    이중 최소값 출력       코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; vector&lt;int&gt; G[1000010]; int done[1000010]; int dp[1000010][2];  void dfs(int num) {     dp[num][0] = 0; // &#51068;&#48152;&#51064;     dp[num][1] = 1; // &#50620;&#47532;&#50500;&#45813;&#53552;     done[num] = 1;      for(auto&amp; next:G[num]) {         if (!done[next]) {             dfs(next);             // &#48512;&#47784;&#44032; &#51068;&#48152; - &#51088;&#49885;&#51008; &#47784;&#46160; &#50620;&#47532;&#50500;&#45813;&#53552;             dp[num][0] += dp[next][1];             // &#48512;&#47784;&#44032; &#50620;&#47532; - &#51088;&#49885;&#51008; &#50620;&#47532; or &#51068;&#48152;             dp[num][1] += min(dp[next][0], dp[next][1]);         }     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int p1, p2;         for(int i=0;i&lt;N-1;i++){                 scanf(\"%d %d\", &amp;p1, &amp;p2);         G[p1].push_back(p2);         G[p2].push_back(p1);     }     dfs(1);      printf(\"%d\\n\", min(dp[1][0], dp[1][1]));     return 0; }       문제 링크    https://www.acmicpc.net/problem/2533    ","categories": [],
        "tags": ["DP","dfs","Tree"],
        "url": "/boj-2533/",
        "teaser": null
      },{
        "title": "BOJ 1080 행렬",
        "excerpt":" BOJ 1080 행렬    NxM 행렬을 2개 주고, 3x3 부분행렬 뒤집어서 두번재 행렬과 같게 되는 뒤집기 회수 구하기      접근하기    같은 위치를 두번 뒤집으면 원래 모습 -&gt; 답이 될 수 없음 3x3행렬을 처음부터 끝까지 적용해보기   3 4 (처음) 0000 0010 0000  (1,1에서 뒤집기) 1110 1100 1110  (2,2에서 뒤집기) -&gt; 목표와 같음 1001 1011 1001  (목표) 1001 1011 1001      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; int a[100010];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++)         scanf(\"%d\", &amp;a[i]);     sort(a, a+N);      int ans = 0;     for(int i=N-1, cnt=1;i&gt;=0;i--, cnt++) {         ans = max(ans, a[i]*cnt);     }     printf(\"%d\\n\", ans);     return 0; }        문제 링크    https://www.acmicpc.net/problem/1080      풀이참고    https://hongjw1938.tistory.com/178    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1080/",
        "teaser": null
      },{
        "title": "BOJ 1339 단어 수학",
        "excerpt":" BOJ 1339 단어 수학    그리디 방법으로 문제의 성질을 파악하는 문제      접근하기      GCF ACDEB  A = 10000               // 10000의 자리에 A가 나옴 C = 1010  = 1000 + 10   // 1000의 자리, 10의 자리에 한번씩 나옴 D = 100 G = 100 E = 10 F = 1 B = 1  이렇게 자릿수를 표현하고 정렬하면  10000 1010 100 100  10   1   1   A    C    D   G    E   F   B   9    8    7   6    5   4   3 &lt;- 9부터 차례로 매핑  98753   684 ----- 99437       코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; char str[10]; typedef long long ll;  long long pow10(int n) {     long long ans = 1;      for(int i=1;i&lt;=n;i++) {         ans *= 10;     }     return ans; }  int main(int argc, char* argv[]) {     //freopen(\"input.txt\", \"r\", stdin);     //freopen(\"input3.txt\", \"r\", stdin);     freopen(\"input4.txt\", \"r\", stdin);     //freopen(\"input2.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     ll table[26] = {0};      ll result = 0;     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);          int len = 0;         for(;str[len];len++);          for(int j=0;j&lt;len;j++) {             int idx = str[j] - 'A';             table[idx] += pow10(len-j-1);         }      }     sort(table, table+26);     int cnt = 9;     for(int i=25;i&gt;=0;i--) {         if (table[i] == 0) break;         result += (table[i] * cnt--);     }     printf(\"%lld\\n\", result);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1339      풀이참고    https://pskpsk.tistory.com/entry/백준1339-단어-수학 https://mygumi.tistory.com/156    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1339/",
        "teaser": null
      },{
        "title": "BOJ 1826 연료 채우기",
        "excerpt":" BOJ 1826 연료 채우기    N개의 주유소가 거리별로 주어짐. 주유소마다 다른 양의 기름 넣을 수 있음     접근하기    cnt             1               2           3 일직선  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 주유소          4 2             5          10                            10 연료   10                    0                              4           0              0                             {2}         {2}            10                                                        {2} cnt = 3  P &lt; L 인 조건동안 반복     1. 연료를 넣지 않아도, 10까지 갈 수 있음. 10안에 4, 2만큼 기름을 채울 수 있음     2. 위치10에서 4를 넣는다. (max heap을 이용해서, 큰 값을 꺼냄 -&gt; +4를 함)     3. 14까지 갈 수 있음. 11위치의 주유소 5의 값을 pq에 추가 pq = (5, 2) -&gt;5 꺼냄     4. 19까지 갈 수 있음. 15위치의 주유소 10의 값을 pq에 추가 pq = (10, 2) -&gt; 10 꺼냄     - 예외처리 : P &lt; L조건인데, pq가 비어있으면 도착할 수 없음       코드    #include &lt;bits/stdc++.h&gt; using namespace std; int N;  // first : num // second : gas typedef pair&lt;int, int&gt; Node;  Node a[10010];      // &#51452;&#50976;&#49548; int L, P;  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;a[i].first, &amp;a[i].second);     }     scanf(\"%d %d\", &amp;L, &amp;P);     sort(a, a+N);      priority_queue&lt;int&gt; pq; // max heap      int idx = 0;     int cnt = 0;     while(P &lt; L) { // &#44592;&#47492;(P)&#44032; &#46020;&#52265;&#51648;(L)&#48372;&#45796; &#51089;&#51008; &#46041;&#50504;         while(a[idx].first &lt;= P &amp;&amp; idx &lt; N) {             pq.push(a[idx].second);             idx++;         }          if (pq.empty()) {             cnt = -1;             break;         }         cnt += 1;         P += pq.top(); pq.pop();     }     printf(\"%d\\n\", cnt);     return 0; }        문제 링크    https://www.acmicpc.net/problem/1826      풀이 참고    https://jason9319.tistory.com/228    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1826/",
        "teaser": null
      },{
        "title": "BOJ 2217 로프",
        "excerpt":" BOJ 2217 그리디    N개의 로프 - 버틸수 있는 최대 중량을 구하기     접근하기    2 10 15  min(15, 15) x 1 = 15 min(10, 15) x 2 = 20  &lt;= 예제 답  가장큰 중량 x 1 다음 중량   x 2 ... 가장작은 중량 x N  이중 가장 큰 값 구하기      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; int a[100010];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++)         scanf(\"%d\", &amp;a[i]);     sort(a, a+N);      int ans = 0;     for(int i=N-1, cnt=1;i&gt;=0;i--, cnt++) {         ans = max(ans, a[i]*cnt);     }     printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2217    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-2217/",
        "teaser": null
      },{
        "title": "BOJ 8983 사냥꾼",
        "excerpt":" BOJ 8983 사냥꾼         접근하기    1. 동물에서 사대를 하나씩 찾아본다. 2. 사대는 y좌표가 0인 x좌표만으로 생각할 수 있음. 3. L보다 동물.y가 더 크면, 사정거리 밖임 -&gt; 걸러내기 4. L - 동물.y = xdiff    -&gt; 동물.x + xdiff or 동물.x - xdiff       사이에 발사대가 있으면, 사정거리 안쪽      코드 - STL lower bound &amp; upper bound 이용    #include &lt;bits/stdc++.h&gt; using namespace std;  int M, N, L;     int a[100010];  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;M, &amp;N, &amp;L);     for(int i=0;i&lt;M;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+M);     int ans = 0;     for(int i=0;i&lt;N;i++) {         int ax, ay;         scanf(\"%d %d\", &amp;ax, &amp;ay);         if (ay - L &gt; 0) continue;         int xdiff = abs(L - ay);         int is_found = upper_bound(a, a+M, ax + xdiff) - lower_bound(a, a+M, ax - xdiff);         if (is_found) ans++;     }     printf(\"%d\\n\", ans);     return 0; }       코드 - 스위핑    #include &lt;bits/stdc++.h&gt; using namespace std;  int M, N, L;     int a[100010];  typedef struct Animal {     int y;     int x; } Animal;  Animal animal[100010];  bool comp(Animal&amp; p1, Animal&amp; p2) {     if (p1.x == p2.x)         return p1.y &lt; p2.y;     else         return p1.x &lt; p2.x; }  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;M, &amp;N, &amp;L);     for(int i=0;i&lt;M;i++) {         scanf(\"%d\", &amp;a[i]);     }      for(int i=0;i&lt;N;i++) {         int ax, ay;         scanf(\"%d %d\", &amp;ax, &amp;ay);         animal[i].x = ax;         animal[i].y = ay;     }     sort(a, a+M);     sort(animal, animal+N, comp);      int ans = 0;      int idx = 0;     for(int i=0;i&lt;N;i++) {         while(idx != M-1 &amp;&amp; a[idx + 1] &lt;= animal[i].x) {             idx++;             } // a[idx+1] &gt; animal[i].x &#51312;&#44148;&#50640;&#49436; loop &#51333;&#47308;         // a[idx+1] &#49324;&#45824; &#50724;&#47480;&#51901;         // a[idx] &#49324;&#45824; &#50812;&#51901;&#50640; &#51080;&#51020;          if (abs(a[idx] - animal[i].x) + animal[i].y &lt;= L)             ans += 1; // &#46041;&#47932;&#44592;&#51456; &#50812;&#51901; &#48156;&#49324;&#45824;         else if (idx != M-1 &amp;&amp; abs(a[idx+1] - animal[i].x) + animal[i].y &lt;= L)             ans += 1; // &#46041;&#47932;&#44592;&#51456; &#50724;&#47480;&#51901; &#48156;&#49324;&#45824;                        }     printf(\"%d\\n\", ans);     return 0; }       TODO 코드 - 이분탐색 구현     문제 링크    https://www.acmicpc.net/problem/8983    ","categories": [],
        "tags": ["이분탐색"],
        "url": "/boj-8983/",
        "teaser": null
      },{
        "title": "BOJ 2206 벽 부수고 이동하기",
        "excerpt":" BOJ 2206 벽 부수고 이동하기    NxM 맵에서 0은 이동 가능하다. 0, 0 에서 N-1, M-1로 이동하는 최단거리 구하기 이 때, 한번은 벽(1)을 부수고 이동할 수 있다.      접근하기    visit[y][x][2]로 확장  0 : (y, x)에 0인 상태로 방문, 기존에 벽을 부수거나 안 부수거나 상관없이 진행  1 : (y, x)에 1인 상태로 방문, 앞으로는 벽을 부술 수 없음      코드    #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std;  int N, M;  #define SIZE 1010  int map[SIZE][SIZE]; int visit[SIZE][SIZE][2];  typedef struct Node {     int y;     int x;     int broke;     int dist; } Node;  Node start; Node dest;  int dy[4] = {1, -1, 0, 0}; int dx[4] = {0, 0, 1, -1};  bool safe(int y, int x) {     return (0&lt;=x &amp;&amp; x&lt;M) &amp;&amp; (0&lt;=y &amp;&amp; y&lt;N); } int ans; void bfs() {     queue&lt;Node&gt; q;     visit[0][0][0] = 1;     q.push({0, 0, 0, 1});       while(!q.empty()) {         Node cur = q.front(); q.pop();          if (cur.y == dest.y &amp;&amp; cur.x == dest.x) {             ans = cur.dist;             return;         }         for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];             int broke = cur.broke;             int dist = cur.dist;             if (safe(ny, nx)) {                 if (map[ny][nx] == 0 &amp;&amp; !visit[ny][nx][broke]) {                     visit[ny][nx][broke] = 1;                     q.push({ny, nx, broke, dist + 1});                 } else if (map[ny][nx] == 1 &amp;&amp; broke == 0) {                     visit[ny][nx][1] = 1;                     q.push({ny, nx, 1, dist + 1});                 }             }         }     } }  int main(int argc, char* argv[]) {     ans = -1;     scanf(\"%d %d\", &amp;N, &amp;M);     char str[1010];     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             map[i][j] = str[j] - '0';         }     }      start.y = 0;     start.x = 0;      dest.y = N-1;     dest.x = M-1;      bfs();     printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2206      풀이/해설참고    https://yabmoons.tistory.com/73    ","categories": [],
        "tags": ["bfs","그래프"],
        "url": "/boj-2206/",
        "teaser": null
      },{
        "title": "BOJ 3055 탈출",
        "excerpt":" BOJ 3055 탈출    물이 계속 차오르고 있을때, 고슴도치가 물을 피해, S에서 D로 이동할 최소시간      접근하기    BFS로 풀기. 물의 확장을 bfs로 탐색 water_map에 채우기   water    bebber 0 1 0    3 0 0 3 2 1    2 1 0 4 0 2    1 0 1  - 목적지는 water[y][x] = 0 상태 - water[ny][nx] &gt; bebber[y][x] + 1    -&gt; 이동할 좌표가 물이 찬 시간 &gt; 비버의 현재시간 + 1  (이 조건을 생각해내는 것이 중요)       코드    #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std;  int R, C;  #define MAX_H 51 #define MAX_W 51  char map[MAX_H][MAX_H]; int water[MAX_H][MAX_H]; int bebber[MAX_H][MAX_H];  typedef struct Node {     int y;     int x; } Node;  queue&lt;Node&gt; water_q;  Node start; Node dest;  int dy[4] = {1, -1, 0, 0}; int dx[4] = {0, 0, 1, -1};  bool safe(int y, int x) {     return (0&lt;=x &amp;&amp; x &lt; C) &amp;&amp; (0&lt;=y &amp;&amp; y &lt; R); }  void bfs_water() {     while(!water_q.empty()) {         Node cur = water_q.front(); water_q.pop();          for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];                 int nx = cur.x + dx[i];              if (safe(ny, nx) &amp;&amp; !water[ny][nx] &amp;&amp; map[ny][nx] == '.') {                 water[ny][nx] = water[cur.y][cur.x] + 1;                 water_q.push({ny, nx});             }         }     } }  void bfs_bebber() {     queue&lt;Node&gt; q;     q.push(start);      while(!q.empty()) {         Node cur = q.front(); q.pop();          for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];              if (safe(ny, nx) &amp;&amp; !bebber[ny][nx] &amp;&amp; (map[ny][nx] == '.' || map[ny][nx] == 'D')) {                  if (water[ny][nx] == 0) {                     bebber[ny][nx] = bebber[cur.y][cur.x] + 1;                     q.push({ny, nx});                 } else if (water[ny][nx] &gt; bebber[cur.y][cur.x] + 1) {                     bebber[ny][nx] = bebber[cur.y][cur.x] + 1;                     q.push({ny, nx});                 }             }          }     } }  int main(int argc, char* argv[]) {     freopen(\"input4.txt\", \"r\", stdin);     scanf(\"%d %d\", &amp;R, &amp;C);     char str[51];     for(int i=0;i&lt;R;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             map[i][j] = str[j];             if (str[j] == '*') {                 water_q.push({i,j});                     } else if (str[j] == 'S') {                 start.y = i;                 start.x = j;                 //printf(\"i:%d j:%d \\n\", i, j);             } else if (str[j] == 'D') {                 dest.y = i;                 dest.x = j;             }         }     }     bfs_water(); #if 0     for(int i=0;i&lt;R;i++) {         for(int j=0;j&lt;C;j++) {             printf(\"%d \", water[i][j]);         }                 printf(\"\\n\");     } #endif      bfs_bebber(); #if 0         for(int i=0;i&lt;R;i++) {         for(int j=0;j&lt;C;j++) {             printf(\"%d \", bebber[i][j]);         }                 printf(\"\\n\");     } #endif         if (bebber[dest.y][dest.x] == 0) {         printf(\"KAKTUS\\n\");     } else {         printf(\"%d\\n\", bebber[dest.y][dest.x]);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/3055       풀이참고/해설참고    https://yabmoons.tistory.com/66    ","categories": [],
        "tags": ["bfs","그래프"],
        "url": "/boj-3055/",
        "teaser": null
      },{
        "title": "BOJ 9205 맥주 마시면서 걸어가기",
        "excerpt":" BOJ 9205 맥주 마시면서 걸어가기    출발지점, 중간지점여러개, 도착지점을 갈 때, 각 점마다 1000이하의 비용만 이동가능 도착 가능한지 출력      접근하기    1. 집 -&gt; 편의점1 -&gt; 편의점2 -&gt; ... -&gt; 편의점N -&gt; 목적지  2. 편의점 개수가 100개이므로, O(N^2)으로 순서대로 연결함 (distance가 1000이하인 경우)    -&gt; 인접 list를 구성함  3. dfs(0)하고 visit[N-1]이 true이면 목적지에 도착한 것임       코드 - dfs로 풀이    #include &lt;bits/stdc++.h&gt; using namespace std;  int T; int N;  typedef pair&lt;int, int&gt; Point;  #define ARR_CNT (100+2+10) Point a[ARR_CNT]; int vis[ARR_CNT]; vector&lt;int&gt; G[ARR_CNT];  int distance(Point&amp; p1, Point&amp; p2) {     return abs(p1.first - p2.first) + abs(p1.second - p2.second); }  void dfs(int num) {     vis[num] = 1;     for(auto&amp; next:G[num]) {         if (!vis[next]) {             dfs(next);         }     } }  void solve() {     scanf(\"%d\", &amp;N);     N = N + 2;     for(int i=0;i&lt;=N;i++) {         vis[i] = 0;         G[i].clear();     }      for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;a[i].first, &amp;a[i].second);     }      // graph &#44221;&#47196;&#47484; &#44396;&#49457;     for(int i=0;i&lt;N-1;i++) {         for(int j=i+1;j&lt;N;j++) {             if (distance(a[i], a[j]) &lt;= 20*50) {                 G[i].push_back(j);                 G[j].push_back(i);             }         }             }     dfs(0); // 0&#48264;&#51060; &#49345;&#44540;&#51060;&#45348; &#51665;     if (vis[N-1] == true)         printf(\"happy\\n\");     else         printf(\"sad\\n\");     }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }        TODO 코드 - 플로이드 와샬    구글링 해볼 것      문제 링크    https://www.acmicpc.net/problem/9205      풀이 참고 (아이디어)    https://jaimemin.tistory.com/709    ","categories": [],
        "tags": ["dfs","그래프"],
        "url": "/boj-9205/",
        "teaser": null
      },{
        "title": "BOJ 1744 수 묶기",
        "excerpt":" BOJ 1744 수 묶기    수열에서 두 수를 묶어서 곱하거나, 묶지 않은 상태로 총합 구하기      접근하기    Case1 -1 0 1       -&gt; 음수와 0이 만나면 소거됨  Case2 -9 -2 0 1    -&gt; 음수 x 음수 = 양수    Case3 1 3          -&gt;  1 x 양수 &lt; 1 + 양수   max heap - 1보다 큰 수 저장 -&gt; 2개씩 꺼내서 곱하고, 남은 건 더하기 min heap - 음의 정수 저장   -&gt; 2개씩 꺼내서 곱하고, zero_cnt로 소거한 후,  남은 건 더하기(뺄셈효과) zero_cnt - 0 개수 세기 one_cnt  - 1 개수 세기 -&gt; 마지막에 더하기      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  // &#50577;&#49688; priority queue // &#51020;&#49688; priority queue // zero_cnt // one_cnt  priority_queue&lt;int&gt; plus_pq; // max heap priority_queue &lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; minus_pq; // min heap int zero_cnt; int one_cnt;  int N; int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      zero_cnt = 0;     one_cnt = 0;      int ans = 0;         for(int i=0;i&lt;N;i++) {         int num;         scanf(\"%d\", &amp;num);         if (num == 0)             zero_cnt += 1;         else if (num == 1)             one_cnt += 1;         else if ( num &gt; 1) {             plus_pq.push(num);             int ret = plus_pq.size();             //printf(\"size : %d \\n\", ret);         } else if ( num &lt; 0) {             minus_pq.push(num);         }     }      while(minus_pq.size() &gt;= 2) {         int n1 = minus_pq.top(); minus_pq.pop();         int n2 = minus_pq.top(); minus_pq.pop();         ans += (n1*n2);     }     if (minus_pq.size() == 1) {         if (zero_cnt &gt; 0) {             zero_cnt--;         } else {             int n1 = minus_pq.top(); minus_pq.pop();             ans += n1;         }     }      while(plus_pq.size() &gt;= 2) {         int n1 = plus_pq.top(); plus_pq.pop();         int n2 = plus_pq.top(); plus_pq.pop();          ans += (n1*n2);     }     if (plus_pq.size() == 1) {         int n1 = plus_pq.top(); plus_pq.pop();         ans += n1;     }     ans += one_cnt;      printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1744    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1744/",
        "teaser": null
      },{
        "title": "BOJ 2585 경비행기",
        "excerpt":" BOJ 2585 경비행기    출발지 S에서 목적지 S로 중간 주유소를 거쳐서 갈 때, K번 이하로 갈 수 있으면, 최소 연료통 크기 구하기 직선거리를 기준으로 하고, 연료통 크기 x 10만큼의 거리를 감      접근하기    1. 연료통 크기를 이분탐색 0~ (0,0) ~ (10000, 10000)까지의 거리 2. mid값을 이용해서 bfs    - 시작점부터 끝점까지 가지는지 반복한다.    - N이 1000정도로 작음, 매번 N번씩 loop돌면서, 다음 방문 위치를 찾기    - visit배열을 이용해서, 이미 방문한 곳은 제외      코드 - binsearch recursive - memo 적용 (28 m/s -&gt; 12 m/s)    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, K; #define SIZE 1010  typedef struct Node {     int y;     int x; } Node;  Node a[SIZE]; int visited[SIZE];  int memo[SIZE][SIZE]; // 28 m/s -&gt; 12 m/s  int calc_oil(int idx1, int idx2) {     if (memo[idx1][idx2]) return memo[idx1][idx2];      int dist = ceil(sqrt(pow(a[idx2].x - a[idx1].x, 2)                  + pow(a[idx2].y - a[idx1].y, 2)));     if(dist % 10 == 0){         return memo[idx1][idx2] = dist/10;     } else {         return memo[idx1][idx2] = dist/10+1;     } }  typedef struct Point {     int idx;    // &#54788;&#51116; &#50948;&#52824;     int cnt;    // &#49884;&#51089;&#51216;&#48512;&#53552; &#47751;&#48264; &#44040;&#50500;&#53460;&#45716;&#51648; } Point;  int bfs(int tongkgi) {     for(int i=0;i&lt;N;i++) visited[i] = 0;     queue&lt;Point&gt; q;      q.push({0,0});      // index, &#51473;&#44036;&#44553;&#50976; &#54943;&#49688;     visited[0] = 1;     while(!q.empty()) {         Point cur = q.front(); q.pop();          if (calc_oil(cur.idx, N-1) &lt;= tongkgi)             return 1;         if (cur.cnt &gt; K) return 0;         for(int next=1;next&lt;N-1;next++) {             if (!visited[next] &amp;&amp; calc_oil(cur.idx, next) &lt;= tongkgi) {                 visited[next] = 1;                 q.push({next, cur.cnt + 1});             }         }     }     return 0; }  int ans = 0; void binary_search(int left, int right) {     if (left &gt; right) return;     int mid = (left + right) / 2;      if (bfs(mid) != 0) {         ans = mid;         binary_search(left, mid-1);     } else {         binary_search(mid+1, right);                 } }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d %d\", &amp;N, &amp;K);      // &#51473;&#44036; &#48708;&#54665;&#51109; &#51077;&#47141;     for(int i=1;i&lt;=N;i++) {         scanf(\"%d %d\", &amp;a[i].x, &amp;a[i].y);     }        a[0].y = 0;     a[0].x = 0;      a[N+1].y = 10000;     a[N+1].x = 10000;     N = N + 2;        binary_search(0, 14143);     printf(\"%d\\n\", ans);     return 0; }  // 14143&#51008; (0, 0) ~ (10000, 10000)&#44620;&#51648;&#51032; &#51649;&#49440;&#44144;&#47532; // math.sqrt(pow(10000, 2) + pow(10000, 2))                                                          // 14142.13562373095 -&gt; 14143         코드 - binsearch iterative - memo 적용 (12 m/s -&gt; 8 m/s)    void binary_search(int left, int right) {     while(left &lt;= right)     {         int mid = (left + right) / 2;         if (bfs(mid) != 0) {             ans = mid;             right = mid - 1;         } else {             left = mid + 1;         }            } }        문제 링크    https://www.acmicpc.net/problem/2585      풀이/해설 참고    https://velog.io/@pjh612/백준-2585번-경비행기 https://chan-7uly.tistory.com/11    ","categories": [],
        "tags": ["이분탐색","bfs"],
        "url": "/boj-2585/",
        "teaser": null
      },{
        "title": "BOJ 14442 벽 부수고 이동하기 2",
        "excerpt":" BOJ 14442    NxM 맵이 주어질 때, K번 부수고, 0,0에서 N-1,M-1로 이동하는지 체크       접근하기    visit[y][x][cnt] : cnt번 부수고 이동함  현재 위치도 방문 안했을 때, 구동해야 함 --&gt; visit[ny][nx][cnt] == 0  현재보다 다음에 한번 더 부수고 이동할 때도, 방문 안했어야 함 --&gt; visit[ny][nx][cnt + 1] == 0      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, M, K;  #define SIZE 1010 int m[SIZE][SIZE]; int visited[SIZE][SIZE][11];  int dy[4] = {1, -1, 0, 0}; int dx[4] = {0, 0, 1, -1};  void dbg() {     for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;M;j++) {             printf(\"%d \", m[i][j]);         }         printf(\"\\n\");     } }  typedef struct Node {     int x;     int y;     int cnt_broke;     int dist; } Node;  Node Start;  bool safe(int y, int x) {     //return (0&lt;=x &amp;&amp; x&lt;M) &amp;&amp; (0&lt;=y &amp;&amp; y&lt;N);     return (0&lt;=x &amp;&amp; x&lt;N) &amp;&amp; (0&lt;=y &amp;&amp; y&lt;M); }  int bfs() {     queue&lt;Node&gt; q;     q.push({0, 0, 0, 1});     visited[0][0][0] = 1;      while(!q.empty()) {         Node cur = q.front(); q.pop();             if (cur.x == N - 1 &amp;&amp; cur.y == M -1) {             return cur.dist;         }          for(int i=0;i&lt;4;i++) {             int nx = cur.x + dx[i];             int ny = cur.y + dy[i];             int broke = cur.cnt_broke;             int dist = cur.dist;              if (safe(ny, nx) &amp;&amp; !visited[nx][ny][broke]) {                 if (m[nx][ny] == 1) {                     if (broke &lt; K &amp;&amp; !visited[nx][ny][broke+1]) {                         visited[nx][ny][broke+1] = 1;                         q.push({nx, ny, broke+1, dist+1});                     }                 } else if (m[nx][ny] == 0) {                     visited[nx][ny][broke] = 1;                     q.push({nx, ny, broke, dist+1});                 }             }         }     }     return -1; }  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K);      char str[1010];     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             m[i][j] = str[j] - '0';         }     }     printf(\"%d\\n\", bfs());     return 0; }        문제 링크    https://www.acmicpc.net/problem/14442    ","categories": [],
        "tags": ["bfs"],
        "url": "/boj-14442/",
        "teaser": null
      },{
        "title": "BOJ 16933 벽 부수고 이동하기 3",
        "excerpt":" BOJ 16933 벽 부수고 이동하기 3    NxM 맵이 주어질 때, K번 부수고, 0,0에서 N-1,M-1로 이동하는지 체크 낮에만 벽을 부술 수 있음      접근하기    visit[y][x][cnt] : cnt번 부수고 이동함  현재 위치도 방문 안했을 때, 구동해야 함 --&gt; visit[ny][nx][cnt] == 0  현재보다 다음에 한번 더 부수고 이동할 때도, 방문 안했어야 함 --&gt; visit[ny][nx][cnt + 1] == 0  queue에 들어가는 구조체에 is_day 필드 추가      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, M, K;  #define SIZE 1010 int m[SIZE][SIZE]; int visited[SIZE][SIZE][11];  int dy[4] = {1, -1, 0, 0}; int dx[4] = {0, 0, 1, -1};  void dbg() {     for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;M;j++) {             printf(\"%d \", m[i][j]);         }         printf(\"\\n\");     } }  typedef struct Node {     int x;     int y;     int cnt_broke;     int dist;     int is_day; } Node;  Node Start;  bool safe(int y, int x) {     return (0&lt;=x &amp;&amp; x&lt;N) &amp;&amp; (0&lt;=y &amp;&amp; y&lt;M); }  int bfs() {     queue&lt;Node&gt; q;     q.push({0, 0, 0, 1, 1});     visited[0][0][0] = 1;      while(!q.empty()) {         Node cur = q.front(); q.pop();             if (cur.x == N - 1 &amp;&amp; cur.y == M -1) {             return cur.dist;         }          for(int i=0;i&lt;4;i++) {             int nx = cur.x + dx[i];             int ny = cur.y + dy[i];             int broke = cur.cnt_broke;             int dist = cur.dist;             int is_day = cur.is_day;              if (safe(ny, nx) &amp;&amp; !visited[nx][ny][broke]) {                 if (m[nx][ny] == 1) {                     if (broke &lt; K &amp;&amp; !visited[nx][ny][broke+1]) {                         if (is_day) {                             visited[nx][ny][broke+1] = 1;                             q.push({nx, ny, broke+1, dist+1, is_day^1});                         } else {                             // &#48164;&#51060;&#47732;, &#54788;&#51116; &#50948;&#52824;&#50640; &#44144;&#47532;1 &#52628;&#44032;/&#48164;&#45230; &#48148;&#45000;                             q.push({cur.x, cur.y, broke, dist+1, is_day^1});                         }                     }                 } else if (m[nx][ny] == 0) {                     visited[nx][ny][broke] = 1;                     q.push({nx, ny, broke, dist+1, is_day^1});                 }             }         }     }     return -1; }  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K);      char str[1010];     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             m[i][j] = str[j] - '0';         }     }     printf(\"%d\\n\", bfs());     return 0; }       문제 링크    https://www.acmicpc.net/problem/16933    ","categories": [],
        "tags": ["bfs"],
        "url": "/boj-16933/",
        "teaser": null
      },{
        "title": "BOJ 17362 수학은 체육과목 입니다. 2",
        "excerpt":" BOJ 17362 수학은 체육과목 입니다. 2    규칙성을 찾아야 하는 문제      접근하기    // 1엄지 2검지 3중지 4약지 5새끼 // N % 8  // 1 -   n1 // 2 -   n2 // 3 -   n3 // 4 -   n4 // 5 -   n5 // 6 -   n4 // 7 -   n3 // 8 -  0 n2 // 9 -  1 n1 // 10 - 2 n2 // 11 - 3 n3      코드    #include &lt;bits/stdc++.h&gt;  int main(int argc, char* argv[]) {         int N;          scanf(\"%d\", &amp;N);         int ans = 0;         switch(N%8)         {         case 1:ans = 1; break;         case 2:ans = 2; break;         case 3:ans = 3; break;         case 4:ans = 4; break;         case 5:ans = 5; break;           case 6:ans = 4; break;           case 7:ans = 3; break;                   case 0:ans = 2; break;         }         printf(\"%d\\n\", ans);         return 0; }         문제 링크    https://www.acmicpc.net/problem/17362    ","categories": [],
        "tags": ["bfs"],
        "url": "/boj-17362/",
        "teaser": null
      },{
        "title": "BOJ 14725 개미굴",
        "excerpt":" BOJ 14725 개미굴    string을 key로 하는 Trie를 STL로 구성하기 STL map은 key가 정렬된 순서로 추가된다. -&gt; 단어 알파벳 오름차순      접근하기    map&lt;string, Node&gt; Node에 재귀적인 형태로 추가 단어가 추가되는 Trie라고 생각하기      코드 - STL map 이용    #include &lt;bits/stdc++.h&gt; using namespace std;  typedef struct Node{         map&lt;string, Node&gt; mp; } Node;  int T, N; Node root;  void dfs(Node&amp; cur, int idx) {         for(auto&amp; o : cur.mp) {  // map - key&#47196; &#51221;&#47148;&#46104;&#50612; &#51080;&#51020;                 for(int i=0;i&lt;idx;i++) {                         printf(\"--\");                 }                 cout &lt;&lt; o.first &lt;&lt; '\\n';                 dfs(o.second, idx+1);         } }  void insert(Node&amp; cur, int idx, vector&lt;string&gt;&amp; a, int size) {         if (idx == size) return;         if (cur.mp.count(a[idx]) == 0) {                 cur.mp[a[idx]] = Node();   // &#49373;&#49457;&#51088;&#47196; &#44061;&#52404; &#52628;&#44032;         }         insert(cur.mp[a[idx]], idx+1, a, size); }  int main(int argc, char* argv[]) {         scanf(\"%d\", &amp;T);         for(int i=0;i&lt;T;i++) {                 scanf(\"%d\", &amp;N);                 vector&lt;string&gt; a(N);                 for(int j=0;j&lt;N;j++) {                         cin &gt;&gt; a[j];                 }                 insert(root, 0, a, N);         }         dfs(root, 0);         return 0; }       코드 - LCRS tree 구조 이용     문제 링크    https://www.acmicpc.net/problem/14725      풀이 참고    https://justicehui.github.io/ps/2019/08/27/BOJ14725/    ","categories": [],
        "tags": ["dfs","Trie"],
        "url": "/boj-14725/",
        "teaser": null
      },{
        "title": "Bit operation 정리",
        "excerpt":" Bit 연산 예제 정리     K번째 bit set여부 확인    #include &lt;bits/stdc++.h&gt;  int main(int argc, char* argv[]) {         unsigned int val = 9;   // 1001         printf(\"%d\\n\", (val &amp; (1&lt;&lt;0)) != 0);         printf(\"%d\\n\", (val &amp; (1&lt;&lt;1)) != 0);         printf(\"%d\\n\", (val &amp; (1&lt;&lt;2)) != 0);         printf(\"%d\\n\", (val &amp; (1&lt;&lt;3)) != 0); // == 1&#51060; &#50500;&#45784;. &#51452;&#51032;         return 0; }       최하위 비트 찾기    #include &lt;bits/stdc++.h&gt;  int main(int argc, char* argv[]) {         unsigned int val = 9;   // 1001         printf(\"%d\\n\", val&amp;-val);         return 0; }       최하위 비트 지우기    #include &lt;bits/stdc++.h&gt;  int main(int argc, char* argv[]) {         unsigned int val = 9;   // 1001         val = val &amp; (val-1);         //   1010         // &amp; 1001         //   1000         printf(\"%d\\n\", val);         return 0; }       모든 부분집합 순회    #include &lt;bits/stdc++.h&gt;  int main(int argc, char* argv[]) {         int val = 15;         for(int a=val;a;a=a&amp;(a-1))         {                 printf(\"%d\\n\", a);         }         return 0; }      ","categories": [],
        "tags": ["bit연산"],
        "url": "/bit-operations/",
        "teaser": null
      },{
        "title": "BOJ 11437 LCA",
        "excerpt":" BOJ 11437 LCA    트리에 두 점이 주어질 때 가장 가까운 부모의 번호를 출력하기      접근하기    1. 인접 리스트로 Graph 형태로 받음. N-1번 받는다.  2. dfs로 1번(root)로부터의 거리만큼을 depth 배열에 저장하고, parent의 번호도 저장한다.       코드 - dfs로 풀이 (O(N) - 1128 m/s)    // 1128 m/s #include &lt;bits/stdc++.h&gt; using namespace std;  int parent[50010]; int depth[50010]; int N; int M;  vector&lt;int&gt; G[50010];  void dfs(int idx, int k) {     depth[idx] = k;     for(auto&amp;next :G[idx]) {         if (depth[next] == 0) {             parent[next] = idx;              dfs(next, k+1);         }     } }  int LCA(int p1, int p2) {     if (p1 == p2) return p1;       if (depth[p1] &gt; depth[p2]) {         return LCA(parent[p1], p2);      } else if (depth[p1] &lt; depth[p2]) {         return LCA(p1, parent[p2]);      } else if(depth[p1] == depth[p2]) {         return LCA(parent[p1], parent[p2]);     }     return p1; }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int p1, p2;     for(int i=0;i&lt;N-1;i++) {         scanf(\"%d %d\", &amp;p1, &amp;p2);         G[p1].push_back(p2);         G[p2].push_back(p1);     }      parent[1] = 1;      dfs(1, 1);      scanf(\"%d\", &amp;M);     for(int i=0;i&lt;M;i++) {         scanf(\"%d %d\", &amp;p1, &amp;p2);          int ret = LCA(p1, p2);         printf(\"%d\\n\", ret);     }     return 0; }       dfs로 풀이 - LCA를 iterative로 1128 m/s    int LCA(int p1, int p2) {     while(p1 != p2) {         if (depth[p1] &gt; depth[p2]) {             p1 = parent[p1];         } else if (depth[p1] &lt; depth[p2]) {             p2 = parent[p2];         } else if(depth[p1] == depth[p2]) {             p1 = parent[p1];             p2 = parent[p2];         }     }     return p1; }       sparse table 기법으로 풀이 (32 m/s)    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; vector&lt;int&gt; G[100010];  #define LOG_SIZE 17  int depth[100010]; int dp[LOG_SIZE+1][100010];  void dfs(int idx, int dep) {         depth[idx] = dep;         for(auto&amp; next:G[idx]) {                 if (depth[next] == 0) {                         dp[0][next] = idx;                         dfs(next, dep + 1);                 }         } }  int LCA(int p1, int p2) {         if (depth[p1] &lt; depth[p2]) {                 swap(p1, p2);         }         int diff = depth[p1] - depth[p2];          // &#45458;&#51060;&#47484; &#47582;&#52644;         for(int i=LOG_SIZE;i&gt;=0;i--) {                 if (diff &amp; (1 &lt;&lt; i)) {                         p1 = dp[i][p1];                 }         }          if (p1 != p2) {                 for(int j=LOG_SIZE;j&gt;=0;j--) {                         if (dp[j][p1] != dp[j][p2]) {                                 p1 = dp[j][p1];                                 p2 = dp[j][p2];                                 //break;                         }                 }                 p1 = dp[0][p1];                 //p2 = dp[0][p2];         }         return p1; }  int main(int argc, char* argv[]) {         scanf(\"%d\", &amp;N);         for(int i=0;i&lt;N-1;i++) {                 int p1, p2;                 scanf(\"%d %d\", &amp;p1, &amp;p2);                 G[p1].push_back(p2);                 G[p2].push_back(p1);         }          dfs(1, 1);          for(int i=1;i&lt;=LOG_SIZE;i++) {                 for(int j=1;j&lt;=N;j++) {                         int tmp = dp[i-1][j];                         dp[i][j] = dp[i-1][tmp];                 }         }          int M;         scanf(\"%d\", &amp;M);         for(int i=0;i&lt;M;i++) {                 int p1, p2;                 scanf(\"%d %d\", &amp;p1, &amp;p2);                  int ret = LCA(p1, p2);                 printf(\"%d\\n\", ret);         }         return 0; }      TODO O(1) LCA 적용해보기    - 바로가기      문제 링크    https://www.acmicpc.net/problem/11437    ","categories": [],
        "tags": ["dfs","LCA"],
        "url": "/boj-11437/",
        "teaser": null
      },{
        "title": "BOJ 11438 LCA 2",
        "excerpt":" BOJ 11438 LCA 2    트리에 두 점이 주어질 때 가장 가까운 부모의 번호를 출력하기 N이 10만, O(N)으로 풀면 시간 초과가 난다.      접근하기    1. 인접 리스트로 Graph 형태로 받음. N-1번 받는다.  2. dfs로 1번(root)로부터의 거리만큼을 depth 배열에 저장하고, parent의 번호도 저장한다.    depth를 저장하고, dp[0][next]에 자신의 index를 저장한다.  3. sparse table을 구성하는 dp 점화식을 적용한다.  4. query에서 받은 두 점간의 depth를 비교한다.    - 긴 쪽을 위로 올린다. 2^k 단위로 올릴 수 있음  5. 높이가 같아졌으면, dp 테이블을 이용해서 2^k단위로 올릴 수 있음    - 같으면,       sparse table 기법으로 풀이    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; vector&lt;int&gt; G[100010];  #define LOG_SIZE 17  int depth[100010]; int dp[LOG_SIZE+1][100010];  void dfs(int idx, int dep) {         depth[idx] = dep;         for(auto&amp; next:G[idx]) {                 if (depth[next] == 0) {                         dp[0][next] = idx;                         dfs(next, dep + 1);                 }         } }  int LCA(int p1, int p2) {         if (depth[p1] &lt; depth[p2]) {                 swap(p1, p2);         }         int diff = depth[p1] - depth[p2];          // &#45458;&#51060;&#47484; &#47582;&#52644;         for(int i=LOG_SIZE;i&gt;=0;i--) {                 if (diff &amp; (1 &lt;&lt; i)) {                         p1 = dp[i][p1];                 }         }          if (p1 != p2) {                 for(int j=LOG_SIZE;j&gt;=0;j--) {                         if (dp[j][p1] != dp[j][p2]) {                                 p1 = dp[j][p1];                                 p2 = dp[j][p2];                                 //break;                         }                 }                 p1 = dp[0][p1];                 //p2 = dp[0][p2];         }         return p1; }  int main(int argc, char* argv[]) {         scanf(\"%d\", &amp;N);         for(int i=0;i&lt;N-1;i++) {                 int p1, p2;                 scanf(\"%d %d\", &amp;p1, &amp;p2);                 G[p1].push_back(p2);                 G[p2].push_back(p1);         }          dfs(1, 1);          for(int i=1;i&lt;=LOG_SIZE;i++) {                 for(int j=1;j&lt;=N;j++) {                         int tmp = dp[i-1][j];                         dp[i][j] = dp[i-1][tmp];                 }         }          int M;         scanf(\"%d\", &amp;M);         for(int i=0;i&lt;M;i++) {                 int p1, p2;                 scanf(\"%d %d\", &amp;p1, &amp;p2);                  int ret = LCA(p1, p2);                 printf(\"%d\\n\", ret);         }         return 0; }      TODO O(1) LCA 적용해보기    - 바로가기      문제 링크    https://www.acmicpc.net/problem/11438    ","categories": [],
        "tags": ["dfs LCA"],
        "url": "/boj-11438/",
        "teaser": null
      },{
        "title": "BOJ 1761 정점들의 거리",
        "excerpt":" BOJ 1761 정점들의 거리     접근하기    Sparse table을 구성해서, LCA를 구하는 문제    Root에서 노드1사이의 거리 = a Root에서 노드2사이의 거리 = b Root에서 노드 1,2의 LCA사이의 거리 = lca  =&gt; Tree에서 두 노드 사이의 거리 = a + b - 2 x lca      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define LOG_SIZE 16  int N;  int dp[LOG_SIZE+1][40040];  int visited[40040]; int dist[40040]; int depth[40040];  typedef struct Node {         int num;         int cost; } Node;  vector&lt;Node&gt; G[40040]; int M;  void dfs(int idx, int d, int w) {         visited[idx] = 1;         depth[idx] = d;         dist[idx] = w;          for(auto&amp; o:G[idx]) {                 int next = o.num;                 int cost = o.cost;                 if (!visited[next]) {                         dp[0][next] = idx;                         dfs(next, d+1, w+cost);                 }         }  }  int LCA(int p1, int p2) {         if (depth[p1] &lt; depth[p2]) {                 swap(p1, p2);         }         int diff = depth[p1] - depth[p2];          for(int i=LOG_SIZE;i&gt;=0;--i) {                 if (diff &amp; (1 &lt;&lt; i)) {                         p1 = dp[i][p1];                 }         }          if (p1 != p2) {                 for(int i=LOG_SIZE;i&gt;=0;--i) {                         if (dp[i][p1] != dp[i][p2]) {                                 p1 = dp[i][p1];                                 p2 = dp[i][p2];                         }                 }                                p1 = dp[0][p1];         }         return p1; }  int main(int argc, char* argv[]) {         freopen(\"input.txt\", \"r\", stdin);         scanf(\"%d\", &amp;N);         int p1, p2, w;         for(int i=0;i&lt;N-1;i++) {                 scanf(\"%d %d %d\", &amp;p1, &amp;p2, &amp;w);                 G[p1].push_back({p2, w});                 G[p2].push_back({p1, w});         }          dfs(1, 0, 0); // dp[0][i] &#52292;&#50880;          // sparse table &#52292;&#50880;         for(int i=1;i&lt;=LOG_SIZE;i++) {                 for(int j=1;j&lt;=N;j++) {                         int tmp = dp[i-1][j];                         dp[i][j] = dp[i-1][tmp];                 }                        }          scanf(\"%d\", &amp;M);         for(int i=0;i&lt;M;i++) {                 scanf(\"%d %d\", &amp;p1, &amp;p2);                 int lca = LCA(p1, p2);                 printf(\"%d\\n\", dist[p1]+dist[p2] - 2*dist[lca]);         }         return 0; }       문제 링크    https://www.acmicpc.net/problem/1761     풀이/해설참고    https://justicehui.github.io/ps/2019/04/22/BOJ1761/    ","categories": [],
        "tags": ["SparseTable"],
        "url": "/boj-17435/",
        "teaser": null
      },{
        "title": "abc234 C - Happy New Year!",
        "excerpt":" C - Happy New Year!     접근하기    3 -&gt; 11 로 생각가능  11 -&gt; 1011 로 생각 가능  2진수로 변환하여, 1을 2로 출력, 0을 0으로 string을 만들어 뒤집기      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  long long int N;  int main(int argc, char* argv[]) {     string ans;     scanf(\"%lld\", &amp;N);      while(N) {         int nam = N %2;          if (nam == 0) {             ans.push_back('0');         } else {             ans.push_back('2');         }         N = N / 2;     }     reverse(ans.begin(), ans.end());     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://atcoder.jp/contests/abc234/tasks/abc234_c    ","categories": [],
        "tags": ["AtCoder","수학"],
        "url": "/abc234-c/",
        "teaser": null
      },{
        "title": "abc234 D - Prefix K-th Max",
        "excerpt":" D - Prefix K-th Max     접근하기    permutation에서 K개를 나열하고, K번째를 출력 -&gt; 이때는 min이 됨    11 5 3 7 2 5 11 / 6 1 9 8 10 4    - 2 가 최소 3 7 2 5 11 6 / 1 9 8 10 4    - 6이 들어오면, 3이 최소, 2가 밀려남 3 7 2 5 11 6 1 / 9 8 10 4    - 1이 들어오면, 3이 최소  3 7 2 5 11 6 1 9 / 8 10 4 3 7 2 5 11 6 1 9 8 / 10 4 3 7 2 5 11 6 1 9 8 10 / 4  k번째 수 &lt; 큰값 -&gt; k번째수가 바뀜  k번째수 &gt; 작은값 -&gt; 안 바뀜      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, K; int a[500050];  priority_queue &lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;K);      int num;     for(int i=0;i&lt;K;i++) {         scanf(\"%d\", &amp;num);         pq.push(num);     }     int first = pq.top();     printf(\"%d\\n\", first);     for(int i=0;i&lt;N-K;i++) {         scanf(\"%d\", &amp;num);         int cur = pq.top();          if (cur &lt; num) {             pq.pop();             pq.push(num);         }         int tmp = pq.top();         printf(\"%d\\n\", tmp);     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc234/tasks/abc234_d    ","categories": [],
        "tags": ["AtCoder","수학"],
        "url": "/abc234-d/",
        "teaser": null
      },{
        "title": "abc234 E - Arithmetic Number",
        "excerpt":" E - Arithmetic Number     접근하기    주어진 조건을 이용해서 sort된 수열을 만든다. - STL set 이용  set에 넣으면, 정렬된 순서로 들어감  Find the smallest arithmetic number not less than X -&gt; lower_bound 이용  set에서 lower_bound 함수를 제공       코드    #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll;  ll X; set&lt;ll&gt; sp; int main(int argc, char* argv[]) {     scanf(\"%lld\", &amp;X);          for(int s=1;s&lt;=9;s++) {         sp.insert(s);          for(int d=-9;d&lt;=9;d++) {             ll val = s;             int num = s;             while(val&lt;1e18) {                 num += d;                 if (num &lt; 0 || num &gt; 9) break;                 val = val * 10 + num;                  sp.insert(val);             }          }     }     printf(\"%lld\\n\", (*sp.lower_bound(X)));     return 0; }       문제 링크    https://atcoder.jp/contests/abc234/tasks/abc234_e    ","categories": [],
        "tags": ["AtCoder","수학"],
        "url": "/abc234-e-upsolving/",
        "teaser": null
      },{
        "title": "Binomial Coefficient(이항계수)란?",
        "excerpt":" Binomial Coefficient(이항계수)란?    집합에서 원하는 개수만큼 순서없이 뽑는 조합의 가짓수 이항 : 하나의 항목에 대해 뽑거나 안뽑거나  원소의 개수 n에서 k개의 항목을 뽑을 때      n개중 k를 선택 가짓수 = n개중 선택안될 (n-k) 가짓수    n=5, k=2일때 10가지가 나옴    1,2 1,3 1,4 1,5  2,3 2,4 2,5  3,4 3,5  4,5    n=5, k=3일 때 10가지    1,2,3 1,2,4 1,2,5  1,3,4 1,3,5  1,4,5  2,3,4 2,3,5  2,4,5  3,4,5       n에서 0가지 고르기 = n에서 n가지 고르기 = 1    전체 집합에서 아무것도 고르지 않는 가짓수 = 1  전체 집합에서 모두를 선택하는 가짓수 = 1      dp 점화식 표현    1,2,3,4 중에서 3가지를 고른다고 하면,  1을 골랐으면, 2,3,4중에 2개를 골라야 한다.  1을 안골랐으면, 2,3,4중에 3개를 골라야 한다.  -&gt; dp[4][3] = dp[3][2] + dp[3][3]  -&gt; dp[0][0] = 1;   // n개에서 0가지 고르는 경우의 수 1 -&gt; dp[N][N] = 1; -&gt; dp[i][i] = 1;   // n개에서 n가지 고르는 경우의 수 1 -&gt; dp[i][j] = dp[i-1][j-1] + dp[i-1][j-1]      0 1 2 3 4  (k) 0 1 1 1 1 2 1 2 1  3 1 3 3 1 4 1 4 6 4      참고 링크    https://haamjamie.tistory.com/6 https://shoark7.github.io/programming/algorithm/3-ways-to-get-binomial-coefficients    ","categories": [],
        "tags": ["조합론"],
        "url": "/binomial-coefficient/",
        "teaser": null
      },{
        "title": "BOJ 11050 이항계수 1",
        "excerpt":" BOJ 11050 이항계수 1          접근하기    이항계수의 성질 중 점화식 이용  4C3은?  1고른 상태에서 남은 3개중 2개 고르기 = 3C2 1 2 3 4       1안고른상태에서 남은 3개중  3개 고르기 = 3C3 1 2 3 4  dp[i][j] = dp[i-1][j-1] + dp[i-1][j]       코드    #include &lt;bits/stdc++.h&gt; using namespace std; int N, K;  int dp[12][12];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;K);     dp[0][0] = 1;      for(int i=0;i&lt;=N;i++) {         dp[i][0] = 1;     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=min(i, K);j++) {             dp[i][j] = dp[i-1][j-1] +  dp[i-1][j];         }     }      printf(\"%d\\n\", dp[N][K]);     return 0; }       문제 링크    https://www.acmicpc.net/problem/11050    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-11050/",
        "teaser": null
      },{
        "title": "BOJ 11051 이항계수 2",
        "excerpt":" BOJ 11051 이항계수 2    N이 1000으로 크고, Mod연산 추가      접근하기    이항계수의 성질 중 점화식 이용  4C3은?  1고른 상태에서 남은 3개중 2개 고르기 = 3C2 1 2 3 4       1안고른상태에서 남은 3개중  3개 고르기 = 3C3 1 2 3 4  dp[i][j] = dp[i-1][j-1] + dp[i-1][j]       코드    #include &lt;bits/stdc++.h&gt; using namespace std; int N, K;  int dp[1001][1001]; #define MOD 10007 int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d %d\", &amp;N, &amp;K);     dp[0][0] = 1;      for(int i=0;i&lt;=N;i++) {         dp[i][0] = 1;     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=min(i, K);j++) {             dp[i][j] = dp[i-1][j-1]%MOD +  dp[i-1][j]%MOD;             dp[i][j] %= MOD;         }     }      printf(\"%d\\n\", dp[N][K]);     return 0; }       문제 링크    https://www.acmicpc.net/problem/11051    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-11051/",
        "teaser": null
      },{
        "title": "BOJ 13977 이항계수와 쿼리",
        "excerpt":" BOJ 13977 이항계수와 쿼리    pow(base, cnt)를 구하기      접근하기    factorial을 400만 크기로 미리 계산한다. 페르마의 소정리를 이용해 이항계수 구한다.      코드 - 페르마의 소정리, 직접 계산 (144 m/s)    #include &lt;bits/stdc++.h&gt;  #define MOD 1000000007 typedef long long ll;  int M, N, K;  ll fact[4000040];  ll pow(ll base, ll cnt) {         if (cnt == 0) return 1;         ll tmp = pow(base, cnt/2) %MOD;          if (cnt%2) {                 return ((tmp * tmp) % MOD * base% MOD)% MOD;         } else {                 return (tmp * tmp) % MOD;         } }  int main(int argc, char* argv[]) {         fact[0] = 1;         for(int i=1;i&lt;=4000000;i++) {                 fact[i] = fact[i-1]%MOD * i;                 fact[i] %= MOD;         }          scanf(\"%d\", &amp;M);         for(int i=0;i&lt;M;i++) {                 scanf(\"%d %d\", &amp;N, &amp;K);                 ll ans = (fact[N] * pow((fact[N-K]*fact[K])%MOD, MOD-2))%MOD;                 printf(\"%lld\\n\", ans%MOD);         } }        코드 - inverse 미리 구해서 가져옴 (163 m/s)    역원을 400만부터 거슬러서 미리 table에 넣어둘 수 있음    #include &lt;bits/stdc++.h&gt;  #define MOD 1000000007 typedef long long ll;  int M, N, K;  ll fact[4000040]; ll inv[4000040];  ll pow(ll base, ll cnt) {         if (cnt == 0) return 1;         ll tmp = pow(base, cnt/2) %MOD;          if (cnt%2) {                 return ((tmp * tmp) % MOD * base% MOD)% MOD;         } else {                 return (tmp * tmp) % MOD;         } }  int main(int argc, char* argv[]) {         freopen(\"input.txt\", \"r\", stdin);         fact[0] = 1;          for(int i=1;i&lt;=4000000;i++) {                 fact[i] = fact[i-1]%MOD * i;                 fact[i] %= MOD;         }         inv[4000000] = pow(fact[4000000], MOD-2) %MOD;         for(int i=4000000-1;i&gt;=0;i--) {                 inv[i] = (inv[i+1] * (i+1))%MOD;         }         scanf(\"%d\", &amp;M);         for(int i=0;i&lt;M;i++) {                 scanf(\"%d %d\", &amp;N, &amp;K);                 ll ans = fact[N] % MOD;                 ans = (ans * inv[K] % MOD) % MOD;                 ans = (ans * inv[N-K] % MOD) % MOD;                  printf(\"%lld\\n\", ans);         } }       문제 링크    https://www.acmicpc.net/problem/13977    ","categories": [],
        "tags": ["분할정복","조합론"],
        "url": "/boj-13977/",
        "teaser": null
      },{
        "title": "BOJ 1526 가장 큰 금민수",
        "excerpt":" BOJ 1526 금민수     접근하기    100에서 역순으로 줄이면서, 7이나 4로 남는 경우만 체크 dfs로 N보다 가장 작은 수로 이동해보기      코드 - 100에서 역순으로    #include &lt;bits/stdc++.h&gt;  int N; int main(int argc,char* argv[]) {     scanf(\"%d\", &amp;N);      for(int i=N;i&gt;=4;--i) {          int num = i;         int bok = 1;         while(num) {             int tmp = num % 10;             if (tmp != 4 &amp;&amp; tmp != 7) {                 bok = 0;                 break;             }             num = num / 10;         }         if (bok) {             printf(\"%d\\n\", i);             break;         }     }     return 0; }      코드 - dfs이용    #include &lt;bits/stdc++.h&gt;  int N; int ans = 0;  void dfs(int num) {     if (num &gt; N) return;     if (N &gt;= num) {         if (ans &lt; num) {             ans = num;         }         }     dfs(num * 10 + 4);     dfs(num * 10 + 7); }  int main(int argc,char* argv[]) {     ans = 0;     scanf(\"%d\", &amp;N);      dfs(0);     printf(\"%d\\n\", ans);      return 0; }       문제 링크    https://www.acmicpc.net/problem/1526    ","categories": [],
        "tags": ["구현"],
        "url": "/boj-1526/",
        "teaser": null
      },{
        "title": "BOJ 1629 곱셈",
        "excerpt":" BOJ 1629 곱셈    pow(base, cnt)를 구하기      접근하기    분할정복으로, 곱셈을 n번하지 않고 구할 수 있음    2^9 = 2*2*2*2* 2*2*2*2 *2      = 2^4 * 2^4 * 2  2^4 = 2^2 * 2^2     코드    #include &lt;bits/stdc++.h&gt;  typedef long long ll;  ll A, B, C;  ll pow(ll base, ll cnt) {     if (cnt == 0) return 1;      ll tmp = pow(base, cnt/2)%C;     if (cnt %2 == 1) {         return (tmp*tmp)%C * base%C;     } else {         return (tmp*tmp)%C;     } }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%lld %lld %lld\", &amp;A, &amp;B, &amp;C);     printf(\"%lld\\n\", pow(A, B) % C);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1629    ","categories": [],
        "tags": ["분할정복"],
        "url": "/boj-1629/",
        "teaser": null
      },{
        "title": "BOJ 11403 이항계수 3",
        "excerpt":" BOJ 11401 이항계수 3    N이 400만에서 이항계수 구하기 dp를 쓸 수 없음      접근하기    페르마의 소정리 이용      코드    #include &lt;bits/stdc++.h&gt;  #define MOD 1000000007 typedef long long ll;   ll factorial(ll num) {         long long ans = 1;         for(int i=2;i&lt;=num;i++) {                 ans = (ans * i) % MOD;         }         return ans; }  // &#48516;&#54624;&#51221;&#48373; recursive&#47196; pow&#44396;&#54616;&#44592; ll pow(ll base, ll m) {         if (m == 0 ) return 1;         if (m == 1) return base % MOD;          ll half = pow(base, m/2) % MOD;          if (m %2 != 0) {                 return (half * half) % MOD * base % MOD;         } else {                 return (half * half) % MOD;         } }  ll N, K;  int main(int argc, char* argv[]) {         scanf(\"%lld %lld\", &amp;N, &amp;K);         ll ans = factorial(N)%MOD * pow(factorial(K)%MOD * factorial(N-K)%MOD, MOD-2)%MOD;         printf(\"%lld\\n\", ans);         return 0; }       문제 링크    https://www.acmicpc.net/problem/11401      참고링크 (수학적 설명)    https://st-lab.tistory.com/241    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-11401/",
        "teaser": null
      },{
        "title": "dvipng로 org-mode web에서 수학식 출력",
        "excerpt":" dvipng로 latex 수학식 출력    dvipng는 apt-get install dvipng로 설치 html로 생성하면, latex 부분이 png로 만들어져서 나온다.      TODO 출력위치 변경하고 맞춰줘야 함    2022-01-09 publish      latex 예제 1    #+BEGIN_EXAMPLE      Dollars    hello       Parens    hello       Double dollars    hello       Brackets    hello  #+END_EXAMPLE     ","categories": [],
        "tags": ["orgmode"],
        "url": "/orgmode-divpng/",
        "teaser": null
      },{
        "title": "BOJ 2075 N번째 큰수",
        "excerpt":" BOJ 2075 N번째 큰수    qsort로 풀어도 큰 시간차 없이 풀림 (1500 x 1500 = 2250000)      접근하기    min heap에  push하고, heap의 크기가 N보다 커지면, 맨 위의 값을 pop  5 12 7 9 15 5 13 8 11 19 6 21 10 26 31 16 48 14 28 35 25 52 20 32 41 49  12 12 7 12 9 7 15 12 9 7 15 12 9 7 5 15 13 12 9 7 (5)     -&gt; 5를 버리면 7이 5번째로 큰수 ... 반복      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; priority_queue &lt; int &gt; pq;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     int val;     for(int i=0;i&lt;N*N;i++) {         scanf(\"%d\", &amp;val);         pq.push(val);         if ((int)pq.size() &gt; N) {             pq.pop();            }     }     printf(\"%d\\n\", pq.top());      return 0; }       문제 링크    https://www.acmicpc.net/problem/2075    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-2075/",
        "teaser": null
      },{
        "title": "IPTime A3000UA-2 Ubuntu 16.04 드라이버 설치",
        "excerpt":" IPTime A3000UA-2 Ubuntu 16.04 드라이버 설치    desktop 컴퓨터에 무선랜 driver가 안깔려 있음. 무선랜카드를 구입하면서, 리눅스용으로 드라이버 설치 필요 다행히 한글로 된 가이드가 구글링 결과에 많이 나옴. 그중 설명이 잘 된 가이드 이용함      순서     ~/work$ git clone https://github.com/cilynx/rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959     .... (1)  'rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959'에 복제합니다... remote: Enumerating objects: 752, done. remote: Counting objects: 100% (12/12), done. remote: Compressing objects: 100% (12/12), done. remote: Total 752 (delta 3), reused 6 (delta 0), pack-reused 740 오브젝트를 받는 중: 100% (752/752), 3.63 MiB | 0 bytes/s, 완료. 델타를 알아내는 중: 100% (254/254), 완료. 연결을 확인하는 중입니다... 완료. ~/work$ cd  rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959 ~/work/rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959$ ls Kconfig   README.md  core       hal          include  platform     runwpa Makefile  clean      dkms.conf  ifcfg-wlan0  os_dep   rtl8822b.mk  wlan0dhcp  ~/work/rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959$ sudo apt install dkms                 ..... (2)  containerd.io docker-ce-cli libbonoboui2-0 libbonoboui2-common libgnomecanvas2-0 libgnomecanvas2-common libgnomeui-0 libgnomeui-common libjansson4 Use 'sudo apt autoremove' to remove them. dkms 0개 업그레이드, 1개 새로 설치, 0개 제거 및 143개 업그레이드 안 함. 66.4 k바이트 아카이브를 받아야 합니다. 이 작업 후 267 k바이트의 디스크 공간을 더 사용하게 됩니다. 받기:1 http://kr.archive.ubuntu.com/ubuntu xenial-updates/main amd64 dkms all 2.2.0.3-2ubuntu11.8 [66.4 kB] 내려받기 66.4 k바이트, 소요시간 1초 (56.1 k바이트/초) Selecting previously unselected package dkms. (데이터베이스 읽는중 ...현재 530797개의 파일과 디렉터리가 설치되어 있습니다.) Preparing to unpack .../dkms_2.2.0.3-2ubuntu11.8_all.deb ... Unpacking dkms (2.2.0.3-2ubuntu11.8) ... Processing triggers for man-db (2.7.5-1) ... dkms (2.2.0.3-2ubuntu11.8) 설정하는 중입니다 ... ~/work/rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959$ cd .. ~/work$ sudo dkms add ./rtl88x2BU_WiFi_linux_v5.3.1_27678.20180430_COEX20180427-5959  Creating symlink /var/lib/dkms/rtl88x2bu/5.3.1/source -&gt; /usr/src/rtl88x2bu-5.3.1  DKMS: add completed. ~/work$ sudo dkms install -m rtl88x2bu -v 5.3.1                                                            ..... (3)  Kernel preparation unnecessary for this kernel.  Skipping...  Building module: cleaning build area.... make KERNELRELEASE=4.4.0-210-generic KVER=4.4.0-210-generic src=/usr/src/rtl88x2bu-5.3.1.................................. cleaning build area....  DKMS: build completed.  88x2bu.ko: Running module version sanity check. - Original module - No original module exists within this kernel - Installation - Installing to /lib/modules/4.4.0-210-generic/updates/dkms/  depmod......  DKMS: install completed. ~/work$ sudo modprobe 88x2bu                                                                               ..... (4) ~/work$ lsmod | grep 88x2bu                                                                                ..... (5) 88x2bu               2605056  0 cfg80211              565248  1 88x2bu ~/work$        랜카드 잡기    https://linsoo.pe.kr/archives/15553 이대로 하기 ESSID와 SSID가 같았음    $ cat /etc/network/interfaces source /etc/network/interfaces.d/*  auto lo iface lo inet loopback  auto WIRELESS_LAN_NAME iface WIRELESS_LAN_NAME inet dhcp wpa-ssid KT_xxxxxxx wpa-key_mgmt WPA-PSK KT_xxxxxx wpa-psk 암호   reboot하면 무선랜이 잡힘     참고 링크    device driver 설치 : simryang.tistory.com    ","categories": [],
        "tags": ["LinuxDeviceDriver"],
        "url": "/iptime-a3000a2-ubuntu16.04/",
        "teaser": null
      },{
        "title": "org mode와 deft를 같이 쓰기",
        "excerpt":" Deft    https://github.com/jrblevin/deft plain text note를 관리하는 시스템 F8로 orgmode 파일을 저장하는 위치에 연결했음      사용법    파일이름을 치면 검색이 됨 새로운 파일 이름이면 만들어짐             C-c C-d 선택 파일 지우기    C-c C-r 파일 이름 변경    C-c C-q 종료        .emacs 지정    ; Deft (global-set-key [f8] 'deft) (setq deft-extensions '(\"org\")) ;(setq deft-directory \"~/Dropbox/orgzly\") (setq deft-directory \"/home/mjpark/work/github/zune2.github.com/_org_posts/_posts\") (setq deft-recursive t)     ","categories": [],
        "tags": ["deft"],
        "url": "/orgode-deft/",
        "teaser": null
      },{
        "title": "BOJ 2979 트럭 주차",
        "excerpt":" BOJ 2979 트럭주차    시작시간 끝 시간을 주고 겹치는 구간을 세기 1대 겹침, 2대 겹침, 3대 겹침      접근하기     코드    #include &lt;bits/stdc++.h&gt;  int c[4];  int a[101];  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;c[0], &amp;c[1], &amp;c[2]);     int s, e;     c[1] *= 2;     c[2] *= 3;     for(int i=0;i&lt;3;i++) {         scanf(\"%d %d\", &amp;s, &amp;e);          for(int i=s;i&lt;e;i++) {             a[i] += 1;         }     }     int sum = 0;     for(int i=0;i&lt;100;i++) {         if (a[i]) sum += c[a[i]-1];          }     printf(\"%d\\n\", sum);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2979    ","categories": [],
        "tags": ["구현"],
        "url": "/boj-2979/",
        "teaser": null
      },{
        "title": "BOJ 5639 이진 검색 트리",
        "excerpt":" BOJ 5639 이진 검색 트리    이진 검색 트리의 규칙에 맞게 전위순회가 주어질 때, 후위 순회하기      접근하기    전위 순회로 tree구성 후위순회 찍기     코드    #include &lt;bits/stdc++.h&gt;  typedef struct Node {     int num;     Node* left;     Node* right; } Node;  Node pool[10010]; int idx;  Node* New() {     return &amp;pool[idx++]; }  void print(Node* ptr) {     if (ptr) {         print(ptr-&gt;left);         print(ptr-&gt;right);         printf(\"%d\\n\", ptr-&gt;num);     } }  Node* walk(Node* ptr, int num) {     if (ptr == NULL) {         ptr = New();         ptr-&gt;num = num;         ptr-&gt;left = NULL;         ptr-&gt;right = NULL;     }     else if (num &lt; ptr-&gt;num) {         ptr-&gt;left = walk(ptr-&gt;left, num);         } else {         ptr-&gt;right = walk(ptr-&gt;right, num);         }      return ptr; }  int main(int argc, char* argv[]) {     idx = 0;      int val;     Node* root = NULL;     while(scanf(\"%d\", &amp;val) != EOF) {         root = walk(root, val);          }     print(root);     return 0; }        문제 링크    https://www.acmicpc.net/problem/5639    ","categories": [],
        "tags": ["Tree"],
        "url": "/boj-5639/",
        "teaser": null
      },{
        "title": "BOJ 9934 완전 이진트리",
        "excerpt":" BOJ 9934 완전이진트리    중위순회를 떠올리기     접근하기    가운데 숫자가 root 반씩 나누면서, 좌우를 타고 내려감 -&gt; 분할정복     코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; int a[2000];  vector&lt;int&gt; G[10];  void f(int depth, int s, int e) {     if ( s &lt; e) {         int m = (s+e)/2;         G[depth].push_back(a[m]);         f(depth+1, s, m);         f(depth+1, m+1, e);     } }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     int len = pow(2, N) - 1;     for(int i=0;i&lt;len;i++) {         scanf(\"%d\", &amp;a[i]);     }      f(0, 0, len);      for(int i=0;i&lt;N;i++) {         for(auto&amp; o:G[i]) {             printf(\"%d \", o);         }         printf(\"\\n\");     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/9934    ","categories": [],
        "tags": ["Tree"],
        "url": "/boj-9934/",
        "teaser": null
      },{
        "title": "abc235 C - The Kth Time Query",
        "excerpt":" C - The Kth Time Query     접근하기    - map 배열을 만들어서 x값별로 추가 - kth가 map[x].size보다 작으면, 출력, 없으면 -1       코드    #include &lt;bits/stdc++.h&gt; using namespace std; int N, Q;  int a[200020]; int x, kth;  map&lt;int, vector&lt;int&gt;&gt; mp;  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;Q);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);         mp[a[i]].push_back(i);     }      for(int i=0;i&lt;Q;i++) {         scanf(\"%d %d\", &amp;x, &amp;kth);          int size = mp[x].size();         if (kth &lt;= size) {             printf(\"%d\\n\", mp[x][kth-1]);         } else {             printf(\"-1\\n\");         }     }     return 0; }       문제 링크    https://atcoder.jp/contests/abc235/tasks/abc235_c    ","categories": [],
        "tags": ["AtCoder STL"],
        "url": "/abc235-c-upsolving/",
        "teaser": null
      },{
        "title": "abc235 D - Multiply and Rotate",
        "excerpt":" D - Multiply and Rotate     접근하기    - BFS로 weight가 같을 때, 최단거리를 구할 수 있음 - but, 숫자를 뒤집는 조건이 추가됨   - 숫자가 작아질 가능성이 있음 -&gt; 무한루프?  - 이 조건은 생각하기 어려웠음.   - 뒤집어도 원래 값보다 커져야 한다.     - 2자리수 이상이어야 한다.     - num%10 == 0인 경우, 10, 100, 1000 등은 뒤집으면 작아지므로 제외  - visit 배열로 한번 접근한 값은 제외  - BFS      코드 84 m/s    #include &lt;bits/stdc++.h&gt; using namespace std;  int a; long long int N; typedef struct Node {     long long num;     int dist; } Node;  queue&lt;Node&gt; q; map&lt;long long, int&gt; visited;  // &#45712;&#47548; vector&#47196; &#48148;&#44984;&#47732; &#48736;&#47492;  int main(int argc, char* argv[]) {     scanf(\"%d %lld\", &amp;a, &amp;N);  //   vector&lt;int&gt; visited(1000000, 0);      q.push({1, 0});     visited[1] = 1;      int ans = -1;     while(!q.empty()) {         Node cur = q.front(); q.pop();         visited[cur.num] = 1;         if (cur.num == N) {             ans = cur.dist;             break;         }          if (1000000 &gt; cur.num * a) {             if(visited[cur.num*a] == 0) {                 visited[cur.num*a] = 1;                 q.push({cur.num*a, cur.dist+1});             }         }          // &#46160;&#51088;&#47551; &#49688; &#51060;&#49345;,         // &#46244;&#51665;&#50632;&#51012;&#46412; &#51687;&#50500;&#51648;&#51648; &#50506;&#51004;&#47140;&#47732;, 10 100 &#52376;&#47100;&#46104;&#47732; &#50504;&#46120;         if (cur.num &gt;= 10 &amp;&amp; cur.num%10 != 0) {             string S = to_string(cur.num);             rotate(S.begin(), S.end() - 1, S.end());             long long rnum = stoi(S);             if(visited[rnum] == 0) {                 visited[rnum] = 1;                 q.push({rnum, cur.dist+1});             }         }     }     printf(\"%d\\n\", ans); }        코드 31 m/s    // &#50948; &#53076;&#46300;&#50640;&#49436;  //map&lt;long long, int&gt; visited;  // &#45712;&#47548; vector&#47196; &#48148;&#44984;&#47732; &#48736;&#47492;  int main() { // map -&gt; vector&#47196; &#48148;&#44984;&#44256;, &#48120;&#47532; &#53356;&#44592;&#47484; &#51648;&#51221;&#54616;&#47732; &#48736;&#47492;     vector&lt;int&gt; visited(1000000, 0);       문제 링크    https://atcoder.jp/contests/abc235/tasks/abc235_d    ","categories": [],
        "tags": ["AtCoder","BFS"],
        "url": "/abc235-d-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 1058 친구",
        "excerpt":" BOJ 1058 친구    곧바로 친구관계이거나, 하나 멀리 친구인 관계를 모두 세는 문제      접근하기    - dfs는 visit 배열에서 한번 갔던 곳을 체크함     1 --&gt; 2 --&gt; 3 관계일 때     1 --&gt; 2            1번     1 --&gt; 2 --&gt; 3      2번     visit 배열    1 2 3    1 1 1       3일 때, 1은 2,3과 친구관계를 의미 3 - 1 = 2      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; char str[52]; vector&lt;int&gt; G[52]; int visited[52];  int ans = 0;  void dfs(int num, int dep) {      if (dep &gt; 2) return;     visited[num] = 1;      for(auto&amp; next: G[num]) {         dfs(next, dep + 1);     } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str);         for(int j=0;j&lt;N;j++) {             if (str[j] == 'Y') {                 G[i].push_back(j);             }         }     }      for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;N;j++)             visited[j] = 0;         int cnt = 0;         dfs(i, 0);         for(int j=0;j&lt;N;j++) {             if (visited[j]) cnt += 1;         }         ans = max(ans, cnt);     }     printf(\"%d\\n\", ans-1);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1058    ","categories": [],
        "tags": ["dfs"],
        "url": "/boj-1058/",
        "teaser": null
      },{
        "title": "BOJ 4256 트리",
        "excerpt":" BOJ 4256 트리     접근하기    분할정복으로 접근해야 하는 문제  전위 순회 3,6,5,4,8,7,1,2        --&gt; 맨 앞이 root node     --&gt; 중위순회에에서 왼쪽 subtree의 노드수 4를 이용하면     --&gt; 3  ,6,5,4,8,  7,1,2         --&gt; root = 0번 index     --&gt; 왼쪽 subtree 시작위치 1  == root + 1   -&gt; 값     --&gt; 오른쪽 subtree 시작위치 5 == root + 4 - 0 + 1     --&gt; 4값은 중위순회에서 얻음      중위 순회 5,6,8,4,3,1,2,7       --&gt; 한가운데가 root node -&gt; 왼쪽 sub tree, 오른쪽 sub tree로 나눌 수 있음     --&gt; 3이 root, 왼쪽 subtree가 4개, 오른쪽 subtree가 3개의 노드가 있음  후위 순회 5,8,4,6,2,1,7,3       코드    #include &lt;bits/stdc++.h&gt;  int T; int N;  int pre[1010]; int in[1010];  void f(int s, int e, int root) {     for(int i=s;i&lt;e;i++) {         if (in[i] == pre[root]) {             f(s, i, root + 1);             f(i+1, e, root + (i-s) + 1);             printf(\"%d \", pre[root]);         }     } }  void solve() {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;pre[i]);      }     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;in[i]);      }      f(0, N, 0);     printf(\"\\n\"); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/4256    ","categories": [],
        "tags": ["분할정복","Tree"],
        "url": "/boj-4256/",
        "teaser": null
      },{
        "title": "BOJ 10610 30",
        "excerpt":" BOJ 10610 30    숫자가 주어질때, 가장 큰 30의 배수로 만들어 출력 없으면 -1 출력      위키에 나온 설명    배수판정법   30의 배수는 3의 배수이면서 일의자리가 0인 수이다. 3의 배수는 각 자리 숫자의 합이 3의 배수인 수이다.       접근하기    30의 배수판별 조건 1. 모든 자리수의 합이 3의 배수여야 함 2. 마지막 자리가 0어야 함  최대로 크다는 의미 큰 자리수에 큰 숫자가 위치, 작은 자리수에 더 작은 숫자가 위치 -&gt; 내림차순 정렬       코드    #include &lt;bits/stdc++.h&gt; using namespace std;  char str[100010];  bool cmp(char p1, char p2) {         return p1 &gt; p2; }  int main(int argc, char* argv[]) {         scanf(\"%s\", str);         int sum = 0;          bool lastzero = 0;         int pos = 0;         for(int i=0;str[i];i++) {                 sum += str[i] - '0';                 pos++;         }         sort(str, str+pos, cmp);         if (sum %3 == 0 &amp;&amp; str[pos-1] == '0') {                 printf(\"%s\\n\", str);         } else {                 printf(\"-1\\n\");         }          return 0; }       문제 링크    https://www.acmicpc.net/problem/10610      풀이/설명참고    https://sihyungyou.github.io/baekjoon-10610/      참고자료   ","categories": [],
        "tags": ["수학"],
        "url": "/boj-10610/",
        "teaser": null
      },{
        "title": "BOJ 13335 트럭",
        "excerpt":" BOJ 13335 트럭    다리에 길이와 무게가 주어짐 차량이 순서대로 통과할 때, 다리가 버틸 수 있는 무게보다 적게만 지나가야 함 모든 트럭이 지나는데 걸리는 시간      접근하기    1. queue를 이용해서 구현 2. 매번 차량이 다리에 오르지 않는 조건을 어떻게 표시할 것인가?       코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, W, L; int a[1010];  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;N, &amp;W, &amp;L);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }      queue&lt;int&gt; q;     int sum = 0;     int time = 0;     for(int i=0;i&lt;N;i++) {          while(1) {             int size = (int)q.size();             // &#45796;&#47532;&#51032; &#54616;&#51473;&#47564;&#53372; &#50732;&#46972;&#50772;&#51004;&#47732;             if (size == W) {                 int cur = q.front(); q.pop();                 sum -= cur;     // &#47592; &#50526;&#51032; &#52264;&#47484; &#52824;&#50868;&#45796;.             }              // &#49352;&#47196;&#50868; &#52264;&#47484; &#50732;&#47540; &#49688; &#50630;&#51004;&#47732;, '0'&#51012; &#50732;&#47548;             if (sum + a[i] &lt;= L)                 break;             else {                 q.push(0);                 time += 1;             }         }          // &#49352;&#47196;&#50868; &#52264;&#47484; &#50732;&#47540; &#49688; &#51080;&#51004;&#47732; &#52628;&#44032;         q.push(a[i]);         sum += a[i];         time += 1;     }     printf(\"%d\\n\", time + W);     return 0; }       문제 링크    https://www.acmicpc.net/problem/13335    ","categories": [],
        "tags": ["시뮬레이션","Queue"],
        "url": "/boj-13335/",
        "teaser": null
      },{
        "title": "BOJ 2504 괄호의 값",
        "excerpt":" BOJ 2504 괄호의 값    올바른 문자열인지 아닌지 체크 올바른 문자열이라면 계산 값 리턴      접근하기    1. check에서 string을 모두 stack에서 pair를 맞춰봐서 스택이 비면, 올바른 문자열 2. 올바른 문자열이면 주어진대로 계산      코드 - 1st    #include &lt;bits/stdc++.h&gt; using namespace std;  // 0 : num // [ : 1 // ] : 2 // ( : 3 // ) : 4 typedef struct Node {     int type;           // 1 : [ ( ) ]      // 2 : val     int num; } Node;  char str[40];  bool check(char str[]) {     stack&lt;char&gt; s;       for(int i=0;str[i];i++) {         switch(str[i]) {         case '[':             s.push(str[i]);             break;         case '(':             s.push(str[i]);             break;         case ')':             if (s.empty()) {                 s.push(str[i]);             }             if (!s.empty() &amp;&amp; s.top() == '(') {                 s.pop();             }             break;         case ']':             if (s.empty()) {                 s.push(str[i]);             }             if (!s.empty() &amp;&amp; s.top() == '[') {                 s.pop();             }             break;         }     }     return s.empty(); }  void work(char str[]) {     stack&lt;Node&gt; s;        for(int i=0;str[i];i++) {         switch(str[i]) {         case '(':               // 3             s.push({3, 0});             break;         case ')':               // 4             if (!s.empty() &amp;&amp; s.top().type == 3) {      // () -&gt;2                 s.pop();                 s.push({0, 2});             } else if (!s.empty() &amp;&amp; s.top().type == 0) {                 int tot = 0;                 while (!s.empty() &amp;&amp; s.top().type != 3) {      // () -&gt;2                     tot = tot + s.top().num;                     s.pop();                 }                 s.pop();        // remove '('                 s.push({0, tot*2});             }             break;         case '[':               // 1             s.push({1, 0});             break;         case ']':               // 2             if (!s.empty() &amp;&amp; s.top().type == 1) {      // [] -&gt;3                 s.pop();                 s.push({0, 3});             } else if (!s.empty() &amp;&amp; s.top().type == 0) {                 int tot = 0;                 while (!s.empty() &amp;&amp; s.top().type != 1) {      // [] -&gt;2                     tot = tot + s.top().num;                     s.pop();                 }                 s.pop();        // remove '['                 s.push({0, tot*3});             }             break;         }      }      int ans = 0;     while( !s.empty()) {         ans += s.top().num;         s.pop();     }     printf(\"%d\\n\", ans); }  int main(int argc, char* argv[]) {     scanf(\"%s\", str);     if (check(str)) {         work(str);     } else {         printf(\"0\\n\");     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/2504    ","categories": [],
        "tags": ["자료구조"],
        "url": "/boj-2504/",
        "teaser": null
      },{
        "title": "BOJ 2638 치즈",
        "excerpt":" BOJ 2638 치즈    바깥 공기와 안쪽 공기로 나뉨 바깥 공기 2개 이상 인접하면, 치즈를 없앰      접근하기    1. 바깥을 0 -&gt; 3으로 처음에 변경 2. 1을 만나면 2개의 3이 있는지 check하고 vector에 저장      코드 - 606 m/s - 느린 구현    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, M; int a[101][101];  typedef struct Node {     int y;     int x; } Node;  int dy[4] = {1, -1, 0, 0}; int dx[4] = {0, 0, 1, -1};  bool safe(int y, int x) {     return (0&lt;=y &amp;&amp; y&lt;N) &amp;&amp; (0&lt;=x &amp;&amp; x&lt;M); }  void fill_outside(int y, int x) {     int visited[101][101] = {0, };     queue&lt;Node&gt; q;     q.push({y,x});     visited[y][x] = 1;         a[y][x] = 2;     while(!q.empty()) {         Node cur = q.front(); q.pop();         for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];              if (safe(ny, nx) &amp;&amp; visited[ny][nx] == 0 &amp;&amp; a[ny][nx] == 0) {                 visited[ny][nx] = 1;                 a[ny][nx] = 2;                  q.push({ny, nx});             }         }     } }  bool touch_two(int y, int x) {     int visited[101][101] = {0, };      visited[y][x] = 1;      int cnt = 0;     for(int i=0;i&lt;4;i++) {         int ny = y + dy[i];         int nx = x + dx[i];          if (safe(ny, nx) &amp;&amp; visited[ny][nx] == 0 &amp;&amp; a[ny][nx] == 2) {             visited[ny][nx] = 1;             cnt += 1;                         }     }      return (cnt &gt;= 2); }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      int total = 0;     for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;M;j++) {             scanf(\"%d\", &amp;a[i][j]);             if (a[i][j]) total += 1;         }     }     fill_outside(0, 0);     int time = 0;     while(total) {          vector&lt;Node&gt; v;         for(int i=0;i&lt;N;i++) {             for(int j=0;j&lt;M;j++) {                 if (a[i][j] == 1) {                     int ret = touch_two(i, j);                     if (ret) v.push_back({i,j});                 }             }         }          for(auto o:v) {             if (a[o.y][o.x] == 1) {                 a[o.y][o.x] = 2;                 fill_outside(o.y, o.x);                 total--;             }          }          time += 1;             dbg();     }     printf(\"%d\\n\", time);     return 0; }        TODO 코드 - 시간 최적화 할 것     문제 링크    https://www.acmicpc.net/problem/2638    ","categories": [],
        "tags": ["BFS"],
        "url": "/boj-2638/",
        "teaser": null
      },{
        "title": "BOJ 17478 재귀함수가 뭔가요?",
        "excerpt":" BOJ 17478 재귀함수가 뭔가요?    재귀함수 형태로 문자열 출력 규칙 파악하기      접근하기    f(0) ----&gt; f(1) ----&gt; f(2)  0칸띄움    4칸띄움    8칸 띄움   f(num) {    if (num &gt; N) {      hello ans    }       if (num == N)        hello ans    else        hello begin    f(x)    hello end }  hello begin     hello begin         hello ans         hello end     hello end hello end      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N ;  void f(int depth) {     if (depth &gt; N) return;      string line = \"\";     for(int i=0;i&lt;depth;i++) {         line += \"____\";     }     cout &lt;&lt; line &lt;&lt; \"\\\"&#51116;&#44480;&#54632;&#49688;&#44032; &#47956;&#44032;&#50836;?\\\"\\n\";      if (N != depth) {         cout &lt;&lt; line &lt;&lt; \"\\\"&#51096; &#46308;&#50612;&#48372;&#44172;. &#50715;&#45216;&#50715;&#45216; &#54620; &#49328; &#44845;&#45824;&#44592;&#50640; &#51060;&#49464;&#49345; &#47784;&#46304; &#51648;&#49885;&#51012; &#53685;&#45804;&#54620; &#49440;&#51064;&#51060; &#51080;&#50632;&#50612;.\\n\";         cout &lt;&lt; line &lt;&lt; \"&#47560;&#51012; &#49324;&#46988;&#46308;&#51008; &#47784;&#46160; &#44536; &#49440;&#51064;&#50640;&#44172; &#49688;&#47566;&#51008; &#51656;&#47928;&#51012; &#54664;&#44256;, &#47784;&#46160; &#51648;&#54812;&#47213;&#44172; &#45824;&#45813;&#54644; &#51452;&#50632;&#51648;.\\n\";         cout &lt;&lt; line &lt;&lt; \"&#44536;&#51032; &#45813;&#51008; &#45824;&#48512;&#48516; &#50739;&#50520;&#45796;&#44256; &#54616;&#45348;. &#44536;&#47088;&#45936; &#50612;&#45712; &#45216;, &#44536; &#49440;&#51064;&#50640;&#44172; &#54620; &#49440;&#48708;&#44032; &#52286;&#50500;&#50752;&#49436; &#47932;&#50632;&#50612;.\\\"\\n\";     } else {         cout &lt;&lt; line &lt;&lt; \"\\\"&#51116;&#44480;&#54632;&#49688;&#45716; &#51088;&#44592; &#51088;&#49888;&#51012; &#54840;&#52636;&#54616;&#45716; &#54632;&#49688;&#46972;&#45348;\\\"\\n\";      }     f(depth + 1);     cout &lt;&lt; line &lt;&lt; \"&#46972;&#44256; &#45813;&#48320;&#54616;&#50688;&#51648;.\\n\";  }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     cout &lt;&lt; \"&#50612;&#45712; &#54620; &#52980;&#54504;&#53552;&#44277;&#54617;&#44284; &#54617;&#49373;&#51060; &#50976;&#47749;&#54620; &#44368;&#49688;&#45784;&#51012; &#52286;&#50500;&#44032; &#47932;&#50632;&#45796;.\\n\";     f(0);     return 0; }       문제 링크    https://www.acmicpc.net/problem/17478    ","categories": [],
        "tags": ["재귀"],
        "url": "/boj-17478/",
        "teaser": null
      },{
        "title": "BOJ 3079 입국심사",
        "excerpt":" BOJ 3079 입국심사    심사대가 N개, 사람수가 M 심사대는 심사시간이 각기다름 빈 곳에 아무 순서대로 가서 심사를 받으면 됨 최소 시간은 얼마?      접근하기    a심사대가 7시간이 소모되고, b심사대가 10시간이 소모되면  시간이 28이면  28/7 = 4 28/10 = 2  M = 4 + 2 가 된다. -&gt;최적 값  시간이 60이면  60/7 = 8 60/10 = 6  8 + 6 &gt; M  총 시간을 X로 놓고, min=0 ~ max=M * 가장오래걸리는 심사대의 시간 이분탐색을 한다.         코드 2    https://www.acmicpc.net/blog/view/109 보고 바꿈   #include &lt;bits/stdc++.h&gt; using namespace std;  typedef long long ll;  ll N, M; int a[100010];  bool check(ll num) {     ll cnt = 0;     for(int i=0;i&lt;N;i++) {         cnt += num/a[i];     }      return (cnt &gt;= M); }  int main(int argc, char* argv[]) {     scanf(\"%lld %lld\", &amp;N, &amp;M);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\",&amp;a[i]);     }         sort(a, a+N);     ll s = 0;     ll e = a[N-1] * M;     ll ans = e;     while(s + 1 &lt; e) {         ll mid = (s+e)/2;          if (check(mid)) {             ans = min(ans, mid);             e = mid;         } else {             s = mid;         }     }     printf(\"%lld\\n\", ans); }      코드    #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int N, M; ll a[100010];  inline bool check(ll mid) {     ll sum = 0;     for(register int i=0;i&lt;N;i++) {         sum += mid/a[i];      }      return (sum &gt;= M); }  int main(int argc, char* argv[]) {     //freopen(\"input.txt\", \"r\", stdin);     freopen(\"input2.txt\", \"r\", stdin);     scanf(\"%d %d\", &amp;N, &amp;M);     for(register int i=0;i&lt;N;i++) {         scanf(\"%lld\", &amp;a[i]);     }       sort(a, a+N);      register ll s = 0;     register ll e = a[N-1];     e = e * M;       register ll ans = e;     while(s&lt;=e) {         ll mid = (s+e)/2;         if (check(mid)) {             ans = min(ans, mid);             e = mid - 1;         } else {             s = mid + 1;         }     }         printf(\"%lld\\n\", ans);     return 0; }        문제 링크    https://www.acmicpc.net/problem/3079    ","categories": [],
        "tags": ["이분탐색"],
        "url": "/boj-3079/",
        "teaser": null
      },{
        "title": "BOJ 8892 팰린드롬",
        "excerpt":" BOJ 8892 팰린드롬    문자열을 조합해서 팰린드롬인지 알아내기      접근하기    N이 100 N*N을 해도 10000번 반복 두 문자열을 붙여서 팰린드롬인지 체크한다.      코드 - STL 24 m/s    #include &lt;bits/stdc++.h&gt; using namespace std;  int T; int N; string str[101];  void solve() {     cin &gt;&gt; N;     for(int i=0;i&lt;N;i++)         cin &gt;&gt; str[i];     for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;N;j++) {             if (i == j) continue;             string tmp = str[i] + str[j];             bool same = true;             for(int s=0, e=(int)tmp.size()-1; s &lt; e &amp;&amp; s&lt;(int)tmp.size() &amp;&amp; e&gt;=0;s++, e--) {                 if (tmp[s] != tmp[e]) {                     same = false;                     break;                 }             }              if (same) {                 cout &lt;&lt; tmp &lt;&lt; \"\\n\";                 return;             }         }     }     cout &lt;&lt; \"0\" &lt;&lt; \"\\n\"; }  int main(int argc, char* argv[]) {     // 28 m/s&#50688;&#51004;&#45208;, &#50500;&#47000;&#47484; &#52628;&#44032;&#54616;&#47732; 4 m/s &#44048;&#49548;     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);     cin &gt;&gt; T;     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       코드 - 구현 8 m/s    #include &lt;stdio.h&gt;  int T; int N;  char str[101][10001]; int len[101]; char tmp[10010];  void my_strcpy(char* p1, char* p2) {     while(*p2 != '\\0') {         *p1 = *p2;         p1++;         p2++;     }     *p1 = '\\0'; }  void solve() {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%s\", str[i]);          len[i] = 0;         for(;str[i][len[i]];len[i]++); }     for(int i=0;i&lt;N;i++) {         for(int j=0;j&lt;N;j++) {             if (i == j) continue;              my_strcpy(tmp, str[i]);             my_strcpy(tmp+len[i], str[j]);             bool same = true;             for(int s=0, e=(int)(len[i]+len[j]-1); s &lt; e &amp;&amp; s&lt;(int)(len[i]+len[j]) &amp;&amp; e&gt;=0;s++, e--) {                 if (tmp[s] != tmp[e]) {                     same = false;                     break;                 }             }              if (same) {                 printf(\"%s\\n\", tmp);                 return;             }         }     }     printf(\"0\\n\"); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }        문제 링크    https://www.acmicpc.net/problem/8892    ","categories": [],
        "tags": ["완전탐색","문자열"],
        "url": "/boj-8892/",
        "teaser": null
      },{
        "title": "BOJ 1769 3의 배수",
        "excerpt":" 3의 배수    모든 자릿수의 수를 더해서 3의 배수이면, 3의 배수 1자리의 수가 될 때까지 반복문      접근하기    문자열을 sum에 담음 sum을 이용해서 반복      TODO 코드 - 재귀를 이용해서 풀어볼 것    TODO 코드 - 좀 더 간결히 풀 것    #include &lt;stdio.h&gt;  char str[1000010];  int main(int argc, char* argv[]) {     scanf(\"%s\", str);      int sum = 0;     for(int i=0;str[i];i++) {         sum += str[i] - '0';         }     int org = sum;     // 123     int cnt = 0;     while(sum / 10 != 0) {         int tmp = sum;         //printf(\"sum:%d\\n\", sum);         sum = 0;         while(tmp) {             int num = tmp % 10;             sum += num;             tmp = tmp / 10;         }          cnt += 1;     }     if (sum != org) cnt++;     printf(\"%d\\n\", cnt);     if (sum % 3 == 0)         printf(\"YES\\n\");     else         printf(\"NO\\n\");     return 0; }       문제 링크    https://www.acmicpc.net/problem/1769    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-1769/",
        "teaser": null
      },{
        "title": "BOJ 9655 돌게임",
        "excerpt":" 돌게임    1, 3개의 돌을 순서대로 가져갈 때 승자 구하기      접근하기     1개 A  3개 A A A -&gt; A  4개    -&gt; B A B B B A A A B  5개 A B B B A  -&gt; A  규칙대로 써보면, 홀수이면 A, 짝수이면 B가 이김       코드1 - 홀짝    #include &lt;stdio.h&gt;  int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     if (N%2 == 1) {         printf(\"SK\\n\");     } else {         printf(\"CY\\n\");     }     return 0; }       코드2 - dp    홀짝 규칙을 점화식으로   #include &lt;stdio.h&gt;  int N;  int dp[1001];  int main(int argc, char* argv[]) {     dp[0] = 0;     scanf(\"%d\", &amp;N);     dp[1] = 1;  // Win SK     dp[2] = 0;     dp[3] = 1;     for(int i=4;i&lt;=N;i++) {         dp[i] = !dp[i-1];     }     if (dp[N]) {         printf(\"SK\\n\");     } else {         printf(\"CY\\n\");     }     return 0; }       코드3 - dp - 최소 게임의 횟수를 dp[k]로 놓기    거리를 기준으로 하는 점화식 표현 가능    dp[k] : k번째 턴에서 최소 게임의 횟수  dp[0] = 0  dp[1] = 1 dp[2] = 2 dp[3] = min(dp[3-3], dp[3-1]) + 1 ... dp[k] = min(dp[k-3], dp[k-1]) + 1    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; int dp[1010]; // dp[k] : &#52572;&#49548; &#44172;&#51076;&#51032; &#54943;&#49688;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     dp[0] = 0;     dp[1] = 1;     dp[2] = 2;     for(int i=3;i&lt;=N;i++) {         dp[i] = min(dp[i-1], dp[i-3]) + 1;     }      if (dp[N] % 2 == 1)          printf(\"SK\\n\");     else         printf(\"CY\\n\");     return 0; }      문제 링크    https://www.acmicpc.net/problem/9655      풀이/설명 참고    https://beginnerdeveloper-lit.tistory.com/83    ","categories": [],
        "tags": ["DP","수학"],
        "url": "/boj-9655/",
        "teaser": null
      },{
        "title": "BOJ 1946 신입사원",
        "excerpt":" BOJ 1946 신입사원     접근하기    서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발  -&gt; 둘중 하나가 남보다 높다. -&gt; 1번째 성적으로 sort하고, 2번째 성적으로 check  7 1 4  -&gt; 무조건 고름 1  2 5  -&gt; 4 &gt; 5 X 3 6  -&gt; 4 &gt; 6 X 4 2  -&gt; 4 &gt; 2 O 고름 2 5 7  -&gt; 2 &gt; 7 X 6 1  -&gt; 2 &gt; 1 O 고름 3 7 3       코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int T, N;  void solve() {     scanf(\"%d\", &amp;N);     vector&lt;pair&lt;int, int&gt;&gt; v(N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d %d\", &amp;v[i].first, &amp;v[i].second);     }     sort(v.begin(), v.end());      int cnt = 1;     int mv = v[0].second;     for(int i=1;i&lt;(int)v.size();i++) {         if (mv &gt; v[i].second) {             mv = v[i].second;             cnt += 1;         }     }     printf(\"%d\\n\", cnt); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/1946    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1946/",
        "teaser": null
      },{
        "title": "BOJ 11497 통나무 건너뛰기",
        "excerpt":" BOJ 2872    규칙을 발견해야 함      접근    2, 9, 7, 4, 5 이 연결되어 있을 때, 각 구간의 차이가 최소가 되도록 했을 때,  최대값은?  2 9 7 4 5 --&gt; 9와 2에서 7 2 5 9 7 4 --&gt; 9와 5에서 4  sort하고 앞뒤로 비교하면, 0번째와 N-1번째의 차이가 크게됨  0 2 4 3 1 형태로 구성하면 최적      코드    #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std;  int T; int N; int a[10010];  void solve() {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+N);     int ans = 0;     for(int i=2;i&lt;N;i++) {         int cnt = a[i] - a[i-2];         ans = max(ans, cnt);     }     printf(\"%d\\n\", ans); }  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/11497    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-11497/",
        "teaser": null
      },{
        "title": "BOJ 2872 우리집엔 도서관이 있어",
        "excerpt":" BOJ 2872    규칙을 발견해야 함      접근    1 3 4 2    -&gt; 2를 맨앞, 1을 맨앞  3, 4는 순서대로  3 2 1      -&gt; 2를 맨앞, 1을 맨앞, 3은 순서대로  가장 큰수를 기준으로 앞으로 가면서 1씩 작은 수가 연속되어 있으면 count한다.  전체(N) - N부터 연속된수가 답       코드    #include &lt;stdio.h&gt;  int N; int a[300030];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }      int pos = N;     for(int i=N;i&gt;=1;i--) {         if (a[i] == pos) {             pos -= 1;         }     }      printf(\"%d\\n\", pos);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2872    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-2872/",
        "teaser": null
      },{
        "title": "BOJ 4179 불!",
        "excerpt":" BOJ 4179 불!    반례를 파악하기 어려워서 힘들었던 문제 BFS로 풀면 된다.      주의사항    F(불)은 여러개 있을 수 있다. 맨 가장자리에서 JH가 곧바로 나올 수 있다.      접근하기          코드 2    #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std;  int R, C; #define SIZE 1010 char a[SIZE][SIZE]; char str[SIZE];  int  jvis[SIZE][SIZE]; int  fvis[SIZE][SIZE]; int  vis[SIZE][SIZE];  typedef struct Node {     int y;     int x; } Node;  Node jh; vector&lt;Node&gt; fire;  int dy[4] = {1, -1, 0, 0}; int dx[4] = {0, 0, 1, -1};  bool safe(int y, int x) {     return ( 0&lt;=x &amp;&amp; x&lt;C &amp;&amp; 0&lt;=y &amp;&amp; y&lt;R ); }  void bfs_f() {     queue&lt;Node&gt; q;     for(auto&amp; o:fire) {         fvis[o.y][o.x] = 0;         q.push({o.y, o.x});      }          while(!q.empty()) {         Node cur = q.front(); q.pop();         for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];              if (safe(ny, nx) &amp;&amp; a[ny][nx] != '#') {                 if (fvis[ny][nx] &gt; fvis[cur.y][cur.x] + 1) {                     fvis[ny][nx] = fvis[cur.y][cur.x] + 1;                     q.push({ny, nx});                 }                     }         }     } }  int bfs_jh() {     queue&lt;Node&gt; q;     q.push({jh.y, jh.x});      jvis[jh.y][jh.x] = 0;     vis[jh.y][jh.x] = 1;      while(!q.empty()) {         Node cur = q.front(); q.pop();          if (cur.y == 0 || cur.y == R -1 || cur.x == 0 || cur.x == C -1) {             return jvis[cur.y][cur.x] + 1;         }          for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];              // vis&#51312;&#44148;&#51060; &#50630;&#51004;&#47732; &#47700;&#47784;&#47532; &#52488;&#44284; &#50724;&#47448;             if (safe(ny, nx) &amp;&amp; a[ny][nx] != '#' &amp;&amp; vis[ny][nx] == 0) {                 if (fvis[ny][nx] &gt; jvis[cur.y][cur.x] + 1) {                     vis[ny][nx] = 1;                     jvis[ny][nx] = jvis[cur.y][cur.x] + 1;                     q.push({ny,nx});                 }             }         }     }      return -1; }  int main(int argc, char* argv[]) { //    freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d %d\", &amp;R, &amp;C);      for(int i=0;i&lt;R;i++) {         scanf(\"%s\", str);          for(int j=0;str[j];j++) {             a[i][j] = str[j];              if (a[i][j] == 'J') {                 jh.y = i;                 jh.x = j;             } else if (a[i][j] == 'F') {                 fire.push_back({i, j});             } else if (a[i][j] == '#') {                 // do nothing             }             fvis[i][j] = 987654321;       // &#52572;&#45824;&#47196; &#45459;&#44256; &#49884;&#51089;         }     }     bfs_f();     int ret =bfs_jh();     dbg();     if (ret == -1)         printf(\"IMPOSSIBLE\\n\");     else         printf(\"%d\\n\", ret);     return 0; }       코드    #include &lt;cstdio&gt; #include &lt;queue&gt; using namespace std;  int R, C;  #define MS 1010 char str[MS];  char a[MS][MS]; int jvis[MS][MS]; int fire[MS][MS];  typedef struct Node {     int y;     int x;     int dist; } Node;  Node jh; vector &lt;Node&gt; f; //Node f;  int dy[4] = {1, -1, 0, 0}; int dx[4] = { 0, 0, 1, -1};  bool safe(int y, int x) {     return (0&lt;=x &amp;&amp; x&lt;C) &amp;&amp;(0&lt;=y &amp;&amp; y&lt;R); }  int bfs_jh() {     queue&lt;Node&gt; q;     q.push({jh.y, jh.x, 0});     jvis[jh.y][jh.x] = 1;      while(!q.empty()) {         Node cur = q.front(); q.pop();          if (cur.y == 0 || cur.y == R -1 || cur.x == 0 || cur.x == C-1) {             if (cur.dist + 1 &lt; fire[cur.y][cur.x])                  return cur.dist + 1;         }          for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];              if (safe(ny, nx) &amp;&amp; jvis[ny][nx] == 0 &amp;&amp; a[ny][nx] != '#') {                 if (cur.dist + 1 &lt; fire[ny][nx] ) {                     jvis[ny][nx] = 1;                     q.push({ny, nx, cur.dist + 1});                 }             }         }     }     return  -1; }  // J : JH&#51032; &#50948;&#52824; // F : &#48520;&#51032; &#50948;&#52824; void bfs_f() {     queue&lt;Node&gt; q;     for(auto &amp; o : f) {         q.push({o.y, o.x, 0});         fire[o.y][o.x] = 1;     }      while(!q.empty()) {         Node cur = q.front(); q.pop();         for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];             if (safe(ny, nx) &amp;&amp; a[ny][nx] != '#') {                 if (fire[ny][nx] &gt; fire[cur.y][cur.x] + 1 ) {                     fire[ny][nx] = fire[cur.y][cur.x] + 1;                     q.push({ny, nx, 0});                 }             }         }     } }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;R, &amp;C);      for(int i=0;i&lt;R;i++) {         scanf(\"%s\", str);         for(int j=0;j&lt;C;j++) {             a[i][j] = str[j];              if (a[i][j] == 'J') {                 jh.y = i;                  jh.x = j;                  fire[i][j] = 987654321;     // &#51648;&#54984;&#51060; &#52488;&#44592;&#50948;&#52824;             } else if (a[i][j] == 'F') {                 f.push_back({i, j, 0});                 fire[i][j] = 0;             } else {                 fire[i][j] = 987654321;             }         }     }      bfs_f();     int ret = bfs_jh();     if (ret == -1) {         printf(\"IMPOSSIBLE\\n\");     } else {         printf(\"%d\\n\", ret);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/4179      반례    5 5 ....F ....# ....# ....# J..#. 답 : 1    5 5 ....F ...J# ....# ....# ...#. 답 : 4    10 10 F........F F........F F........F F........F F...J....F F........F F........F F........F F........F F........F 답 : IMPOSSIBLE    ","categories": [],
        "tags": ["BFS"],
        "url": "/boj-4179/",
        "teaser": null
      },{
        "title": "BOJ 5427 불",
        "excerpt":" BOJ 5427 불    BFS로 풀면 된다.      주의사항    F(불)은 여러개 있을 수 있다. 맨 가장자리에서 SG가 곧바로 나올 수 있다.      코드    #include &lt;cstdio&gt; #include &lt;queue&gt; #include &lt;vector&gt; using namespace std;  int T;  int W, H;  char a[1010][1010]; char str[1010];  int f_vis[1010][1010]; bool vis[1010][1010];  typedef struct Node {     int y;     int x;     int dist; } Node;  Node sg; vector &lt;Node&gt; fire;  int dy[4] = {1, -1, 0, 0}; int dx[4] = {0, 0, 1, -1};  bool safe(int y, int x) {     return (0&lt;=x &amp;&amp; x&lt;W) &amp;&amp; (0&lt;=y &amp;&amp; y&lt;H);  }  void bfs_f() {     queue&lt;Node&gt; q;     for(auto&amp; o: fire) {         q.push({o.y, o.x, 0});         f_vis[o.y][o.x] = 0;     }      while(!q.empty()) {         Node cur = q.front(); q.pop();          for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];              if (safe(ny, nx) &amp;&amp; a[ny][nx] != '#') {                 if (f_vis[ny][nx] &gt; f_vis[cur.y][cur.x] + 1) {                     f_vis[ny][nx] = f_vis[cur.y][cur.x] + 1;                     q.push({ny,nx, 0});                 }             }         }     } }  int bfs_sg() {     queue&lt;Node&gt; q;     q.push({sg.y, sg.x, 0});     vis[sg.y][sg.x] = true;     while(!q.empty()) {         Node cur = q.front();         q.pop();         if (cur.y == 0 || cur.y == H-1 || cur.x == 0 || cur.x == W-1) {             return cur.dist + 1;         }          for(int i=0;i&lt;4;i++) {             int ny = cur.y + dy[i];             int nx = cur.x + dx[i];              if (safe(ny, nx) &amp;&amp; a[ny][nx] != '#') {                 if (f_vis[ny][nx] &gt; cur.dist + 1 &amp;&amp; vis[ny][nx] == false) {                     vis[ny][nx] = true;                     q.push({ny, nx, cur.dist + 1});                 }             }         }     }     return -1; }   void init(int W, int H) {     for(int i=0;i&lt;H;i++) {         for(int j=0;j&lt;W;j++) {             f_vis[i][j] = 0;             vis[i][j] = false;         }     }     fire.clear(); }  void solve() {     scanf(\"%d %d\", &amp;W, &amp;H);     init(W, H);      for(int i=0;i&lt;H;i++) {         scanf(\"%s\", str);         for(int j=0;str[j];j++) {             a[i][j] = str[j];               if (a[i][j] == '@') {                 sg.y = i;                 sg.x = j;             } else if (a[i][j] == '*') {                 fire.push_back({i, j, 0});             }             f_vis[i][j] = 987654321;         }     }      bfs_f();     int ans = bfs_sg();     if (ans == -1)         printf(\"IMPOSSIBLE\\n\");     else         printf(\"%d\\n\", ans); }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;T);     for(int tc=1;tc&lt;=T;tc++) {         solve();     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/5427    ","categories": [],
        "tags": ["BFS"],
        "url": "/boj-5427/",
        "teaser": null
      },{
        "title": "abc236 D - Dance",
        "excerpt":" D - Dance     접근하기    - N 범위가 작아서 완전탐색 - N*2 = 16이면 시간 초과 가능 - permutation을 변형  N = 라면 다음 모양이 나와야 함 0 1 2 3 0 2 1 3 0 3 1 2  에디토리얼 보고 이해함      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  typedef long long ll;  int N; ll a[20][20];  bool visited[20]; int ans = 0; vector &lt;pair&lt;int, int&gt;&gt; vec;  void bt(int idx) {     if ((int)vec.size() == N) {         int ret = 0;         for(auto&amp;o : vec) {             ret = ret ^ a[o.first][o.second];         }          ans = max(ans, ret);         return;      }      int l;     for(int i=0;i&lt;N*2;i++) {         if (visited[i] == 0) {             l = i;             break;         }     }      visited[l] = 1;     for(int i=0;i&lt;N*2;i++) {         if(visited[i] == 0) {             visited[i] = 1;             vec.push_back({l, i});             bt(idx +1);             visited[i] = 0;             vec.pop_back();         }     }     visited[l] = 0; }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;(2*N-1);i++) {         for(int j=i+1;j&lt;(2*N);j++) {             scanf(\"%lld\", &amp;a[i][j]);         }     }      bt(0);     printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://atcoder.jp/contests/abc236/tasks/abc236_d    ","categories": [],
        "tags": ["AtCoder","완전탐색"],
        "url": "/abc236-d-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 1449 수리공 항승",
        "excerpt":" BOJ 1449 수리공 항승    규칙을 발견해야 함      접근    case 1) 구멍의위치   L=2 테이프 길이 1 2 100 101  1~2막으면 테이프 1개 필요 100~101막으면 테이프 1개 필요  L-1로 막는다.  case 2) L = 1이면 3 1 3 2 1  앞뒤로 0.5가 필요하므로, L - 1 = 0 N의 개수만큼 테이프 필요  case 3) 4 3 1 2 3 4  L - 1 = 2  1-2 2-3 3-4 총 3개 필요      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, L; int a[1010];  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;L);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+N);     int s = a[0];      int cnt = 1;     for(int i=0;i&lt;N;i++) {         if ( a[i] - s &gt; L - 1) {             cnt += 1;                 s = a[i];         }     }     printf(\"%d\\n\", cnt);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1449    ","categories": [],
        "tags": ["그리디"],
        "url": "/boj-1449/",
        "teaser": null
      },{
        "title": "BOJ 1493 박스 채우기",
        "excerpt":" BOJ 1493 박스채우기     접근하기    입체 박스에서 정육면체를 하나 떼어내면, 3방향이 나옴  3방향은 작아진 박스가 나옴 -&gt; 분할정복으로 표현이 됨       코드    #include &lt;bits/stdc++.h&gt;  int L, W, H; int N;  typedef struct Node {     int length;     int cnt; } Node; int ans; Node cube[22]; bool failed;  void f(int length, int width, int height, int idx) {     if (length == 0 || width == 0 || height == 0) return;      for(int i=idx;i&gt;=0;i--) {         if (cube[i].cnt &gt; 0 &amp;&amp; (cube[i].length &lt;= length &amp;&amp; cube[i].length &lt;= width &amp;&amp; cube[i].length &lt;= height)) {             cube[i].cnt -= 1;             ans += 1;             f(cube[i].length, width - cube[i].length, cube[i].length, i);             f(length - cube[i].length, width, cube[i].length, i);             f(length, width, height - cube[i].length, i);             return;         }     }     failed = true; }  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;L, &amp;W, &amp;H);     scanf(\"%d\", &amp;N);      for(int i=0;i&lt;N;i++) {         int len, cnt;         scanf(\"%d %d\", &amp;len, &amp;cnt);         cube[i].length = (1 &lt;&lt; len);         cube[i].cnt = cnt;     }      f(L, W, H, N-1);     if (failed) {         printf(\"-1\\n\");     } else {         printf(\"%d\\n\", ans);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/1493      설명/코드 참고    jjh3258 설명    ","categories": [],
        "tags": ["분할정복"],
        "url": "/boj-1493/",
        "teaser": null
      },{
        "title": "BOJ 5904 Moo 게임",
        "excerpt":" BOJ 5904 Moo 게임    생각을 많이 하게 만드는 문제      접근하기     Moo Moo Moo o Moo ...  이렇게 확장되는 규칙에서 N이 주어질 때, N번째 문자 맞추기   1. 분할정복 style풀기 - recursive 2. iterative로 풀기       코드 - recursive style    #include &lt;bits/stdc++.h&gt;  int N; char str[4] = {'m', 'o', 'o', '\\0'};  void f(int n, int k, int len) {     if (n&lt;=3) {         printf(\"%c\\n\", str[n-1]);         return;     }      int new_len = len*2 + (3 + k);      if (n &gt; new_len) {         f(n, k+1, new_len);     } else { // n &lt;= new_len         if (n &gt; len &amp;&amp; n&lt;= (len + k + 3)) {             if (n - len == 1)                printf(\"m\\n\");              else                printf(\"o\\n\");              return ;         } else {             f(n - (len + k + 3), 1, 3);         }        } }  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     f(N, 1, 3);     return 0; }       코드 - iteratvie style    #include &lt;bits/stdc++.h&gt; int N;  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);      int new_len = 3;     int mid_len = 3;      while(new_len &lt; N) {         new_len = new_len*2 + (++mid_len);     }      while(1) {         int size = (new_len - mid_len) / 2;         // 1st         if (size &gt;= N) {             mid_len--;             new_len = size;         } else if (size + mid_len &lt; N) {             N = N - (size + mid_len);             mid_len--;             new_len = size;         } else {             N = N - size;             break;         }         // 3rd     }      if (N == 1)          printf(\"m\\n\");     else         printf(\"o\\n\");     return 0; }       문제 링크    https://www.acmicpc.net/problem/5904      풀이참고    https://david0506.tistory.com/68 https://bconfiden2.tistory.com/277    ","categories": [],
        "tags": ["분할정복"],
        "url": "/boj-5904/",
        "teaser": null
      },{
        "title": "BOJ 1654 랜선 자르기",
        "excerpt":" BOJ 1654 랜선 자르기     접근하기    이분탐색      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  using ll = long long; ll K; ll N;  int a[10010];  bool check(ll mid)  // int mid&#54616;&#47732; &#53952;&#47548; {     ll cnt = 0;     for(int i=0;i&lt;K;i++) {         cnt += a[i]/mid;     }     return (cnt &gt;= N); }  int main(int argc, char* argv[]) {     scanf(\"%lld %lld\", &amp;K, &amp;N);     for(int i=0;i&lt;K;i++) {         scanf(\"%d\", &amp;a[i]);     }      ll s = 1;      ll e = ll(1e10) + 7;     long long ans = s;      // ans = 0 &#51060;&#47732; &#53952;&#47548;     while(s+1 &lt; e) {         ll mid = (s+e)/2;          if (check(mid)) {             ans = mid;             s = mid;         } else {             e = mid;         }     }     printf(\"%lld\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1654      해설/코드참고    https://blog.naver.com/jinhan814/222607789392    ","categories": [],
        "tags": ["이분탐색"],
        "url": "/boj-1654/",
        "teaser": null
      },{
        "title": "BOJ 21758 꿀 따기",
        "excerpt":" BOJ 21758 꿀 따기     접근하기    1. 벌통이 맨 오른쪽에 있는 경우  2. 벌통이 맨 왼쪽에 있는 경우  3. 벌통이 가운데 어딘가 있는 경우      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; int a[100010]; int s[100010];  int main(int argc, char* argv[]) {     freopen(\"input.txt\", \"r\", stdin);     scanf(\"%d\", &amp;N);     for(int i=1;i&lt;=N;i++) {         scanf(\"%d\", &amp;a[i]);     }      s[1] = a[1];     for(int i=2;i&lt;=N;i++) {         s[i] = s[i-1] + a[i];     }     int ans = 0;      for(int i=2;i&lt;N;i++) {         ans = max(ans, s[N] - a[1] - a[i] + s[N] - s[i-1] - a[i]);         ans = max(ans, s[N] - a[N] - a[i] + s[i-1]);         ans = max(ans, s[i] - a[1] + s[N] - s[i-1] - a[N]);     }      printf(\"%d\\n\", ans);     return 0; }       문제 링크    https://www.acmicpc.net/problem/21758      설명/코드 참고    https://david0506.tistory.com/68    ","categories": [],
        "tags": ["부분합","그리디"],
        "url": "/boj-21758/",
        "teaser": null
      },{
        "title": "BOJ 2805 나무자르기",
        "excerpt":" BOJ 2805 나무 자르기     접근하기    이분탐색  - 톱의 높이를 up -&gt; 나무가 줄어듬 - 톱의 높이를 down -&gt; 나무가 많아짐  - down &lt;-  톱의 높이 --&gt; up -    T T T T T F F F F F  - 조건을 만족하는 가장 높은 높이     코드    #include &lt;bits/stdc++.h&gt;  typedef long long ll; int N, M; int a[1000010];  bool check(int height) {     ll cnt = 0; // int&#51060;&#47732; WA     for(int i=0;i&lt;N;i++) {         int namu = a[i] - height;         if (namu &gt; 0) cnt += namu;     }      return (cnt &gt;= M); }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);     int mv = 0;     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);         if (mv &lt; a[i]) mv = a[i];     }      int s = 0;     int e = mv;       int ans = 0;     while(s + 1 &lt; e) {         int mid = (s + e) / 2;          if (check(mid)) {             //printf(\"%d\\n\", mid);             ans = mid;             s = mid;         } else {             e = mid;         }     }     printf(\"%d\\n\", ans);      return 0; }       문제 링크    https://www.acmicpc.net/problem/2805       해설 참고    https://www.acmicpc.net/blog/view/109    ","categories": [],
        "tags": ["이분탐색"],
        "url": "/boj-2805/",
        "teaser": null
      },{
        "title": "abc237 C - kasaka",
        "excerpt":" C - Kasaka     접근하기    앞의 a의 수를 센다. -&gt; x 뒤의 a수를 센다     -&gt; y  y &gt; x 이면 string(y-x, 'a')를 앞에 붙임  str == reverse(string) -&gt; 팰린드롬 -&gt; Yes출력      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(nullptr); typedef long long ll;  int N;  string str;  int main(int argc, char* argv[]) {     cin &gt;&gt; str;     int size = str.size();      // left -&gt;     int x = 0;     for(int i=0;i&lt;size;i++) {         if (str[i] == 'a') x++;             else break;     }      // &lt;- right     int y = 0;     for(int i=size-1;i&gt;=0;i--) {         if (str[i] == 'a') y++;             else break;     }      if (x &lt; y) {         string as(y-x, 'a');         str = as + str;     }      string rev = str;     reverse(rev.begin(), rev.end());      if (str == rev) {         cout &lt;&lt; \"Yes\" &lt;&lt; '\\n';     } else {         cout &lt;&lt; \"No\" &lt;&lt; '\\n';     }      return 0; }        문제 링크    https://atcoder.jp/contests/abc237/tasks/abc237_c    ","categories": [],
        "tags": ["AtCoder","STL"],
        "url": "/abc237-c-upsolving/",
        "teaser": null
      },{
        "title": "abc237 D - LR insertion",
        "excerpt":" D - LR insertion     접근하기    5 LRRLR  0 L  0 앞에 1  1 0 R  1 뒤에 2  1 2 0 R  2 뒤에 3  1 2 3 0 L  3 앞에 4  1 2 4 3 0 R  4 뒤에 5  1 2 4 5 3 0  빈 list에 0을 넣고, 마지막으로 넣은 위치를 cursor로 가리키며, 추가      코드 - STL list    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(nullptr);  int N; string s; list&lt;int&gt; lst;  int main(int argc, char * argv[]) {     FASTIO;     cin &gt;&gt; N &gt;&gt; s;     auto cursor = lst.insert(lst.begin(), 0);      for (int i = 0; i &lt; N; ++i) {         if (s[i] == 'R') {             cursor = lst.insert(++cursor, i + 1);         } else {             cursor = lst.insert(cursor, i + 1);         }     }     for (int x : lst) {         cout &lt;&lt; x &lt;&lt; \" \";     }     cout &lt;&lt; '\\n';     return 0; }        코드 - list 구현    #include &lt;bits/stdc++.h&gt; using namespace std;  int N; char str[500005];  typedef struct Node {     int num;     Node* prev;     Node* next; } Node;  Node pool[500005]; int idx;  Node* CreateNode(int num) {     Node* ptr = &amp;pool[idx++];     ptr-&gt;num = num;     ptr-&gt;prev = NULL;     ptr-&gt;next = NULL;     return ptr; }  Node* insert_next(Node* cursor, int num) {     Node* ptr = CreateNode(num);     Node* before = cursor;     Node* after = cursor-&gt;next;      before-&gt;next = ptr;     ptr-&gt;prev = before;      ptr-&gt;next = after;     after-&gt;prev = ptr;      return ptr; }  Node* insert_prev(Node* cursor, int num) {     Node* ptr = CreateNode(num);      Node* before = cursor-&gt;prev;     Node* after = cursor;      before-&gt;next = ptr;     ptr-&gt;prev = before;      ptr-&gt;next = after;     after-&gt;prev = ptr;      return ptr; }   int main(int argc, char* argv[]) {     idx = 0;     scanf(\"%d\", &amp;N);     scanf(\"%s\", str);      Node* head = CreateNode(-1);     Node* tail = CreateNode(-1);      head-&gt;next = tail;     head-&gt;prev = head;      tail-&gt;prev = head;     tail-&gt;next = tail;      Node* cursor = head;     cursor = insert_next(cursor, 0);      for(int i=0;str[i];i++) {         if (str[i] == 'L'){ // left -&gt; before             cursor = insert_prev(cursor, i+1);         } else {            // right -&gt; after             cursor = insert_next(cursor, i+1);         }     }      Node* ptr = head-&gt;next;     while(ptr != ptr-&gt;next) {         printf(\"%d \", ptr-&gt;num);          ptr = ptr-&gt;next;     }     printf(\"\\n\");     return 0; }        문제 링크    https://atcoder.jp/contests/abc237/tasks/abc237_d    ","categories": [],
        "tags": ["AtCoder","STL","리스트"],
        "url": "/abc237-d-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 10816 숫자카드 2",
        "excerpt":" BOJ 10816 숫자 카드 2     접근하기    입력 0 1 2  3  4  5  6   7  8 9 6 3 2 10 10 10 -10 -10 7 3  sort하면   0   1 2 3 4 5 6  7  8  9  -10 -10 2 3 3 6 7 10 10 10  lower_bound(10) -&gt; 10이 처음 나타나는 주소 upper_bound(10) -&gt; val:10의 다음 주소  upper_bound(10) - lower_bound(10) = 10의 개수 = 3      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  typedef long long ll;  int N, M; int a[500050];  int main(int argc, char* argv[]) {     scanf(\"%d\", &amp;N);     for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     sort(a, a+N);     scanf(\"%d\", &amp;M);     int num;     for(int i=0;i&lt;M;i++) {         scanf(\"%d\", &amp;num);         printf(\"%d \", (int)(upper_bound(a, a+N, num) - lower_bound(a, a+N, num)));     }     printf(\"\\n\");      return 0; }       문제 링크    https://www.acmicpc.net/problem/10816    ","categories": [],
        "tags": ["이분탐색"],
        "url": "/boj-10816/",
        "teaser": null
      },{
        "title": "BOJ 13397 구간 나누기 2",
        "excerpt":" BOJ 13397 구간 나누기 2     접근하기    이분탐색 이용  mid : 구간 점수의 최대값과 최소값 차이  이 값보다 크면 구간을 나눔. - check 함수로 구현      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, M; int a[5050];  #define INF 987654321  bool check(int mid) {     int cnt = 1;     int minv = a[0];     int maxv = a[0];      for(int i=1;i&lt;N;i++) {          maxv = max(maxv, a[i]);         minv = min(minv, a[i]);         if (maxv - minv &gt; mid) {             cnt += 1;              minv = a[i];             maxv = a[i];         }     }      return cnt &lt;= M; }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }      int s = -1;     int e = 10000;      while(s + 1 &lt; e) {         int mid = (s + e)/2;         if (check(mid)) {             e = mid;      // &#44396;&#44036;&#51032; &#51216;&#49688;&#51032; &#52572;&#45843;&#44050;&#51032; &#52572;&#49567;&#44050;         } else {             s = mid;          }     }     printf(\"%d\\n\", e);     return 0; }       문제 링크    https://www.acmicpc.net/problem/13397    ","categories": [],
        "tags": ["이분탐색"],
        "url": "/boj-13397/",
        "teaser": null
      },{
        "title": "BOJ 1477 휴게소 세우기",
        "excerpt":" BOJ 1477 휴게소 세우기     접근하기    휴게소가 없는 구간의 길이의 최댓값을 최소      코드    #include &lt;bits/stdc++.h&gt; using namespace std;  int N, M, L; int a[60];  bool check(int mid) {     int cnt = 0;     for(int i=1;i&lt;N;i++) {         int dist = a[i] - a[i-1] - 1;          cnt += (dist / mid);     }     return cnt &lt;= M; }  int main(int argc, char* argv[]) {     scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;L);      for(int i=0;i&lt;N;i++) {         scanf(\"%d\", &amp;a[i]);     }     a[N++] = 0;     a[N++] = L;     sort(a, a+N);      int s = 0;     int e = L;      while(s+1 &lt; e){         int mid = (s+e)/2;         if (check(mid)) {             e = mid;        // &#52572;&#45824;val&#51032; min         } else {             s = mid;        // &#52572;&#49548;val&#51032; max         }     }     printf(\"%d\\n\", e);     return 0; }       문제 링크    https://www.acmicpc.net/problem/1477    ","categories": [],
        "tags": ["이분탐색"],
        "url": "/boj-1477/",
        "teaser": null
      },{
        "title": "BOJ 1789 수들의 합",
        "excerpt":" BOJ 1789 수들의 합     접근하기    1. 그리디로 풀기  i:1 sum = 1 i:2 sum = 3 i:3 sum = 6 i:4 sum = 10 i:5 sum = 15 i:6 sum = 21 i:7 sum = 28 i:8 sum = 36 i:9 sum = 45 i:10 sum = 55 i:11 sum = 66 i:12 sum = 78 i:13 sum = 91 i:14 sum = 105 i:15 sum = 120 i:16 sum = 136 i:17 sum = 153 i:18 sum = 171 i:19 sum = 190  -&gt; 200이 되려면 29를 더하면 된다. i=19 i:20 sum = 210  -&gt; 20에서 -1빼면 나옴      코드 - 그리디    #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll;  ll N;  int main(int argc, char* argv[]) {     scanf(\"%lld\", &amp;N);      long long sum = 0;     long long i = 1;     while(1) {         sum += i;         if (sum &gt; N) {             printf(\"%lld\\n\", i - 1);             return 0 ;         }         i += 1;     }     return 0; }        TODO 코드 - 이분탐색           문제 링크    https://www.acmicpc.net/problem/1789    ","categories": [],
        "tags": ["그리디","이분탐색"],
        "url": "/boj-1789/",
        "teaser": null
      },{
        "title": "BOJ 2417 정수 제곱근",
        "excerpt":" BOJ 2417 정수 제곱근     접근하기    1. sqrt 함수 이용  2. 이분탐색 이용      코드 - sqrt 이용    #include &lt;bits/stdc++.h&gt; using namespace std;  typedef long long ll;  int main(int argc, char* argv[]) {     ll val;     scanf(\"%lld\", &amp;val);      ll ret = sqrt(val);     if (ret * ret == val)         printf(\"%lld\\n\", ret);     else         printf(\"%lld\\n\", ret + 1);     return 0; }       코드 - 이분탐색 이용    #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; ll N;  int main(int argc, char* argv[]) {     scanf(\"%lld\", &amp;N);       ll s = -1;     ll e = sqrt(numeric_limits&lt;long long&gt;::max()) + 1;      while(s+1 &lt; e) {         ll mid = (s + e) / 2;         if ( mid*mid &gt;= N) {             e = mid;   // &#52572;&#45824;&#44050;&#51032; &#52572;&#49548;         } else {             s = mid;         }     }      printf(\"%lld\\n\", e);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2417    ","categories": [],
        "tags": ["이분탐색","수학"],
        "url": "/boj-2417/",
        "teaser": null
      },{
        "title": "BOJ 2792 보석 상자",
        "excerpt":" BOJ 2792 보석 상자     접근하기    4개 (RRRR) 파란 보석이 7개 (BBBBBBB)  mid로 나누어 떨어지면, cnt 나누어 떨어지지 않으면 cnt + 1  질투심 최대가 최소가 되게 보석을 나누어주는 방법      코드    #include &lt;bits/stdc++.h&gt;  int N, M; int kind[300030];  bool check(long long mid) {     long long cnt = 0;     for(int i=0;i&lt;M;i++) {         cnt += kind[i]/mid;          if (kind[i]%mid != 0) cnt += 1;     }      return cnt &lt;= N; }  int main(int argc, char* argv[]) {     scanf(\"%d %d\", &amp;N, &amp;M);     for(int i=0;i&lt;M;i++) {         scanf(\"%d\", &amp;kind[i]);     }      long long s = 0;     long long e = 1000000000;      while(s + 1 &lt; e) {         long long mid = (s+e)/2;         if (check(mid)) {             e = mid;    // &#51656;&#53804;&#49900; &#52572;&#45824;&#44032; &#52572;&#49548;         } else {             s = mid;         }     }     printf(\"%lld\\n\", e);     return 0; }       문제 링크    https://www.acmicpc.net/problem/2792    ","categories": [],
        "tags": ["이분탐색"],
        "url": "/boj-2792/",
        "teaser": null
      },{
        "title": "BOJ 1406 에디터",
        "excerpt":" BOJ 1406 에디터    STL list를 이용하는 문제      접근하기    abcd 3 P x L P y  lst = abcd($)       ($ == lst.end()에 cursor) P x lst = abcdx($)      // 커서는 그대로 L lst = abcd(x)$ P y  lst = abcdy(x)$   1. push_back후 맨 마지막에 cursor를 가리키기      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(nullptr); typedef long long ll;  int N; char str[100010];  int main(int argc, char* argv[]) {     FASTIO;     cin &gt;&gt; str;     cin &gt;&gt; N;     list&lt;char&gt; l;     for(int i=0;str[i];i++) {         l.push_back(str[i]);     }     auto cursor = l.end();      char cmd;     char ch;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; cmd;         switch(cmd) {         case 'L':             if (l.begin() != cursor) {                 cursor--;              }             break;         case 'D':             if (l.end() != cursor) {                 cursor++;              }             break;         case 'B':             if (l.begin() != cursor) {                 // &#52964;&#49436; &#50812;&#51901;&#50640; &#51080;&#45716; &#47928;&#51088;&#47484; &#49325;&#51228;                 // &#52964;&#49436;&#51032; &#50724;&#47480;&#51901;&#50640; &#51080;&#45912; &#47928;&#51088;&#45716; &#44536;&#45824;&#47196;&#51076;                 cursor = l.erase(--cursor);  // remove left               }             break;         case 'P':             cin &gt;&gt; ch;             l.insert(cursor, ch);  // insert left               break;         }     }     for(auto&amp; o : l) {         cout &lt;&lt; o;     }     cout &lt;&lt; '\\n';      return 0; }       문제 링크    https://www.acmicpc.net/problem/1406    ","categories": [],
        "tags": ["STL","리스트"],
        "url": "/boj-1406/",
        "teaser": null
      },{
        "title": "BOJ 1504 특정한 최단경로",
        "excerpt":" BOJ 1504 특정한 최단 경로    다익스트라 알고리즘으로 구함      접근하기    case1) 1 -&gt; A -&gt; B -&gt; N  case2) 1 -&gt; B -&gt; A -&gt; N  두 경우를 모두 다익스트라 알고리즘으로 나눈다.  // 다익스트라 1번 f(1, A) f(1, B)  // 다익스트라 2번 - 양방향이므로 a_b == b_a 임 f(A, B) f(A, N) f(B, A)  // 다익스트라 3번 f(B, N)       코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define INF 1e9  int N, E; int A, B;  vector&lt; pair&lt;int, int&gt; &gt; G[801]; int d[801];  priority_queue &lt; pair&lt;int, int&gt;, vector&lt; pair&lt;int, int&gt; &gt;, greater&lt; pair&lt;int, int&gt; &gt; &gt; pq;  void daik(int start) {     for(int i=0;i&lt;=N;i++) {         d[i] = INF;     }      d[start] = 0;      pq.emplace(0, start);    // &#49884;&#51089;&#51216;     while(!pq.empty()) {         int cost = pq.top().first;          int id = pq.top().second;          pq.pop();         if (d[id] &lt; cost) continue;                   for(auto&amp; i:G[id]) {             int nid = i.second;       // id             int ncost = i.first;      // cost             if (d[nid] &gt; cost + ncost) {                 d[nid] = cost + ncost;                 pq.emplace(d[nid], nid);             }         }     }  }  int main(int argc, char* argv[]) {     ios_base::sync_with_stdio(false); cin.tie(NULL);     cin &gt;&gt; N &gt;&gt; E;      for(int i=0;i&lt;E;i++) {         int p1, p2, cost;         cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; cost;         G[p1].push_back({cost, p2});         G[p2].push_back({cost, p1});     }     cin &gt;&gt; A &gt;&gt; B;      daik(1);     int s_a = d[A];     int s_b = d[B];      daik(A);     int a_b = d[B];     int b_a = d[B];     int a_n = d[N];      daik(B);     int b_n = d[N];      long long ans = INF;     ans = min(ans, (long long)(s_a + a_b + b_n));         ans = min(ans, (long long)(s_b + b_a + a_n));         if ( a_b == INF || ans &gt;= INF)         cout &lt;&lt; -1 &lt;&lt; '\\n';     else         cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/1504    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-1504/",
        "teaser": null
      },{
        "title": "BOJ 1753 최단경로",
        "excerpt":" BOJ 1753 최단경로    다익스트라 알고리즘으로 구함      접근하기    1. 그래프에서 edge의 가중치가 양수 2. 최단거리를 구하기  -&gt; 다익스트라 알고리즘으로 구할 수 있음      코드 - STL priority queue 이용    #include &lt;bits/stdc++.h&gt; using namespace std; #define INF 1e9  int V, E; int S;  vector&lt; pair&lt;int, int&gt; &gt; G[20020]; int d[20020];  priority_queue &lt; pair&lt;int, int&gt;, vector&lt; pair&lt;int, int&gt; &gt;, greater&lt; pair&lt;int, int&gt; &gt; &gt; pq;  int main(int argc, char* argv[]) {     ios_base::sync_with_stdio(false); cin.tie(NULL);     cin &gt;&gt; V &gt;&gt; E;      cin &gt;&gt; S;      for(int i=0;i&lt;E;i++) {         int p1, p2, cost;         cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; cost;         G[p1].push_back({cost, p2});     }     for(int i=0;i&lt;=V;i++) {         d[i] = INF;     }      d[S] = 0;      pq.emplace(0, S);    // &#49884;&#51089;&#51216;     while(!pq.empty()) {         int cost = pq.top().first;          int id = pq.top().second;          pq.pop();         if (d[id] &lt; cost) continue;                   for(auto&amp; i:G[id]) {             int nid = i.second;       // id             int ncost = i.first;      // cost             if (d[nid] &gt; cost + ncost) {                 d[nid] = cost + ncost;                 pq.emplace(d[nid], nid);             }         }     }       for(int i=1;i&lt;=V;i++) {         if (d[i] == INF)             cout &lt;&lt; \"INF\" &lt;&lt; '\\n';         else             cout &lt;&lt; d[i] &lt;&lt; '\\n';     }     return 0; }      코드 - heap 직접구현    #include &lt;cstdio&gt;  int V, E; int S;  typedef struct Node {     int to;     int val;     Node* next; } Node;  #define MAX_V 20001 #define MAX_E (300010*2) Node pool[MAX_E]; Node* list[MAX_V]; int d[MAX_V]; int idx;  Node* CreateNode(int to, int val) {     Node* ptr = &amp;pool[idx++];     ptr-&gt;to = to;     ptr-&gt;val = val;     ptr-&gt;next = NULL;     return ptr; }  typedef struct HeapNode {     int to;     int val; } HeapNode;  class MinHeap { private:     int heap_size;     HeapNode heap[MAX_E]; public:     MinHeap() {         heap_size = 0;     }      void push(int to, int val) {         int idx = ++heap_size;             heap[idx].to = to;         heap[idx].val = val;          while(idx != 1 &amp;&amp; heap[idx].val &lt; heap[idx/2].val) {             HeapNode tmp = heap[idx];             heap[idx] = heap[idx/2];             heap[idx/2] = tmp;              idx = idx / 2;         }     }      bool empty()     {         return heap_size == 0;     }      int size()     {         return heap_size;     }      HeapNode top() {         return heap[1];     }      HeapNode pop() {         HeapNode ret = heap[1];         heap[1] = heap[heap_size--];          int parent = 1;         int child = parent * 2;          while(child &lt;= heap_size) {             if (child+1 &lt;= heap_size &amp;&amp; heap[child].val &gt; heap[child+1].val) {                 child++;             }              if (heap[child].val &lt; heap[parent].val) {                 HeapNode tmp = heap[child];                 heap[child] = heap[parent];                 heap[parent] = tmp;             }              parent = child;             child *= 2;         }         return ret;     } };   int main(int argc, char* argv[]) {     idx = 0;     scanf(\"%d %d\", &amp;V, &amp;E);     scanf(\"%d\", &amp;S);      for(int i=0;i&lt;=V;i++) {         d[i] = 1e9;     }     d[S] = 0;      MinHeap q;     q.push(S, 0);      int from, to, val;     for(int i=0;i&lt;E;i++) {         scanf(\"%d %d %d\", &amp;from, &amp;to, &amp;val);         Node* ptr = CreateNode(to, val);         ptr-&gt;next = list[from];         list[from] = ptr;     }       while(!q.empty()) {         int cur = q.top().to;         int val = q.top().val;         q.pop();          if (d[cur] &lt; val) continue;          Node* ptr = list[cur];         while(ptr) {             if (d[ptr-&gt;to] &gt; val + ptr-&gt;val) {                 d[ptr-&gt;to] = val + ptr-&gt;val;                 q.push(ptr-&gt;to, val + ptr-&gt;val);              }             ptr = ptr-&gt;next;         }     }     for(int i=1;i&lt;=V;i++) {         if (d[i] == 1e9)             printf(\"INF\\n\");         else             printf(\"%d\\n\", d[i]);     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/1753      해설 링크    https://yabmoons.tistory.com/364    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-1753/",
        "teaser": null
      },{
        "title": "abc239 D - Prime Sum Game",
        "excerpt":" D - Prime Sum Game    Taka가 A~B 사이 숫자 하나 내기 Aoki가 C~D 사이 숫자 하나 내기 prime(소수)이면 Aoki승, 아니면 Taka승이라고 할 때 누가 이기는가? (둘다 최적으로 게임을 하면)      접근하기    1. 두 선수가 낼 수 있는 모든 숫자의 조합을 모두 검사한다. 2. 모든 조합에서 소수만 나올 수 있으면, Aoki 승 아니면 Taka 승      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; int p[201]; int a, b, c, d;  void make_prime() {         for(int i=2;i&lt;=200;i++)         p[i]=1;          for(int i=2;i*i&lt;=200;i++) {         if(p[i]) {             for(int j=i*i;j&lt;=200;j+=i) {                 p[j]=0;             }         }     } }   int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE //    freopen(\"input.txt\", \"r\", stdin); #endif      cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;      make_prime();     for(int i=a;i&lt;=b;i++) {         int result = 1;     // Taka         for(int j=c;j&lt;=d;j++) {             if (!p[i+j])                 result = result &amp; 1;             else                 result = result &amp; 0;         }         if (result) {             cout &lt;&lt; \"Takahashi\" &lt;&lt; '\\n';             return 0;         }     }     cout &lt;&lt; \"Aoki\" &lt;&lt; '\\n';     return 0; }       문제 링크    https://atcoder.jp/contests/abc239/tasks/abc239_d    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc239-d-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 11404 플로이드",
        "excerpt":" BOJ 11404 플로이드     접근하기    - 플로이드 와샬 알고리즘으로 모든 정점간의 최단거리 구하기      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9 int N; int M;  int dp[101][101];  int main(int argc, char* argv[]) {     FASTIO     freopen(\"input.txt\", \"r\", stdin);     cin &gt;&gt; N;     cin &gt;&gt; M;      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             if (i != j) dp[i][j] = INF;         }     }      int p1, p2, cost;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; cost;         if(dp[p1][p2] &gt; cost) {             dp[p1][p2] = cost;         }     }      for(int k=1;k&lt;=N;k++) {         for(int i=1;i&lt;=N;i++) {             for(int j=1;j&lt;=N;j++) {                 if (dp[i][j] &gt; dp[i][k] + dp[k][j]) {                     dp[i][j] = dp[i][k] + dp[k][j];                 }             }         }     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             if (dp[i][j] == INF)                 cout &lt;&lt; 0 &lt;&lt; \" \";             else                 cout &lt;&lt; dp[i][j] &lt;&lt; \" \";         }         cout &lt;&lt; '\\n';     }      return 0; }       문제 링크    https://www.acmicpc.net/problem/11404      알고리즘 해설    http://egloos.zum.com/printf/v/776269 https://dongdd.tistory.com/107    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-11404/",
        "teaser": null
      },{
        "title": "BOJ 1389 케빈 베이컨의 6단계 법칙",
        "excerpt":" BOJ 1389 케빈 베이컨의 6단계 법칙    BFS로 최단거리 -&gt; 깊이      접근하기    N이 100   1~N만큼 BFS를 구동해서, 찾는다.      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll;  int N, M; typedef struct Node {     int id;     int dist; } Node;  vector&lt;Node&gt; G[101];  int bfs(int start) {     int vis[101] = {0, };         int dp[101] = {0, };         queue&lt;Node&gt; q;     q.push({start, 0});     vis[start] = 1;     dp[start] = 0;      while(!q.empty()) {         Node cur = q.front(); q.pop();         for(auto&amp; o : G[cur.id]) {             int nid = o.id;             if (vis[nid] == 0) {                 vis[nid] = 1;                 dp[nid] = cur.dist +1;                 q.push({nid, cur.dist +1});              }          }     }      int sum = 0;     for(int i=1;i&lt;=N;i++) {         sum += dp[i];     }     return sum; }   int main(int argc, char* argv[]) {     FASTIO;     //freopen(\"input.txt\", \"r\", stdin);     cin &gt;&gt; N &gt;&gt; M;     int p1, p2;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; p1 &gt;&gt; p2;         G[p1].push_back({p2, 0});         G[p2].push_back({p1, 0});     }      int val = 987654321;     int ans = -1;     for(int i=1;i&lt;=N;i++) {         int ret = bfs(i);         if (val &gt; ret) {             val = ret;             ans = i;         }     }     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/1389    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-1389/",
        "teaser": null
      },{
        "title": "BOJ 1613 역사",
        "excerpt":" BOJ 1613 역사    a(1000) &lt; b(1919)  -&gt; -1 b(1919) &lt; a(1000)  -&gt; 1 모르면             -&gt; 0      접근하기    - 플로이드 와샬 알고리즘으로 선후 관계를 알 수 있음  G[a][b] = -1; G[b][a] = 1; 로 입력의 선후관계 지정  플로이드 와샬 알고리즘       코드 - 플로이드 와샬(Floyd-Warshall)    #include &lt;bits/stdc++.h&gt; using namespace std; int N; int K; int S;  int dp[401][401]; int a[401][401];  int main(int argc, char* argv[]) {     cin &gt;&gt; N &gt;&gt; K;      int p1, p2;     for(int i=1;i&lt;=K;i++) {         cin &gt;&gt; p1 &gt;&gt; p2;         dp[p1][p2] = -1;         dp[p2][p1] = 1;     }       for(int k=1;k&lt;=N;k++) {         for(int i=1;i&lt;=N;i++) {             for(int j=1;j&lt;=N;j++) {                  if (dp[i][j] == 0) {                     if (dp[i][k] == 1 &amp;&amp; dp[k][j] == 1) {                         dp[i][j] = 1;                     }                     if (dp[i][k] == -1 &amp;&amp; dp[k][j] == -1) {                         dp[i][j] = -1;                     }                 }             }         }     }      cin &gt;&gt; S;     for(int i=0;i&lt;S;i++) {         cin &gt;&gt; p1 &gt;&gt; p2;         if (dp[p1][p2] == INF)             cout &lt;&lt; 0 &lt;&lt; '\\n';         else             cout &lt;&lt; dp[p1][p2] &lt;&lt; '\\n';     }     return 0; }       TODO 코드 - 위상정렬(Topological sort)이용    TODO 코드 - DFS로 풀기    문제 링크    https://www.acmicpc.net/problem/1613    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-1613/",
        "teaser": null
      },{
        "title": "BOJ 1719 택배",
        "excerpt":" BOJ 1719 택배    경로표는 한 집하장에서 다른 집하장으로 최단경로로 화물을 이동시키기 위해 가장 먼저 거쳐야 하는 집하장      접근하기    1. 플로이드 와샬 알고리즘으로 table구성  i -&gt; k -&gt; j 이면 a[i][j] = a[i][k]를 담으면 됨       TODO 코드 - 다익스트라     코드 - 플로이드 와샬    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N, M;  int dp[202][202]; int arr[202][202];  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; N &gt;&gt; M;      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             if (i != j) dp[i][j] = INF;             arr[i][j] = INF;         }     }      int a, b, c;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;         dp[a][b] = c;         dp[b][a] = c;         arr[a][b] = b;         arr[b][a] = a;     }      for(int k=1;k&lt;=N;k++) {         for(int i=1;i&lt;=N;i++) {             for(int j=1;j&lt;=N;j++) {                 if (dp[i][j] &gt; dp[i][k] + dp[k][j]) {                     dp[i][j] = dp[i][k] + dp[k][j];                     arr[i][j] = arr[i][k];                 }             }         }     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             if (arr[i][j] == INF )                 cout &lt;&lt; '-' &lt;&lt; \" \";             else                 cout &lt;&lt; arr[i][j] &lt;&lt; \" \";         }         cout &lt;&lt; '\\n';     }      return 0; }      문제 링크    https://www.acmicpc.net/problem/1719      풀이 해설    https://beginthread.tistory.com/63 https://ongveloper.tistory.com/181    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-1719/",
        "teaser": null
      },{
        "title": "BOJ 1956 운동",
        "excerpt":" BOJ 1956 운동     접근하기    플로이드 와샬 알고리즘에서 dp[2][2] = 2번에서 2번으로 이동하는 최단거리를 의미 -&gt; cycle       코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll;  #define INF 1e9  int V, E; int dp[401][401];  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; V &gt;&gt; E;     for(int i=1;i&lt;=V;i++) {         for(int j=1;j&lt;=V;j++) {             dp[i][j] = INF;                }     }      int p1, p2, cost;     for(int i=0;i&lt;E;i++) {         cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; cost;         dp[p1][p2] = cost;     }      for(int k=1;k&lt;=V;k++) {         for(int i=1;i&lt;=V;i++) {             for(int j=1;j&lt;=V;j++) {                 if (dp[i][j] &gt; dp[i][k] + dp[k][j]) {                     dp[i][j] = dp[i][k] + dp[k][j];                 }             }         }     }      int ans = INF;     for(int i=1;i&lt;=V;i++) {         ans = min(ans, dp[i][i]);      }     if (ans == INF)         cout &lt;&lt; -1 &lt;&lt; '\\n';     else         cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/1956    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-1956/",
        "teaser": null
      },{
        "title": "BOJ 2610 회의준비",
        "excerpt":" BOJ 2610 회의준비     접근하기        1-2-3     4-5-6-7     8  3개의 그룹이 생김 (그룹을 확인하기 - dfs/bfs/union-find)  각 그룹을 graph로 나타내고, 플로이드와샬로 최단거리를 구함.  다른 점과의 최대 거리가 가장 짧은 점을 골라야 한다.  다른 모든 점과의 최단거리를 구하는 문제가 아님(실수)       코드 - BFS + 플로이드 와샬    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 987654321  int N, M; int dp[101][101]; int vis[101]; vector&lt;int&gt; ans;     int bfs(int start, int vis[]) {     //cout &lt;&lt; \"[bfs]\\n\";      queue&lt;int&gt; q;     q.push(start);     vis[start] = 1;     int cnt = 0;     ans.push_back(start);     while(!q.empty()) {         int cur = q.front(); q.pop();         //cout &lt;&lt; cur &lt;&lt; '\\n';         cnt += 1;         for(int i=1;i&lt;=N;i++) {             if (dp[cur][i] != INF &amp;&amp; vis[i] == 0) {                 vis[i] = 1;                 q.push(i);                 ans.push_back(i);             }         }     }     return cnt; }  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); //    freopen(\"input2.txt\", \"r\", stdin); #endif     cin &gt;&gt; N;     cin &gt;&gt; M;      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             if (i!=j) dp[i][j] = INF;         }     }      int p1, p2;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; p1 &gt;&gt; p2;         dp[p1][p2] = 1;         dp[p2][p1] = 1;     }      for(int k=1;k&lt;=N;k++) {         for(int i=1;i&lt;=N;i++) {             for(int j=1;j&lt;=N;j++) {                 if (dp[i][j] &gt; dp[i][k] + dp[k][j]) {                     dp[i][j] = dp[i][k] + dp[k][j];                 }             }         }     }      vector&lt;int&gt; result;      for(int i=1;i&lt;=N;i++) {         ans.clear();         if (vis[i]) continue;         int ret = bfs(i, vis);         if (ret == 0) continue;         // 1 2 3         int mv = INF;         int mv_id = -1;         for(auto&amp; from:ans) {             int sum = 0;             for(int to=1;to&lt;=N;to++) {                 if (from != to &amp;&amp; dp[from][to] != INF) {                     // HINT : https://www.acmicpc.net/board/view/8953                     // &#47784;&#46304; &#52280;&#49437;&#51088;&#46308;&#51032; &#51032;&#49324;&#51204;&#45804;&#49884;&#44036;&#51473; &#52572;&#45824;&#44050;&#51060; &#52572;&#49548;&#44032; &#46104;&#46020;&#47197; &#54616;&#44592;                     //sum += dp[from][to];          // &#51060;&#47111;&#44172; &#54616;&#47732; &#53952;&#47548;                     sum = max(sum, dp[from][to]);                 }             }             if (mv &gt; sum) {                 mv = sum;                 mv_id = from;             }         }          if (mv_id != -1) result.push_back(mv_id);     }     cout &lt;&lt; result.size() &lt;&lt; '\\n';     sort(result.begin(), result.end());     for(auto &amp;o : result) {         cout &lt;&lt; o &lt;&lt; '\\n';     }     return 0; }       코드 - DFS + 플로이드 와샬    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 987654321  int N, M; int dp[101][101]; int vis[101]; vector&lt;int&gt; ans;     void dfs(int cur) {     vis[cur] = 1;     ans.push_back(cur);     for(int i=1;i&lt;=N;i++) {         if (dp[cur][i] != INF &amp;&amp; vis[i] == 0) {             dfs(i);         }     } }  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     cin &gt;&gt; M;      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             if (i!=j) dp[i][j] = INF;         }     }      int p1, p2;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; p1 &gt;&gt; p2;         dp[p1][p2] = 1;         dp[p2][p1] = 1;     }      for(int k=1;k&lt;=N;k++) {         for(int i=1;i&lt;=N;i++) {             for(int j=1;j&lt;=N;j++) {                 if (dp[i][j] &gt; dp[i][k] + dp[k][j]) {                     dp[i][j] = dp[i][k] + dp[k][j];                 }             }         }     }      vector&lt;int&gt; result;      for(int i=1;i&lt;=N;i++) {         ans.clear();         if (vis[i]) continue;         dfs(i);         if ((int)ans.size() == 0) continue;         // 1 2 3         int mv = INF;         int mv_id = -1;         for(auto&amp; from:ans) {             int sum = 0;             for(int to=1;to&lt;=N;to++) {                 if (from != to &amp;&amp; dp[from][to] != INF) {                     // HINT : https://www.acmicpc.net/board/view/8953                     // &#47784;&#46304; &#52280;&#49437;&#51088;&#46308;&#51032; &#51032;&#49324;&#51204;&#45804;&#49884;&#44036;&#51473; &#52572;&#45824;&#44050;&#51060; &#52572;&#49548;&#44032; &#46104;&#46020;&#47197; &#54616;&#44592;                     //sum += dp[from][to];          // &#51060;&#47111;&#44172; &#54616;&#47732; &#53952;&#47548;                     sum = max(sum, dp[from][to]);                 }             }             if (mv &gt; sum) {                 mv = sum;                 mv_id = from;             }         }          if (mv_id != -1) result.push_back(mv_id);     }     cout &lt;&lt; result.size() &lt;&lt; '\\n';     sort(result.begin(), result.end());     for(auto &amp;o : result) {         cout &lt;&lt; o &lt;&lt; '\\n';     }     return 0; }      코드 - UnionFind + 플로이드 와샬    #include &lt;bits/stdc++.h&gt; using namespace std; #define INF 987654321  int N, M; int dp[101][101]; int vis[101];  int Find(int a) {     if (vis[a] &lt; 0) return a;     return vis[a] = Find(vis[a]); }  void Union(int a, int b) {     a = Find(a);     b = Find(b);      if (a == b) return;      if (vis[a] &lt;= vis[b]) {         vis[a] += vis[b];         vis[b] = a;     } else {         vis[b] += vis[a];         vis[a] = b;     } }  int main(int argc, char* argv[]) {     cin &gt;&gt; N;     cin &gt;&gt; M;      for(int i=1;i&lt;=N;i++) {         vis[i] = -1;     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=N;j++) {             if (i!=j) dp[i][j] = INF;         }     }      int p1, p2;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; p1 &gt;&gt; p2;         dp[p1][p2] = 1;         dp[p2][p1] = 1;          Union(p1, p2);     }      for(int k=1;k&lt;=N;k++) {         for(int i=1;i&lt;=N;i++) {             for(int j=1;j&lt;=N;j++) {                 if (dp[i][j] &gt; dp[i][k] + dp[k][j]) {                     dp[i][j] = dp[i][k] + dp[k][j];                 }             }         }     }      vector&lt;int&gt; lst[101];     for(int i=1;i&lt;=N;i++) {         int k = Find(i);         lst[k].push_back(i);     }      vector&lt;int&gt; result;      for(int i=1;i&lt;=N;i++) {         if (lst[i].size() == 0) continue;         // 1 2 3         int mv = INF;         int mv_id = -1;         for(auto&amp; from:lst[i]) {             int sum = 0;             for(int to=1;to&lt;=N;to++) {                 if (from != to &amp;&amp; dp[from][to] != INF) {                     sum = max(sum, dp[from][to]);                 }             }             if (mv &gt; sum) {                 mv = sum;                 mv_id = from;             }         }          if (mv_id != -1) result.push_back(mv_id);     }     cout &lt;&lt; result.size() &lt;&lt; '\\n';     sort(result.begin(), result.end());     for(auto &amp;o : result) {         cout &lt;&lt; o &lt;&lt; '\\n';     }      return 0; }      문제 링크    https://www.acmicpc.net/problem/1956      디버깅 참고    https://www.acmicpc.net/board/view/8953    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-2610/",
        "teaser": null
      },{
        "title": "BOJ 11722 가장 긴 감소하는 부분 수열",
        "excerpt":" BOJ 11722 가장 긴 감소하는 부분 수열         접근하기    가장 긴 증가하는 부분수열 반대로 하기      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; int a[1010]; int dp[1010];  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      int ans = 1;     for(int i=1;i&lt;=N;i++) {         dp[i] = 1;         for(int j=1;j&lt;=i;j++) {             if (a[i] &lt; a[j] &amp;&amp; dp[i] &lt; dp[j] + 1) {                 dp[i] = dp[j] + 1;                 ans = max(ans, dp[i]);             }          }     }     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/11722    ","categories": [],
        "tags": ["DP"],
        "url": "/11722/",
        "teaser": null
      },{
        "title": "BOJ 11053 가장 긴 증가하는 부분 수열",
        "excerpt":" BOJ 11053 가장 긴 증가하는 부분 수열    dp로 LIS풀기      접근하기    DP로 풀기    10, 20, 10, 30, 20, 50  10 20 30 50 -&gt; 4개  다른 형태로도 가능함      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; int a[1010]; int dp[1010];  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      int ans = 1;       // &#52488;&#44592;&#44050;&#51012; 0&#51004;&#47196; &#54616;&#47732; WA     for(int i=1;i&lt;=N;i++) {         dp[i] = 1;         for(int j=1;j&lt;=i;j++) {             if (a[i] &gt; a[j] &amp;&amp; dp[i] &lt; dp[j] + 1) {                 dp[i] = dp[j] + 1;                 ans = max(ans, dp[i]);             }          }      }      cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/11053      LIS 알고리즘 해설    https://source-sc.tistory.com/14 https://jason9319.tistory.com/113    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-11053/",
        "teaser": null
      },{
        "title": "BOJ 11054 가장 긴 바이토닉 부분 수열",
        "excerpt":" BOJ 11054 가장 긴 바이토닉 부분 수열         접근하기    1. dp LIS 알고리즘으로 구한다.  왼쪽부터 오른쪽으로 한번 LIS - dp table 1  왼쪽에서부터 오른쪽으로 한번 LIS 적용 - dp table 2  ans = max(ans, dp1[k] + dp2[k] - 1)       코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL);  int N; int a[1010];  int dp1[1010] = {0,}; int dp2[1010] = {0,};  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif      cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      for(int i=1;i&lt;=N;i++) {         dp1[i] = 1;         for(int j=1;j&lt;=i;j++) {             if (a[j] &lt; a[i] &amp;&amp; dp1[i] &lt; dp1[j] + 1) {                 dp1[i] = dp1[j] + 1;             }         }     }      for(int i=N;i&gt;=1;i--) {         dp2[i] = 1;         for(int j=N;j&gt;=i;j--) {             if (a[j] &lt; a[i] &amp;&amp; dp2[i] &lt; dp2[j] + 1) {                 dp2[i] = dp2[j] + 1;             }         }     }      int ans = 0;     for(int i=1;i&lt;=N;i++) {         ans = max(ans, dp1[i] + dp2[i] - 1);     }     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/11054    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-11054/",
        "teaser": null
      },{
        "title": "BOJ 11055 가장 큰 증가 부분 수열",
        "excerpt":" BOJ 11055 가장 큰 증가 부분 수열    dp로 LIS풀기      접근하기    1 100 2 50 60 3 5 6 7 8  dp[i] : i까지의 가장큰 증가 부분 수열의 합     1    1      1 100    1 101    1 100 2    1  1  3    1 100 2 50    1  1  3 53    1 100 2 50 60              113    1 100 2 50 60 3    1     3       6    1 100 2 50 60 3 5    1     3       6 11    1 100 2 50 60 3 5 6    1     3       6 11 17    1 100 2 50 60 3 5 6 7 ...    1 100 2 50 60 3 5 6 7 8  가장 큰 값은 113     코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; int a[1010]; int dp[1010];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      int ans = a[1];     for(int i=1;i&lt;=N;i++) {         dp[i] = a[i];         for(int j=1;j&lt;=i;j++) {             if (a[i] &gt; a[j] &amp;&amp; dp[i] &lt; dp[j] + a[i]) {                 dp[i] = dp[j] + a[i];                 ans = max(ans, dp[i]);             }         }     }     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/11055    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-11055/",
        "teaser": null
      },{
        "title": "BOJ 11657 타임머신",
        "excerpt":" BOJ 11657 타임머신          접근하기    음의 간선이 있는 그래프의 최단거리 구하기 - 벨만포드 알고리즘  음의 cycle이 있는지 여부 파악이 가능함      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N, M; vector &lt; pair&lt; pair&lt;int, int &gt;, int&gt; &gt; edge; ll dp[501];  void bf() {     dp[1] = 0;      // &#49884;&#51089;&#51216;     for(int i=1;i&lt;=N-1;i++) {         for(auto&amp;o : edge) {             int from = o.first.first;             int to = o.first.second;             int cost = o.second;              if (dp[from] == INF) continue;             if (dp[to] &gt; dp[from] + cost) {                 dp[to] = dp[from] + cost;             }          }     } }  bool cycle_check() {     for(auto&amp;o : edge) {         int from = o.first.first;         int to = o.first.second;         int cost = o.second;          if (dp[from] == INF) continue;         if (dp[to] &gt; dp[from] + cost) {             dp[to] = dp[from] + cost;             return true;         }      }     return false; }  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N &gt;&gt; M;      for(int i=1;i&lt;=N;i++) {         dp[i] = INF;     }      int p1, p2, cost;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; cost;         edge.push_back({p1, p2}, cost);     }      bf();     if (cycle_check()) {         cout &lt;&lt; -1 &lt;&lt; '\\n';     } else {         for(int i=2;i&lt;=N;i++) {             if (dp[i] != INF)                 cout &lt;&lt; dp[i] &lt;&lt; '\\n';             else                 cout &lt;&lt; -1 &lt;&lt; '\\n';         }     }     return 0; }       문제 링크    https://www.acmicpc.net/problem/11657      이론해설    https://yabmoons.tistory.com/365 https://developer-davii.tistory.com/89    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-11657/",
        "teaser": null
      },{
        "title": "BOJ 1446 지름길",
        "excerpt":" BOJ 11657 지름길    다익스트라를 변형하는 문제 DP로 분류해도 좋을 문제      접근하기    dp[i] : 1~i까지의 제일 짦은 거리 (지름길)  1~D까지 loop {   dp[i] = min(dp[i], dp[i-1]+1, dp[지름길k.start] + 지름길k.end) }      코드 - vector    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 987654321  int N, D; typedef struct Node {     int s;     int e;     int c; } Node;  vector&lt; Node &gt; vec;  int dp[10010];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N &gt;&gt; D;     for(int i=0;i&lt;10010;i++) {         dp[i] = INF;     }      int p1, p2, cost;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; cost;         if (p2 &gt; D) continue;         if (p2 -p1 &lt; cost) continue;         vec.push_back({p1, p2, cost});     }      dp[0] = 0;      for(int i=1;i&lt;=D;i++) {         dp[i] = min(dp[i], dp[i-1] + 1);         for(auto o:vec) {             if (o.e == i &amp;&amp; dp[i] &gt; dp[o.s] + o.c)                 dp[i] = dp[o.s] + o.c;         }     }      cout &lt;&lt; dp[D] &lt;&lt; '\\n';     return 0; }       코드 - vector arr    i#include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 987654321  int N, D; typedef struct Node {     int s;     int c; } Node;  vector&lt; Node &gt; vec[10010];  int dp[10010];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N &gt;&gt; D;     for(int i=0;i&lt;10010;i++) {         dp[i] = INF;     }      int p1, p2, cost;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; cost;         if (p2 &gt; D) continue;         if (p2 -p1 &lt; cost) continue;         vec[p2].push_back({p1, cost});     }      dp[0] = 0;      for(int i=1;i&lt;=D;i++) {         dp[i] = min(dp[i], dp[i-1] + 1);         if (vec[i].size() != 0) {             for(auto o:vec[i]) {                 dp[i] = min(dp[i], dp[o.s] + o.c);             }         }     }      cout &lt;&lt; dp[D] &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/1446    ","categories": [],
        "tags": ["최단거리","DP"],
        "url": "/boj-1446/",
        "teaser": null
      },{
        "title": "BOJ 2740 행렬 곱셈",
        "excerpt":" BOJ 2740 행렬 곱셈    접근하기    행렬 곱셈 수학식을 2차원 배열로 코딩    A = 3 x 2   B = 2 x 3  C = 3 x 3 행렬이 된다.  y-&gt; A세로 = 3 x-&gt; B가로 = 3        코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N, M, K; int a[110][110]; int b[110][110]; int c[110][110];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N &gt;&gt; M;     for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=M;j++) {             cin &gt;&gt; a[i][j];         }     }      cin &gt;&gt; M &gt;&gt; K;     for(int i=1;i&lt;=M;i++) {         for(int j=1;j&lt;=K;j++) {             cin &gt;&gt; b[i][j];         }     }      for(int i=1;i&lt;=N;i++) {          // 1 ~ 3         for(int j=1;j&lt;=K;j++) {      // 1 ~ 3             for(int k=1;k&lt;=M;k++) {  // 1 ~ 2                 c[i][j] += a[i][k]*b[k][j];             }         }     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=K;j++) {             cout &lt;&lt; c[i][j] &lt;&lt; \" \";         }         cout &lt;&lt; '\\n';     }      return 0; }       문제 링크    https://www.acmicpc.net/problem/2740    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-2740/",
        "teaser": null
      },{
        "title": "BOJ 11568 민균이의 계략",
        "excerpt":" BOJ 11568 민균이의 계략    dp로 LIS풀기      접근하기     준민이가 제시해야하는 수열은 순증가여야 할 뿐만 아니라, 원소의 개수가 제일 많은 수열이여야 한다.  LIS(N) -&gt; 최대 길이       코드 - DP로 풀이    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  #define ARRSIZE 1010  ll N; ll a[ARRSIZE]; ll dp[ARRSIZE];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      for(int i=1;i&lt;=N;i++) {         dp[i] = 1;     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=i;j++) {             if (a[i] &gt; a[j] &amp;&amp; dp[i] &lt; dp[j] + 1) {                 dp[i] = dp[j] + 1;             }         }     }     ll ans = dp[1];     for(int i=1;i&lt;=N;i++) {         ans = max(ans, dp[i]);     }      cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       TODO 코드 - lower_bound로 풀이     문제 링크    https://www.acmicpc.net/problem/11568    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-11568/",
        "teaser": null
      },{
        "title": "BOJ 12355 Ocean View (Large)",
        "excerpt":" BOJ 12355 Ocean View (Large)    dp로 LIS풀기      접근하기     서쪽에 호수 동쪽에 Hill  4 5 6 1 7 1 2 3   4   LIS(N) = 4  N = 5  N-LIS(N) = 1      코드 - DP로 풀이    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  #define ARRSIZE 1010  ll N; ll a[ARRSIZE]; ll dp[ARRSIZE];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      for(int i=1;i&lt;=N;i++) {         dp[i] = 1;     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=i;j++) {             if (a[i] &gt; a[j] &amp;&amp; dp[i] &lt; dp[j] + 1) {                 dp[i] = dp[j] + 1;             }         }     }     ll ans = dp[1];     for(int i=1;i&lt;=N;i++) {         ans = max(ans, dp[i]);     }      cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       TODO 코드 - lower_bound로 풀이     문제 링크    https://www.acmicpc.net/problem/12355    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-12355/",
        "teaser": null
      },{
        "title": "BOJ 14231 박스 포장",
        "excerpt":" BOJ 14231 박스 포장    dp로 LIS풀기      접근하기    i앞에 있는 박스가 뒤에 있는 박스보다 작아야지만, 뒤에 있는 박스에 넣을 수 있다.  LIS(N) - N까지의 값이 증가하는 최대 수열  a[j] &lt; a[i] &amp;&amp; dp[i] &lt; dp[j] + 1   =&gt; dp[i] = dp[j] + 1      코드 - DP로 풀이    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  #define ARRSIZE 5050  ll N; ll a[ARRSIZE]; ll dp[ARRSIZE];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      for(int i=1;i&lt;=N;i++) {         dp[i] = 1;     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=i;j++) {             if (a[i] &gt; a[j] &amp;&amp; dp[i] &lt; dp[j] + 1) {                 dp[i] = dp[j] + 1;             }         }     }     ll ans = dp[1];     for(int i=1;i&lt;=N;i++) {         ans = max(ans, dp[i]);     }      cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       TODO 코드 - lower_bound로 풀이     문제 링크    https://www.acmicpc.net/problem/14231    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-14231/",
        "teaser": null
      },{
        "title": "BOJ 16466 콘서트",
        "excerpt":" BOJ 16466 콘서트    1번부터 N번까지 표가 팔렸을 때, 가장 작은 안팔린 표의 번호 구하기      접근하기    5 1 2 3 4 5  출력 : 6 &lt;- 틀리기 쉬운 반례      코드 2    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; int a[1000010]; int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; a[i];     }     sort(a, a+N);     int num = 1;     for(int i=0;i&lt;N;i++) {         if (a[i] != num) {             cout &lt;&lt; num &lt;&lt; '\\n';              return 0;         }         num += 1;     }     cout &lt;&lt; num &lt;&lt; '\\n';      return 0; }      코드 1    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; set&lt;ll&gt; sp; int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     ll a;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; a;         sp.insert(a);     }      long long num = 1;     for(auto&amp; o :sp) {         if (num != o) {             cout &lt;&lt; num &lt;&lt; '\\n';             return 0;         } else {             num += 1;         }     }     cout &lt;&lt; num &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/16466    ","categories": [],
        "tags": ["STL"],
        "url": "/boj-16466/",
        "teaser": null
      },{
        "title": "BOJ 17216 가장 큰 감소 부분 수열",
        "excerpt":" BOJ 17216 가장 큰 감소 부분 수열     접근하기    가장 큰 증가 부분 수열 코드를 반대로 구현      코드 2    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; ll a[1010]; ll dp[1010];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      for(int i=1;i&lt;=N;i++) {         dp[i] = a[i];         for(int j=1;j&lt;=i;j++) {             if (a[i] &lt; a[j] &amp;&amp; dp[i] &lt; dp[j] + a[i]) {                 dp[i] = dp[j] + a[i];             }         }     }      ll ans = dp[1];     for(int i=1;i&lt;=N;i++) {         ans = max(ans, dp[i]);     }     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/17216    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-17216/",
        "teaser": null
      },{
        "title": "BOJ 18353 병사배치하기",
        "excerpt":" BOJ 18353 병사 배치하기    dp로 LIS풀기      접근하기    N = 전체 병사의 수  값이 연속적으로 감소하는 최대 길이 = LIS(N)  열외해야할 병사의 수 = N - LIS(N)     코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  #define ARRSIZE 2020  ll N; ll a[ARRSIZE]; ll dp[ARRSIZE];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      for(int i=1;i&lt;=N;i++) {         dp[i] = 1;     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=i;j++) {             if (a[i] &lt; a[j] &amp;&amp; dp[i] &lt; dp[j] + 1) {                 dp[i] = dp[j] + 1;             }         }     }     ll ans = dp[1];     for(int i=1;i&lt;=N;i++) {         ans = max(ans, dp[i]);     }     cout &lt;&lt; N - ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/18353    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-18353/",
        "teaser": null
      },{
        "title": "BOJ 2004 조합",
        "excerpt":" BOJ 2004 조합    접근하기    2, 5의 승수를 센다      코드 1    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N, M;  int power2(int num) {     int ret = 0;     while(num &gt;=2) {         ret += num / 2;         num = num / 2;     }     return ret; }  int power5(int num) {     int ret = 0;     while(num &gt;=5) {         ret += num / 5;         num = num / 5;     }     return ret; }   int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N &gt;&gt; M;     int n1 = power2(N) - power2(N-M) - power2(M);     int n2 = power5(N) - power5(N-M) - power5(M);     cout &lt;&lt; min(n1, n2) &lt;&lt; '\\n';     return 0; }      코드 2    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  ll N, M;  ll cnt2(ll num) {     ll sum = 0;     for(ll i=2;i&lt;=num;i*=2) {         sum += num / i;     }     return sum; }  ll cnt5(ll num) {     ll sum = 0;     for(ll i=5;i&lt;=num;i*=5) {         sum += num / i;     }     return sum; }  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N &gt;&gt; M;     // N!     // (N-M)!     // M!     ll n1 = cnt2(N) - cnt2(N-M) - cnt2(M);     ll n2 = cnt5(N) - cnt5(N-M) - cnt5(M);      cout &lt;&lt; min(n1, n2) &lt;&lt; '\\n';      return 0; }       해설 참고    https://st-lab.tistory.com/166 https://sihyungyou.github.io/baekjoon-2004/     문제 링크    https://www.acmicpc.net/problem/2004    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-2004/",
        "teaser": null
      },{
        "title": "BOJ 20162 간식 파티",
        "excerpt":" BOJ 20162 간식 파티    dp로 LIS풀기      접근하기    서울이는 전에 먹었던 간식보다 더 맛있는 간식만 먹는다  5 4 5 1 2 3  4 먹고 5를 먹어서 9가 만족의 최대  누적값이 최대가 되는 LIS(N) 문제     코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  #define ARRSIZE 1010  ll N; ll a[ARRSIZE]; ll dp[ARRSIZE];  int main(int argc, char* argv[]) {     FASTIO     cin &gt;&gt; N;     for(int i=1;i&lt;=N;i++) {         cin &gt;&gt; a[i];     }      for(int i=1;i&lt;=N;i++) {         dp[i] = a[i];     }      for(int i=1;i&lt;=N;i++) {         for(int j=1;j&lt;=i;j++) {             if (a[i] &gt; a[j] &amp;&amp; dp[i] &lt; dp[j] + a[i]) {                 dp[i] = dp[j] + a[i];             }         }     }     ll ans = dp[1];     for(int i=1;i&lt;=N;i++) {         ans = max(ans, dp[i]);     }      cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/20162    ","categories": [],
        "tags": ["DP"],
        "url": "/boj-20162/",
        "teaser": null
      },{
        "title": "BOJ 2981 검문",
        "excerpt":" BOJ 2981 검문    접근하기    A = aM + r B = bM + r C = cM + r ...  B - A = (b - a)xM      (r이 소거됨) C - B = (c - b)xM      (r이 소거됨) ...  gcd( B-A, C-B, D-C, ...) -&gt;최대공약수  최대공약수의 약수 -&gt; 공약수의 목록     코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; int a[110];  int gcd(int a, int b) {     if (b == 0)         return a;     else         return gcd(b, a%b); }  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     //freopen(\"input.txt\", \"r\", stdin);     freopen(\"input2.txt\", \"r\", stdin); #endif     cin &gt;&gt; N;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; a[i];     }     sort(a, a+N);      int cur = a[1] - a[0];     for(int i=2;i&lt;N;i++) {         cur = gcd(cur, a[i] - a[i-1]);     }      set&lt;int&gt; sp;     for(int i=2;i*i&lt;=cur;i++) {         if (cur%i == 0) {             sp.insert(i);             sp.insert(cur/i);         }     }     sp.insert(cur);     for(auto o:sp) {         cout &lt;&lt; o &lt;&lt; \" \";     }     cout &lt;&lt; '\\n';     return 0; }       해설 참고    https://kjwan4435.tistory.com/59      문제 링크    https://www.acmicpc.net/problem/2981    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-2981/",
        "teaser": null
      },{
        "title": "약수 출력하기",
        "excerpt":" 약수 출력하기     접근하기    N = 100 이면 1 ~ 100으로 %했을 때 0이 나오면 약수  N의 제곱근까지 나눈다.   - 1 ~ N의 제곱근    - k 추가, N/k 추가    - ...  1 2 4 5 10 20 25 50 100      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL);  int N;  int main(int argc, char* argv[]) {     FASTIO     set &lt;int&gt; sp;     cin &gt;&gt; N;     for(int i=1;i*i &lt;= N;i++) {         if (N %i == 0) {             sp.insert(i);             sp.insert(N/i);         }     }      for(auto o:sp) {         cout &lt;&lt; o &lt;&lt; '\\n';     }     return 0; }       설명    https://kbw1101.tistory.com/32      문제 링크    http://220.89.64.243/30stair/factor/factor.php?pname=factor    ","categories": [],
        "tags": ["DSA","수학"],
        "url": "/dsa-math-divisor/",
        "teaser": null
      },{
        "title": "BOJ 6118 숨바꼭질",
        "excerpt":" BOJ 6118 숨바꼭질     접근하기    edge에 가중치가 없는 graph에서의 최단거리 -&gt; BFS 가장 먼 거리에 있는 번호 가장 먼 거리의 길이 값 가장 먼 거리를 공통으로 가진 노드의 수  다익스트라로 푼 코드가 많음      코드 - BFS    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N, M;  vector &lt;int&gt; G[20020]; int vis[20020];  void bfs(int start) {     queue&lt;int&gt; q;     q.push(start);      vis[start] = 1;      while(!q.empty()) {         int cur = q.front(); q.pop();          for(auto next:G[cur]) {             if (vis[next] == 0) {                 vis[next] = vis[cur] + 1;                             q.push(next);             }         }             } }  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; N &gt;&gt; M;     int p1, p2;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; p1 &gt;&gt; p2;         G[p1].push_back(p2);         G[p2].push_back(p1);     }     bfs(1);     int maxv = 0;     int maxv_idx = 0;     for(int i=1;i&lt;=N;i++) {         if (maxv &lt; vis[i]) {             maxv = vis[i];             maxv_idx = i;         }     }     int ans = 0;     for(int i=1;i&lt;=N;i++) {         if (vis[i] == maxv)             ans++;      }      cout &lt;&lt; maxv_idx &lt;&lt; \" \";     cout &lt;&lt; maxv - 1 &lt;&lt; \" \";     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       TODO 코드 - 다익스트라     문제 링크    https://www.acmicpc.net/problem/6118    ","categories": [],
        "tags": ["최단거리"],
        "url": "/boj-6118/",
        "teaser": null
      },{
        "title": "abc238 B - Pizza",
        "excerpt":" B - Pizza     접근하기    피자를 회전(시계방향)해서 12시 방향에서 cut하기는 생각하기 어렵다.  이미 cut되어 있는 방향을 돌린다고 생각(반시계방향)  처음 위치 ang[0] = 1  ang[0 + p1] = 1  ang[0 + p1 + p2] = 1   ...  (0 + p1 + p2 ...) % 360을 하면, 원래 위치를 넘어서 cut할 수 있다.  1인 두 점 사이의 거리가 가장 큰 것을 구해서 출력x      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; int ang[360];  int main(int argc, char* argv[]) {     FASTIO      ang[0] = 1;      cin &gt;&gt; N;     int cur = 0;     int num;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; num;         cur += num;         cur = cur % 360;    // &#50896;&#54805;&#51004;&#47196; &#46028;&#47532;&#45716; &#44163; 360 -&gt; 0         ang[cur] = 1;     }      int prev = 0;     int ans = 0;     for(int i=1;i&lt;=360;i++) {         if (ang[i%360] != 0) {             ans = max(ans, i - prev);             prev = i;         }     }     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }        문제 링크    https://atcoder.jp/contests/abc238/tasks/abc238_b    ","categories": [],
        "tags": ["수학"],
        "url": "/abc-b-upsolving/",
        "teaser": null
      },{
        "title": "BOJ 2357 농구 골대 세우기",
        "excerpt":" BOJ 2357 농구 골대 세우기    X축으로 위치를 늘어놓고 가운데 고르기 Y축으로 위치를 늘어놓고 가운데 고르기  모든 마을에서 합이 최소화되는 위치임       접근하기    1, 2, 3, 4, 5   N=5일 때의 중앙값은?  1, 2, 3, 4      N=4일 때의 중앙값은? -&gt; (2+3)/2를 해줘야 한다.  하지만, 문제의 조건에서 좌표가 작은쪽을 고르라고 함. -&gt; 중앙값에서 작은쪽 찾기    문제의 조건에서 pi가 1000까지여서 100000*1000을 생각했는데, 메모리가 넘침 10000001 까지만 해주면 accept가 된다.      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N;  int x[1000001]; int y[1000001];  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; N;      int p1, p2;     int cnt;     int idx=0;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; cnt;         for(int j=idx;j&lt;idx+cnt;j++) {             x[j] = p1;             y[j] = p2;         }         idx += cnt;     }      sort(x, x+idx);     sort(y, y+idx);      // &#51473;&#50521;&#44050;      // 1 2 3 4 5 -&gt; &#54848;&#49688;&#44060;, N=5     // (N+1)/2 - 1 =&gt; 2     // 1 2 3 4 -&gt; &#51677;&#49688;&#44060;, N=4     // (N)/2 - 1 =&gt; 1      if (idx %2 != 0) idx += 1;     cout &lt;&lt; x[idx/2 -1] &lt;&lt; \" \" &lt;&lt; y[idx/2 -1] &lt;&lt; '\\n';     return 0; }       해설 참고    https://boomrabbit.tistory.com/88     문제 링크    https://www.acmicpc.net/problem/2375    ","categories": [],
        "tags": ["수학,","중앙값"],
        "url": "/boj-2375/",
        "teaser": null
      },{
        "title": "vim에서 template.cpp코드 불러오기",
        "excerpt":" 용도    BOJ 문제 풀때 vim에서 사용      사용법    파일이 열린 상태에서 ,tt를 입력하면, 모든 파일 내용을 지우고, template를 로딩      vim에서 ,tt 키 입력으로 template code로딩    ~/.vimrc에 다음 줄을 추가   map ,tt &lt;ESC&gt;: 1,$ d &lt;ESC&gt;:r ~/template.cpp &lt;CR&gt; 1Gdd &lt;CR&gt;    mapp ,tt 로 매핑한다. esc : 명령 모드로 기존에 버퍼 내용을 모두 지운다. ( 1, $ d) esc :명령 모드로 ~/template.cpp를 로드한다. CR (리턴 입력) 1Gdd : 1번 줄로 이동하고, 줄을 지우기 (공백이 생겨서 지움)      template.cpp    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N;  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif      return 0; }     ","categories": [],
        "tags": ["vim"],
        "url": "/vim-cpp-template/",
        "teaser": null
      },{
        "title": "BOJ 14400 편의점 2",
        "excerpt":" BOJ 14400 편의점 2    접근하기    n명의 주요 고객들의 위치 (xi,yi)이 주어질 때, 모든 고객들의 거리 합을 최소로 하는 위치에 편의점을 세우는 위치  -&gt; 중앙값(median)의 점을 찾는다.      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N;  int x[100000]; int y[100000];  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; N;     for(int i=0;i&lt;N;i++) {         cin &gt;&gt; x[i] &gt;&gt; y[i];     }      sort(x, x+N);     sort(y, y+N);     int x1 = 0;     int y1 = 0;     if (N%2 == 1) {          x1 = x[N/2];          y1 = y[N/2];      } else {         x1 = (x[N/2 - 1] + x[N/2]) / 2;          y1 = (y[N/2 - 1] + y[N/2]) / 2;      }     ll ans = 0;     for(int i=0;i&lt;N;i++) {         ans += abs(x1 - x[i]) + abs(y1 - y[i]);     }     cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }        수학/중앙값 설명    https://mathbang.net/116      문제 링크    https://www.acmicpc.net/problem/14400    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-14400/",
        "teaser": null
      },{
        "title": "BOJ 1213 팰린드롬 만들기",
        "excerpt":" BOJ 1213 팰린드롬 만들기    접근하기     1) 팰린드롬 가능여부 확인 문자열의 길이가 짝수일때, 모든 문자가 짝수이어야 팰린드롬 가능 문자열의 길이가 홀수일 때, 홀수에서 한글자를 뺀 나머지 문자가 짝수여야 팰린드롬 가능  -&gt; 뺀 문자가 가운데록 가야함  2) 사전순으로 배열 - 우선순위 queue에 넣어서 맨앞과 맨뒤에 번갈아가며 추가하도록 함       코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N; char str[60]; char a[60]; char table[26]; int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE //    freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; str;      int len = 0;     for(len=0;str[len];len++) {         table[(int)str[len] - 'A'] += 1;     }     int oddcnt = 0;     for(int i=0;i&lt;26;i++) {         if (table[i] == 0) continue;         if (table[i]%2 == 1) oddcnt += 1;      }      if (oddcnt &gt; 1) {         cout &lt;&lt; \"I'm Sorry Hansoo\" &lt;&lt; '\\n';         return 0;     }      priority_queue &lt; char, vector&lt;char&gt;, greater&lt;char&gt; &gt; pq;     char mid = 0;     for(int i=0;i&lt;26;i++) {         if (table[i] == 0) continue;         if (table[i]%2 == 1) {             mid = i + 'A';             table[i]--;             if (table[i]) {                 for(int j=0;j&lt;table[i];j++) {                     pq.push(i + 'A');                 }             }         } else {             for(int j=0;j&lt;table[i];j++) {                 pq.push(i + 'A');             }         }     }      int cnt = 0;     int lidx = 0;     int ridx = 0;     while(!pq.empty()) {         char cur = pq.top(); pq.pop();          if((++cnt)%2 != 0) {             a[lidx] = cur;             lidx++;         } else {             ridx++;             a[len - ridx] = cur;         }     }      if (len%2 == 1) {         a[len/2] = mid;     }     a[len] = '\\0';     cout &lt;&lt; a &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/1213    ","categories": [],
        "tags": ["수학","구현"],
        "url": "/boj-1213/",
        "teaser": null
      },{
        "title": "BOJ 14496 그대 그머가 되어",
        "excerpt":" BOJ 14496 그대 그머가 되어    접근하기    BFS로 최단거리      TODO 코드 - 다익스트라로 풀이    cost를 1로 주변 다익스트라로 풀이 가능함      코드 - BFS로 풀이    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int A, B; int N, M;  vector&lt;int&gt; G[1001]; int vis[1001];  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     //freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; A &gt;&gt; B;     cin &gt;&gt; N &gt;&gt; M;      int p1, p2;     for(int i=0;i&lt;M;i++) {         cin &gt;&gt; p1 &gt;&gt; p2;         G[p1].push_back(p2);         G[p2].push_back(p1);     }      queue&lt;int&gt; q;     q.push(A);      vis[A] = 1;      while(!q.empty()) {         int cur = q.front(); q.pop();          for(auto next:G[cur]) {             if (!vis[next]) {                 vis[next] = vis[cur] + 1;                 q.push(next);             }         }     }      if (vis[B]) {         cout &lt;&lt; vis[B] - 1 &lt;&lt; '\\n';     } else {         cout &lt;&lt; -1 &lt;&lt; '\\n';     }      return 0; }       문제 링크    https://www.acmicpc.net/problem/14496      풀이참고    다익스트라 - https://codecollector.tistory.com/953    ","categories": [],
        "tags": ["BFS"],
        "url": "/boj-14496/",
        "teaser": null
      },{
        "title": "BOJ 20155 우리 집 밑에 편의점이 있는데",
        "excerpt":" BOJ 20155 우리 집 밑에 편의점이 있는    접근하기    최빈값을 구하는 문제      코드    #include &lt;bits/stdc++.h&gt; using namespace std; #define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL); typedef long long ll; #define INF 1e9  int N, M; int a[1010];  int main(int argc, char* argv[]) {     FASTIO #ifndef ONLINE_JUDGE     freopen(\"input.txt\", \"r\", stdin); #endif     cin &gt;&gt; N &gt;&gt; M;     int num;              for(int i=0;i&lt;N;i++) {         cin &gt;&gt; num;         a[num] += 1;     }     cout &lt;&lt; *max_element(a, a+N) &lt;&lt; '\\n';     return 0; }       문제 링크    https://www.acmicpc.net/problem/20155    ","categories": [],
        "tags": ["수학"],
        "url": "/boj-20155/",
        "teaser": null
      },{
        "title": "abc239 C - Night Fork",
        "excerpt":" C - Knight Fork     접근하기    x1, y1을 기준으로 -2 ~ +2 범위만큼을 완전탐색 x2, y2에서는 그 안에 들어오게된다.      코드    #include &lt;bits/stdc++.h&gt; using namespace std; typedef long long ll;  ll calc(int x1, int y1, int x2, int y2) {     return abs(x1 - x2) * abs(x1 - x2) + abs(y1 - y2) * abs(y1 - y2); }  int main(int argc, char* argv[]) {     ll x1, y1;     ll x2, y2;     cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;      string ans = \"No\";     for(int y=y1-2;y&lt;=y1+2;y++) {         for(int x=x1-2;x&lt;=x1+2;x++) {             if ( calc(x1, y1, x, y) == calc(x2, y2, x, y) &amp;&amp; calc(x1, y1, x, y) == 5) {                 ans = \"Yes\";             }         }      }      cout &lt;&lt; ans &lt;&lt; '\\n';     return 0; }       문제 링크    https://atcoder.jp/contests/abc239/tasks/abc239_c    ","categories": [],
        "tags": ["AtCoder"],
        "url": "/abc239-c-upsolving/",
        "teaser": null
      },{
        "title": "Language Reactor Chrome 플러그인",
        "excerpt":" Language Reactor    https://chrome.google.com/webstore/detail/language-reactor/hoombieeljmmljlkjmnheibnpciblicm?hl=ko Youtube로 영여공부하기 좋게 자막을 보여준다. 설치 완료      사용법 가이드    https://nekrataa.tistory.com/93        영어자막 + manual 한글자막     Youtuber recommendations for LEARNING ENGLISH    https://www.youtube.com/watch?v=I3fSIbyyj28      “영어 브이로그” 로 영어회화 깨기✨ | How to improve spoken English with vlogs    https://www.youtube.com/watch?v=K4-8BCn61pc      The Ultimate Notion Tour    https://www.youtube.com/watch?v=abpFmOu1eHk       영어자막 + auto 한글자막     How I Organize My Life with Notion (school, youtube, life)    https://www.youtube.com/watch?v=eEX1RDs-lTs&amp;t=77s      \"아마존 프라임 1위\" 교도소에 간 전직 특수 요원(결말포함)    https://www.youtube.com/watch?v=c8kJ3mKapAc        유튜브 추천     WanderJess    https://www.youtube.com/c/WanderJess재이     Briddy li    https://youtube.com/c/BeautybyBriddy      Ur mom ashely    https://youtube.com/c/urmomashley      Oh no nina    https://youtube.com/c/ohnonina      Michelle choi    https://youtube.com/user/michellechoii      Jenn Im    https://youtube.com/c/clothesencounters      Jessica vu    https://youtube.com/c/JessicaVu      Yoora Jung    https://youtube.com/c/Yoora     ","categories": [],
        "tags": ["영어공부"],
        "url": "/language-reactor-chrome/",
        "teaser": null
      },{
        "title": "STL set에 struct pointer 이용",
        "excerpt":" STL set에 struct pointer    객체풀을 이용해서 포인터를 넣기    #include &lt;map&gt; #include &lt;set&gt; #include &lt;iostream&gt; #include &lt;utility&gt; using namespace std;  typedef struct Node {     int id;     int score; } Node;  Node pool[1000]; int idx;  Node* CreateNode(int id, int score) {     Node* ptr = &amp;pool[idx++];     ptr-&gt;id = id;     ptr-&gt;score = score;     return ptr; }  // Node*&#47484; &#51077;&#47141;&#51004;&#47196; &#48155;&#45716; Compare struct &#47564;&#46308;&#44592; struct Compare {     bool operator()(Node* a, Node* b) {         return a-&gt;score &lt; b-&gt;score;     } };  // Compare &#44061;&#52404; &#45347;&#44592;, 1&#48264;&#51704;&#47196; Node* multiset&lt;Node*, Compare&gt; s      insert하기    Node* ptr = CreateNode(id, score); s.insert(ptr);       find &amp; erase &amp; size    if (s.find(ptr) != s.end()) {    // erase    s.erase(ptr);     // size    if (s.size()) {       min / max 구하기    https://www.geeksforgeeks.org/find-maximum-and-minimum-element-in-a-set-in-c-stl/      lower bound 구하기    tmp.score = score; tmp.id = 0;  auto it = s.lower_bound(&amp;tmp); if (it != s.end()) {  // (*it)-&gt;score // (*it)-&gt;id     ","categories": [],
        "tags": ["STL"],
        "url": "/stl-set-with-struct/",
        "teaser": null
      }]
