#+HTML: ---
#+HTML: title: BOJ 11657 타임머신
#+HTML: tags: 최단거리
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 11657 타임머신
- 

** 접근하기
#+BEGIN_EXAMPLE
음의 간선이 있는 그래프의 최단거리 구하기 - 벨만포드 알고리즘

음의 cycle이 있는지 여부 파악이 가능함
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;
#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL);
typedef long long ll;
#define INF 1e9

int N, M;
vector < pair< pair<int, int >, int> > edge;
ll dp[501];

void bf()
{
    dp[1] = 0;      // 시작점
    for(int i=1;i<=N-1;i++) {
        for(auto&o : edge) {
            int from = o.first.first;
            int to = o.first.second;
            int cost = o.second;

            if (dp[from] == INF) continue;
            if (dp[to] > dp[from] + cost) {
                dp[to] = dp[from] + cost;
            } 
        }
    }
}

bool cycle_check()
{
    for(auto&o : edge) {
        int from = o.first.first;
        int to = o.first.second;
        int cost = o.second;

        if (dp[from] == INF) continue;
        if (dp[to] > dp[from] + cost) {
            dp[to] = dp[from] + cost;
            return true;
        } 
    }
    return false;
}

int main(int argc, char* argv[])
{
    FASTIO
    cin >> N >> M;
    
    for(int i=1;i<=N;i++) {
        dp[i] = INF;
    }

    int p1, p2, cost;
    for(int i=0;i<M;i++) {
        cin >> p1 >> p2 >> cost;
        edge.push_back({p1, p2}, cost);
    }

    bf();
    if (cycle_check()) {
        cout << -1 << '\n';
    } else {
        for(int i=2;i<=N;i++) {
            if (dp[i] != INF)
                cout << dp[i] << '\n';
            else
                cout << -1 << '\n';
        }
    }
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/11657

** 이론해설
- https://yabmoons.tistory.com/365
- https://developer-davii.tistory.com/89
