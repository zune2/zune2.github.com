#+HTML: ---
#+HTML: title: BOJ 11966 2의 제곱인가?
#+HTML: tags: 비트연산
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 11966 2의 제곱인가?

** 접근하기
- N의 음수는 2의 보수인 성질을 이용하기
#+BEGIN_EXAMPLE
N = 8        -N = 8의 2의보수

1000 -> 0111 (1의보수) -> 1000 (2의보수)

N & (-N) == N  --> 2의 제곱수 
#+END_EXAMPLE

- N & N-1 == 0이면 2의 보수인 성질 이용하기
#+BEGIN_EXAMPLE
N = 8     N-1=7
  1000
  0111
 ------
  0000

N & (N-1) == 0   --> 2의 제곱수
#+END_EXAMPLE
** 코드1
#+BEGIN_SRC cpp
#include <stdio.h>

int N;

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    if (0 == (N & (N-1)))
        printf("1\n");
    else
        printf("0\n");
    return 0;
}
#+END_SRC

** 코드2
#+BEGIN_SRC cpp
#include <stdio.h>

int N;

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    if (N == (N & -N)) // -N : N의 2의 보수
        printf("1\n");
    else
        printf("0\n");
    return 0;
}
#+END_SRC


** 문제 링크
- https://www.acmicpc.net/problem/11966
