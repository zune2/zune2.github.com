#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 2638 치즈
#+HTML: tags: BFS
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 2638 치즈
- 바깥 공기와 안쪽 공기로 나뉨
- 바깥 공기 2개 이상 인접하면, 치즈를 없앰

** 접근하기
#+BEGIN_EXAMPLE
1. 바깥을 0 -> 3으로 처음에 변경
2. 1을 만나면 2개의 3이 있는지 check하고 vector에 저장
#+END_EXAMPLE

** 코드 - 606 m/s - 느린 구현
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;

int N, M;
int a[101][101];

typedef struct Node {
    int y;
    int x;
} Node;

int dy[4] = {1, -1, 0, 0};
int dx[4] = {0, 0, 1, -1};

bool safe(int y, int x)
{
    return (0<=y && y<N) && (0<=x && x<M);
}

void fill_outside(int y, int x)
{
    int visited[101][101] = {0, };
    queue<Node> q;
    q.push({y,x});
    visited[y][x] = 1;    
    a[y][x] = 2;
    while(!q.empty()) {
        Node cur = q.front(); q.pop();
        for(int i=0;i<4;i++) {
            int ny = cur.y + dy[i];
            int nx = cur.x + dx[i];

            if (safe(ny, nx) && visited[ny][nx] == 0 && a[ny][nx] == 0) {
                visited[ny][nx] = 1;
                a[ny][nx] = 2; 
                q.push({ny, nx});
            }
        }
    }
}

bool touch_two(int y, int x)
{
    int visited[101][101] = {0, };
  
    visited[y][x] = 1;

    int cnt = 0;
    for(int i=0;i<4;i++) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if (safe(ny, nx) && visited[ny][nx] == 0 && a[ny][nx] == 2) {
            visited[ny][nx] = 1;
            cnt += 1;                
        }
    }
    
    return (cnt >= 2);
}

int main(int argc, char* argv[])
{
    scanf("%d %d", &N, &M);
    
    int total = 0;
    for(int i=0;i<N;i++) {
        for(int j=0;j<M;j++) {
            scanf("%d", &a[i][j]);
            if (a[i][j]) total += 1;
        }
    }
    fill_outside(0, 0);
    int time = 0;
    while(total) {

        vector<Node> v;
        for(int i=0;i<N;i++) {
            for(int j=0;j<M;j++) {
                if (a[i][j] == 1) {
                    int ret = touch_two(i, j);
                    if (ret) v.push_back({i,j});
                }
            }
        }

        for(auto o:v) {
            if (a[o.y][o.x] == 1) {
                a[o.y][o.x] = 2;
                fill_outside(o.y, o.x);
                total--;
            } 
        }

        time += 1;    
        dbg();
    }
    printf("%d\n", time);
    return 0;
}
#+END_SRC


** TODO 코드 - 시간 최적화 할 것

** 문제 링크
- https://www.acmicpc.net/problem/2638
