#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 20040 사이클 게임
#+HTML: tags: UnionFind
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 20040 사이클 게임
- Union Find를 이용해서 cycle을 탐지하는 문제

** 접근하기
#+BEGIN_EXAMPLE
union(a, b) : a점과 b점을 연결하는 것을 의미

Find(a) == Find(b) -> 선분이 이미 연결되어 있음

Find(a) != Find(b) -> 선분이 연결되어 있지 않음 
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <cstdio>

int N, M;
int p[500010];

int Find(int a)
{
    if (p[a] < 0) return a;
    return p[a] = Find(p[a]);
}

void Union(int a, int b)
{   
    a = Find(a);
    b = Find(b);

    if (a != b) {
        if (p[a] < p[b]) {
            p[a] += p[b];
            p[b] = a;
        } else {
            p[b] += p[a];
            p[a] = b;            
        }
    }
}

void uf_init(int n)
{
    for(int i=0;i<=n ;i++) {
        p[i] = -1;
    }
}

int main(int argc, char* argv[])
{
    freopen("input2.txt", "r", stdin);
    scanf("%d %d", &N, &M);
    uf_init(N);
    int p1, p2;
    int ans = 0;
    for(int i=0;i<M;i++) {
        scanf("%d %d", &p1, &p2);
        p1++;
        p2++;
        int parent1 = Find(p1);
        int parent2 = Find(p2);

        if (parent1 != parent2) {
            Union(p1, p2);
        } else {
            ans = i + 1; 
            printf("%d\n", ans);            
            return 0;
        }
    }
    printf("%d\n", ans);
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/20040
