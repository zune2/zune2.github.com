#+HTML: ---
#+HTML: title: BOJ 11403 이항계수 3
#+HTML: tags: 수학
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 11401 이항계수 3
- N이 400만에서 이항계수 구하기
- dp를 쓸 수 없음

** 접근하기
- 페르마의 소정리 이용

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>

#define MOD 1000000007
typedef long long ll;


ll factorial(ll num)
{
	long long ans = 1;
	for(int i=2;i<=num;i++) {
		ans = (ans * i) % MOD;
	}
	return ans;
}

// 분할정복 recursive로 pow구하기
ll pow(ll base, ll m)
{
	if (m == 0 ) return 1;
	if (m == 1) return base % MOD;

	ll half = pow(base, m/2) % MOD;

	if (m %2 != 0) {
		return (half * half) % MOD * base % MOD;
	} else {
		return (half * half) % MOD;
	}
}

ll N, K;

int main(int argc, char* argv[])
{
	scanf("%lld %lld", &N, &K);
	ll ans = factorial(N)%MOD * pow(factorial(K)%MOD * factorial(N-K)%MOD, MOD-2)%MOD;
	printf("%lld\n", ans);
	return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/11401

** 참고링크 (수학적 설명)
- https://st-lab.tistory.com/241 
