#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 2309 일곱 난쟁이
#+HTML: tags: 완전탐색 Bitmask
#+HTML: ---
#+OPTIONS: ^:nil

** 일곱 난쟁이
- bit를 이용한 power set을 이용해서 반복함
- 완전탐색으로 조합순서를 만들기 가능
  - 가지치기를 적용해볼 수 있음
- sum - 100이 되도록 두 수를 찾아도 됨

** bitmask 이용 powerset 
  
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int a[9];
int b[9];

int main(int argc, char* argv[])
{
    freopen("input.txt", "r", stdin);
    for(int i=0;i<9;i++) {
        scanf("%d", &a[i]);
    }
    sort(a, a+9);
    for(int i=0;i<(1<<9);i++) {
        
        int sum = 0;
        int cnt = 0;
        for(int j=0;j<9;j++) {
            if (i & (1<<j)) {
                sum += a[j]; 
                cnt += 1;
            }
        }

        if (cnt == 7 && sum == 100) {
            for(int j=0;j<9;j++) {
                if (i & (1<<j)) {
                    printf("%d\n", a[j]);
                }
            }
            goto exit;
        }
    } 
exit: 
    return 0;
}
#+END_SRC

** 완전탐색 + quicksort 구현
#+BEGIN_SRC cpp
#include <cstdio>

int a[9];
int b[9];
int visit[9];

int ans = 0;

int partition(int a[], int left, int right)
{
	int pivot = left;
	int i = left-1;
	int j = right+1;

	while(1)
	{
		do {
			i++;
		} while (a[i] < a[pivot]);

		do {
			j--;
		} while (a[j] > a[pivot]);

		if (i>=j)	return j;

		int t = a[i];
		a[i] = a[j];
		a[j] = t;
	}
	return j;
}

void quicksort(int a[], int left, int right)
{
	if (left < right) {
		int p = partition(a, left, right);
		quicksort(a, left, p);
		quicksort(a, p+1, right);
	}
}

int bt(int k, int sum) {
	if ( ans ) return 0;
	if ( sum > 100) return 0;
	if (7 == k) {
		if (sum == 100) {
			quicksort(b, 0, 6);
			for(int i=0; i<7;i++) {
				printf("%d\n", b[i]);
			}
			ans = 1;
		}
		return 0;
	}

	for(int i=0;i<9;i++) {
		if (visit[i] == 0) {
			visit[i] = 1;
			b[k] = a[i];
			bt(k+1, sum+a[i]);
			visit[i] = 0;

		}
	}
	return 0;
}

int main(int argc, char* argv[])
{
	for(int i=0;i<9;i++) {
		scanf("%d", &a[i]);
	}
	bt(0, 0);
	return 0;
}
#+END_SRC
** powerset이용 bactracking + bound이용 최적화
- powerset을 구하는 bactracking코드
- 100보다 크면 제외하기
- 앞으로 나올값과 현재값을 더했을때 100이 될 가능성이 없으면 제외

#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int a[9];
int b[9];
int run;

void f(int idx, int sum, int remaining, int cnt)
{
    if (run == 0) return;
    if (sum > 100) return;  // 100보다 크면, 제외
    if (sum + remaining < 100) return;   // 현재 + 앞으로 가능한 값이 100보다 작으면 제외

    if (idx == 9) {
        if (cnt == 7 && sum == 100) {
            sort(b, b+9);
            for(int i=0;i<9;i++) {
                if (b[i]) printf("%d\n", b[i]);
            }
            run = 0;
        }
        return;
    }

    b[idx] = 0;
    f(idx+1, sum, remaining, cnt);

    b[idx] = a[idx];
    f(idx+1, sum + a[idx], remaining - a[idx], cnt + 1);
}

int main(int argc, char* argv[])
{
    int sum = 0;
    for(int i=0;i<9;i++) {
        scanf("%d", &a[i]);
        sum += a[i];
    }

    run = 1;
    f(0, 0, sum, 0);
    return 0;
}
#+END_SRC
** TODO 두수를 뺐을 때, 100이 되게하는 목록 만들기
- 이중 loop에서 두 숫자 x, y를 구함
- sum - x - y == 100이면, 전체 목록에서 x, y를 제거하고 출력하기

** TODO sort하고, 두 수를 찾기
- 두수의 합이 sum - 100이 되도록 하는 두 수 찾기
- 알고리즘 이름이 뭐였더라?

** 참고자료
- [[https://mygumi.tistory.com/361][비트마스크(BitMask) 는 무엇인가?]]

** 문제 링크
- https://www.acmicpc.net/problem/2309

