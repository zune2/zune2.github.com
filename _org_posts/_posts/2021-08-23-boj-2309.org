#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 2309 일곱 난쟁이
#+HTML: tags: 완전탐색 Bitmask
#+HTML: ---
#+OPTIONS: ^:nil

** 일곱 난쟁이
- bit를 이용한 power set을 이용해서 반복함

- 완전탐색으로 조합순서를 만들기 가능

** bitmask 이용 powerset 
   
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int a[9];

#if 0
void dec2bin(unsigned int num)
{
    for(int i=31;i>=0;i--) {
        if ( (num & (1U << (unsigned int)i)) ) {
            printf("1");
        } else {
            printf("0");
        }
    }
    printf("\n");
}
#endif

int main(int argc, char *argv[])
{
    for(int i=0;i<9;i++) {
        scanf("%d", &a[i]);    
    }
    sort(a, a+9);

    for(unsigned int i=0; i<(1<<9);i++)  {
        int total = 0;
        int cnt = 0;
        for(unsigned int j=0;j<9;j++) {
            if( (i & (1<<j))){
                total += a[j]; 
                cnt += 1;
            }
        }
        if (total == 100 && cnt == 7) {
            for(unsigned int j=0;j<9;j++) {
                if( (i & (1<<j))){
                    printf("%d\n", a[j]);
                }
            }
            break;
        }
    }
    return 0;
}
#+END_SRC

** 완전탐색 + quicksort 구현
#+BEGIN_SRC cpp
#include <cstdio>

int a[9];
int b[9];
int visit[9];

int ans = 0;

int partition(int a[], int left, int right)
{
	int pivot = left;
	int i = left-1;
	int j = right+1;

	while(1)
	{
		do {
			i++;
		} while (a[i] < a[pivot]);

		do {
			j--;
		} while (a[j] > a[pivot]);

		if (i>=j)	return j;

		int t = a[i];
		a[i] = a[j];
		a[j] = t;
	}
	return j;
}

void quicksort(int a[], int left, int right)
{
	if (left < right) {
		int p = partition(a, left, right);
		quicksort(a, left, p);
		quicksort(a, p+1, right);
	}
}

int bt(int k, int sum) {
	if ( ans ) return 0;
	if ( sum > 100) return 0;
	if (7 == k) {
		if (sum == 100) {
			quicksort(b, 0, 6);
			for(int i=0; i<7;i++) {
				printf("%d\n", b[i]);
			}
			ans = 1;
		}
		return 0;
	}

	for(int i=0;i<9;i++) {
		if (visit[i] == 0) {
			visit[i] = 1;
			b[k] = a[i];
			bt(k+1, sum+a[i]);
			visit[i] = 0;

		}
	}
	return 0;
}

int main(int argc, char* argv[])
{
	for(int i=0;i<9;i++) {
		scanf("%d", &a[i]);
	}
	bt(0, 0);
	return 0;
}
#+END_SRC
** powerset이용 bactracking + bound이용 최적화
- powerset을 구하는 bactracking코드
- 100보다 크면 제외하기
- 앞으로 나올값과 현재값을 더했을때 100이 될 가능성이 없으면 제외

#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int a[9];
int b[9];
int run;

void f(int idx, int sum, int remaining, int cnt)
{
    if (run == 0) return;
    if (sum > 100) return;  // 100보다 크면, 제외
    if (sum + remaining < 100) return;   // 현재 + 앞으로 가능한 값이 100보다 작으면 제외

    if (idx == 9) {
        if (cnt == 7 && sum == 100) {
            sort(b, b+9);
            for(int i=0;i<9;i++) {
                if (b[i]) printf("%d\n", b[i]);
            }
            run = 0;
        }
        return;
    }

    b[idx] = 0;
    f(idx+1, sum, remaining, cnt);

    b[idx] = a[idx];
    f(idx+1, sum + a[idx], remaining - a[idx], cnt + 1);
}

int main(int argc, char* argv[])
{
    int sum = 0;
    for(int i=0;i<9;i++) {
        scanf("%d", &a[i]);
        sum += a[i];
    }

    run = 1;
    f(0, 0, sum, 0);
    return 0;
}
#+END_SRC
** 참고자료
- [[https://mygumi.tistory.com/361][비트마스크(BitMask) 는 무엇인가?]]

** 문제 링크
- https://www.acmicpc.net/problem/2309

