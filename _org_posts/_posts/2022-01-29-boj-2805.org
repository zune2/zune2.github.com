#+HTML: ---
#+HTML: title: BOJ 2805 나무자르기
#+HTML: tags: 이분탐색
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 2805 나무 자르기

** 접근하기
#+BEGIN_SRC 
이분탐색

- 톱의 높이를 up -> 나무가 줄어듬
- 톱의 높이를 down -> 나무가 많아짐

- down <-  톱의 높이 --> up
-    T T T T T F F F F F

- 조건을 만족하는 가장 높은 높이
#+END_SRC
** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>

typedef long long ll;
int N, M;
int a[1000010];

bool check(int height)
{
    ll cnt = 0; // int이면 WA
    for(int i=0;i<N;i++) {
        int namu = a[i] - height;
        if (namu > 0) cnt += namu;
    }

    return (cnt >= M);
}

int main(int argc, char* argv[])
{
    scanf("%d %d", &N, &M);
    int mv = 0;
    for(int i=0;i<N;i++) {
        scanf("%d", &a[i]);
        if (mv < a[i]) mv = a[i];
    }

    int s = 0;
    int e = mv; 

    int ans = 0;
    while(s + 1 < e) {
        int mid = (s + e) / 2;

        if (check(mid)) {
            //printf("%d\n", mid);
            ans = mid;
            s = mid;
        } else {
            e = mid;
        }
    }
    printf("%d\n", ans);

    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/2805


** 해설 참고
- https://www.acmicpc.net/blog/view/109
