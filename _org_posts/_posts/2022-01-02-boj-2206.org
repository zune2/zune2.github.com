#+HTML: ---
#+HTML: title: BOJ 2206 벽 부수고 이동하기
#+HTML: tags: bfs 그래프
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 2206 벽 부수고 이동하기
- NxM 맵에서 0은 이동 가능하다. 0, 0 에서 N-1, M-1로 이동하는 최단거리 구하기
- 이 때, 한번은 벽(1)을 부수고 이동할 수 있다.

** 접근하기
#+BEGIN_EXAMPLE
visit[y][x][2]로 확장
 0 : (y, x)에 0인 상태로 방문, 기존에 벽을 부수거나 안 부수거나 상관없이 진행
 1 : (y, x)에 1인 상태로 방문, 앞으로는 벽을 부술 수 없음
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <queue>
using namespace std;

int N, M;

#define SIZE 1010

int map[SIZE][SIZE];
int visit[SIZE][SIZE][2];

typedef struct Node {
    int y;
    int x;
    int broke;
    int dist;
} Node;

Node start;
Node dest;

int dy[4] = {1, -1, 0, 0};
int dx[4] = {0, 0, 1, -1};

bool safe(int y, int x)
{
    return (0<=x && x<M) && (0<=y && y<N);
}
int ans;
void bfs()
{
    queue<Node> q;
    visit[0][0][0] = 1;
    q.push({0, 0, 0, 1}); 

    while(!q.empty()) {
        Node cur = q.front(); q.pop();
        
        if (cur.y == dest.y && cur.x == dest.x) {
            ans = cur.dist;
            return;
        }
        for(int i=0;i<4;i++) {
            int ny = cur.y + dy[i];
            int nx = cur.x + dx[i];
            int broke = cur.broke;
            int dist = cur.dist;
            if (safe(ny, nx)) {
                if (map[ny][nx] == 0 && !visit[ny][nx][broke]) {
                    visit[ny][nx][broke] = 1;
                    q.push({ny, nx, broke, dist + 1});
                } else if (map[ny][nx] == 1 && broke == 0) {
                    visit[ny][nx][1] = 1;
                    q.push({ny, nx, 1, dist + 1});
                }
            }
        }
    }
}

int main(int argc, char* argv[])
{
    ans = -1;
    scanf("%d %d", &N, &M);
    char str[1010];
    for(int i=0;i<N;i++) {
        scanf("%s", str);
        for(int j=0;str[j];j++) {
            map[i][j] = str[j] - '0';
        }
    }

    start.y = 0;
    start.x = 0;
    
    dest.y = N-1;
    dest.x = M-1;

    bfs();
    printf("%d\n", ans);
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/2206

** 풀이/해설참고
- https://yabmoons.tistory.com/73
