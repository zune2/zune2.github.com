#+HTML: ---
#+HTML: title: BOJ 7795 먹을 것인가 먹힐 것인가
#+HTML: tags: STL 이분탐색
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 7795 먹을 것인가 먹힐 것인가?
- lower bound를 적용하는 문제
- 잘 떠오르지 않는다.

** 접근하기
- 이중 loop로 찾을 수 있지만 느릴 것.
- lower bound : K보다 같거나 큰 값이 처음으로 나타나는 위치

- 1번째 예제
#+BEGIN_EXAMPLE
A = {8, 1, 7, 3, 1}
sort(B) = {1, 3, 6}

lower_bound(B, 8) = B의 마지막 주소 - B시작주소 = 3
lower_bound(B, 1) = B시작 주소 - B시작주소 = 0
lower_bound(B, 7) = B마지막 주소 - B시작주소 = 3
lower_bound(B, 3) = 3의 위치 - B시작주소 = 1
lower_bound(B, 1) = B시작 주소 - B시작주소 = 0

3 + 0 + 3 + 1 + 0 = 7
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;

int T;
int N, M;

int a[20020];
int b[20020];

void solve()
{
    scanf("%d %d", &N, &M);
    
    for(int i=0;i<N;i++) {
        scanf("%d", &a[i]);
    }
    for(int i=0;i<M;i++) {
        scanf("%d", &b[i]);
    }

    sort(b, b+M);

    int sum = 0;
    for(int i=0;i<N;i++) {
        auto it = lower_bound(b, b+M, a[i]);
        sum += (int)(it - b);
    }
    cout << sum << endl;
}

int main(int argc, char* argv[])
{
    scanf("%d", &T);    

    for(int tc=1;tc<=T;tc++) {
        solve();
    }
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/7795
