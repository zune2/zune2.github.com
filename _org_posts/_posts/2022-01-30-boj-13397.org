#+HTML: ---
#+HTML: title: BOJ 13397 구간 나누기 2
#+HTML: tags: 이분탐색
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 13397 구간 나누기 2

** 접근하기
#+BEGIN_SRC 
이분탐색 이용

mid : 구간 점수의 최대값과 최소값 차이

이 값보다 크면 구간을 나눔. - check 함수로 구현
#+END_SRC

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;

int N, M;
int a[5050];

#define INF 987654321

bool check(int mid)
{
    int cnt = 1;
    int minv = a[0];
    int maxv = a[0];

    for(int i=1;i<N;i++) {
        
        maxv = max(maxv, a[i]);
        minv = min(minv, a[i]);
        if (maxv - minv > mid) {
            cnt += 1;

            minv = a[i];
            maxv = a[i];
        }
    }

    return cnt <= M;
}

int main(int argc, char* argv[])
{
    scanf("%d %d", &N, &M);

    for(int i=0;i<N;i++) {
        scanf("%d", &a[i]);
    }

    int s = -1;
    int e = 10000;

    while(s + 1 < e) {
        int mid = (s + e)/2;
        if (check(mid)) {
            e = mid;      // 구간의 점수의 최댓값의 최솟값
        } else {
            s = mid; 
        }
    }
    printf("%d\n", e);
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/13397
