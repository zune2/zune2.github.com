#+HTML: ---
#+HTML: title: BOJ 11660 구간 합 구하기 5
#+HTML: tags: DP 누적합
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 11660 구간 합 구하기 5

** 접근하기
- 누적합 자체가 DP 점화식으로 표현된다.

#+BEGIN_EXAMPLE
1 2 3 4     (1)   3    6  (10)
2 3 4 5      3    8   15   24
3 4 5 6     (6)  15   27   42
4 5 6 7     10   24   42   64

42 - 10 - 6 + 1 = 27 

1은 가로/세로가 공유하므로 두번 더한 셈
한번 빼줘야 함.
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <cstdio>

int dp[1026][1026];
int N, M;

int main(int argc, char* argv[])
{
    scanf("%d %d", &N, &M);

    int val;
    for(int i=1;i<=N;i++) {
        for(int j=1;j<=N;j++) {
            scanf("%d", &val);
            dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + val; 
        }        
    }

    int x1, y1, x2, y2;
    for(int i=0;i<M;i++) {
        scanf("%d %d %d %d", &y1, &x1, &y2, &x2);
        printf("%d\n", dp[y2][x2] - dp[y2][x1-1] - dp[y1-1][x2] + dp[y1-1][x1-1]);
    }   
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/11660
