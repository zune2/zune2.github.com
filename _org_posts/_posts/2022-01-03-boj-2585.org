#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 2585 경비행기
#+HTML: tags: 이분탐색 bfs
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 2585 경비행기
- 출발지 S에서 목적지 S로 중간 주유소를 거쳐서 갈 때, K번 이하로 갈 수 있으면, 최소 연료통 크기 구하기
- 직선거리를 기준으로 하고, 연료통 크기 x 10만큼의 거리를 감

** 접근하기
#+BEGIN_EXAMPLE
1. 연료통 크기를 이분탐색 0~ (0,0) ~ (10000, 10000)까지의 거리
2. mid값을 이용해서 bfs
   - 시작점부터 끝점까지 가지는지 반복한다.
   - N이 1000정도로 작음, 매번 N번씩 loop돌면서, 다음 방문 위치를 찾기
   - visit배열을 이용해서, 이미 방문한 곳은 제외
#+END_EXAMPLE

** 코드 - binsearch recursive - memo 적용 (28 -> 12)
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;

int N, K;
#define SIZE 1010

typedef struct Node {
    int y;
    int x;
} Node;

Node a[SIZE];
int visited[SIZE];

int memo[SIZE][SIZE]; // 28 m/s -> 12 m/s

int calc_oil(int idx1, int idx2)
{
    if (memo[idx1][idx2]) return memo[idx1][idx2];

    int dist = ceil(sqrt(pow(a[idx2].x - a[idx1].x, 2) 
                + pow(a[idx2].y - a[idx1].y, 2)));
    if(dist % 10 == 0){
        return memo[idx1][idx2] = dist/10;
    } else {
        return memo[idx1][idx2] = dist/10+1;
    }
}

typedef struct Point {
    int idx;	// 현재 위치
    int cnt;	// 시작점부터 몇번 갈아탔는지
} Point;

int bfs(int tongkgi)
{
    for(int i=0;i<N;i++) visited[i] = 0;
    queue<Point> q;

    q.push({0,0});	// index, 중간급유 횟수
    visited[0] = 1;
    while(!q.empty()) {
        Point cur = q.front(); q.pop();

        if (calc_oil(cur.idx, N-1) <= tongkgi)
            return 1;
        if (cur.cnt > K) return 0;
        for(int next=1;next<N-1;next++) {
            if (!visited[next] && calc_oil(cur.idx, next) <= tongkgi) {
                visited[next] = 1;
                q.push({next, cur.cnt + 1});
            }
        }
    }
    return 0;
}

int ans = 0;
void binary_search(int left, int right)
{
    if (left > right) return;
    int mid = (left + right) / 2;

    if (bfs(mid) != 0) {
        ans = mid;
        binary_search(left, mid-1);
    } else {
        binary_search(mid+1, right);		
    }
}

int main(int argc, char* argv[])
{
    freopen("input.txt", "r", stdin);
    scanf("%d %d", &N, &K);

    // 중간 비행장 입력
    for(int i=1;i<=N;i++) {
        scanf("%d %d", &a[i].x, &a[i].y);
    }	
    a[0].y = 0;
    a[0].x = 0;

    a[N+1].y = 10000;
    a[N+1].x = 10000;
    N = N + 2;	

    binary_search(0, 14143);
    printf("%d\n", ans);
    return 0;
}

// 14143은 (0, 0) ~ (10000, 10000)까지의 직선거리
// math.sqrt(pow(10000, 2) + pow(10000, 2))                                                         
// 14142.13562373095 -> 14143
#+END_SRC



** 코드 - binsearch iterative - memo 적용 (12 -> 8)
#+BEGIN_SRC cpp
void binary_search(int left, int right)
{
    while(left <= right)
    {
        int mid = (left + right) / 2;
        if (bfs(mid) != 0) {
            ans = mid;
            right = mid - 1;
        } else {
            left = mid + 1;
        }	
    }
}
#+END_SRC


** 문제 링크
- https://www.acmicpc.net/problem/2585
