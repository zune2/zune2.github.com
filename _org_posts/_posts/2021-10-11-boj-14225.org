#+HTML: ---
#+HTML: title: BOJ 14225 부분수열의 합
#+HTML: tags: 완전탐색
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 14225


** 접근하기
- 완전탐색 tree를 재귀로 구현함
- check배열에 진입한 상태에 1로 체크
- 1~부터 200만을 loop돌며, 처음 false위치 출력 
** 코드
#+BEGIN_SRC cpp
#include <cstdio>
using namespace std;

int N;
int a[21];
int b[2000010];

void bt(int k, int sum)
{
    b[sum] = 1;

    if (k == N) {
        return;
    }
    bt(k+1, sum);
    bt(k+1, sum + a[k]);
}

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    for(int i=0;i<N;i++) {
        scanf("%d", &a[i]);
    }

    bt(0, 0);

    for(int i=1;i<2000010;i++) {
        if (b[i] == 0) {
            printf("%d\n", i);
            break;
        }
    }
    return 0;
}
#+END_SRC

** TODO 생각
- DP style로 좀 더 최적화해서 풀 수 있을 듯 싶다.

** 문제 링크
- https://www.acmicpc.net/problem/14225
