#+HTML: ---
#+HTML: title: BOJ 9440 숫자 더하기
#+HTML: tags: 그리디
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 9440 숫자 더하기
- 한자리 숫자 2~14개를 주고, 두 숫자를 만들어서 더할 때, 가장 작은 수 만들기

** 접근하기
- 완전 탐색으로 풀어서 시간초과를 받음

- 최소 힙에서 숫자를 하나씩 빼서, 숫자 배열을 만들기
- 0이 여러개일 때 예외처리를 해줘야 한다.
  - 0이 짝수개일 때
  - 0이 홀수개일 때

- 문제가 되는 testcase를 찾기 어렵다.

#+BEGIN_EXAMPLE
문제 case : 1 9 0 0 0 0 0 0 0 0 0 0 0

0 0 0 0 0 0 1
0 0 0 0 0 9

1 0 0 0 0 0 0  <- 0을 앞에 넣어준다.
  9 0 0 0 0 0

1 9 0 0 0 0 0
#+END_EXAMPLE
** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
#include <queue>

using namespace std;
int N;
int main(int argc, char* argv[])
{
    priority_queue<char, vector<char>, greater<char>> pq;
    while(1) {
        scanf("%d", &N);
        if (N == 0) break;

        int zero = 0;
        char num;
        for(int i=0;i<N;i++) {
            scanf(" %c", &num);
            if (num == '0') zero += 1;
            pq.push(num);
        }
        char a[2][14] = {0};
        int cnt[2] = {0};

        int idx = 0;
        char backup;

        // zero가 1이 아닌 홀수개이면, 하나를 빼서 a[0]로 보내기
        if ( zero != 1 && zero %2 == 1) {
            backup = pq.top(); pq.pop();
            a[0][cnt[0]++] = backup; 
        }

        while(!pq.empty()) {
            char val = pq.top(); pq.pop();
            a[idx%2][cnt[idx%2]++] = val; 
            idx++;
        }
        
        for(int k=0;k<2;k++) {
            for(int i=0;i<cnt[k];i++) {
                if (a[k][0] == '0' && a[k][i] != '0') {
                    char tmp = a[k][0];
                    a[k][0] = a[k][i];
                    a[k][i] = tmp;
                    break;
                }
            }
        }

        int ans[2] = {0,};
        for(int k=0;k<2;k++) {
            for(int i=0;i<cnt[k];i++) {
                ans[k] = ans[k] * 10 + (a[k][i] - '0');
            }
        }
        printf("%d\n", ans[0]+ans[1]);
    }
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/9440

** TC 참고
- https://kwanghyuk.tistory.com/76
