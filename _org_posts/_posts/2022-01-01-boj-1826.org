#+Html: ---
#+HTML: layout: post
#+HTML: title: BOJ 1826 연료 채우기
#+HTML: tags: 그리디
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 1826 연료 채우기
- N개의 주유소가 거리별로 주어짐. 주유소마다 다른 양의 기름 넣을 수 있음
** 접근하기
#+BEGIN_EXAMPLE
cnt             1               2           3
일직선  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
주유소          4 2             5          10                            10
연료   10                    0
                             4           0              0
                            {2}         {2}            10
                                                       {2}
cnt = 3

P < L 인 조건동안 반복

   1. 연료를 넣지 않아도, 10까지 갈 수 있음. 10안에 4, 2만큼 기름을 채울 수 있음

   2. 위치10에서 4를 넣는다. (max heap을 이용해서, 큰 값을 꺼냄 -> +4를 함)

   3. 14까지 갈 수 있음. 11위치의 주유소 5의 값을 pq에 추가 pq = (5, 2) ->5 꺼냄

   4. 19까지 갈 수 있음. 15위치의 주유소 10의 값을 pq에 추가 pq = (10, 2) -> 10 꺼냄

   - 예외처리 : P < L조건인데, pq가 비어있으면 도착할 수 없음

#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;
int N;

// first : num
// second : gas
typedef pair<int, int> Node;

Node a[10010];      // 주유소
int L, P;

int main(int argc, char* argv[])
{
    freopen("input.txt", "r", stdin);
    scanf("%d", &N);
    for(int i=0;i<N;i++) {
        scanf("%d %d", &a[i].first, &a[i].second);
    }
    scanf("%d %d", &L, &P);
    sort(a, a+N);

    priority_queue<int> pq; // max heap

    int idx = 0;
    int cnt = 0;
    while(P < L) { // 기름(P)가 도착지(L)보다 작은 동안
        while(a[idx].first <= P && idx < N) {
            pq.push(a[idx].second);
            idx++;
        }

        if (pq.empty()) {
            cnt = -1;
            break;
        }
        cnt += 1;
        P += pq.top(); pq.pop();
    }
    printf("%d\n", cnt);
    return 0;
}
#+END_SRC


** 문제 링크
- https://www.acmicpc.net/problem/1826

** 풀이 참고
- https://jason9319.tistory.com/228
