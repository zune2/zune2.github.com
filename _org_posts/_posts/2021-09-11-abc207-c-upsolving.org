#+HTML: ---
#+HTML: layout: post
#+HTML: title: abc207 C - Many Segments
#+HTML: tags: AtCoder
#+HTML: ---
#+OPTIONS: ^:nil

** C - Many Segments

** 접근하기
- l, r 중에서 r로 sort함
- 구간이 서로 겹치는 곳을 찾아서 count하기

** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int N;

typedef struct Node
{
    int p1;
    int on1;
    int p2;
    int on2;
} Node;

Node pool[2020];

bool comp(Node& before, Node& after)
{
    return (before.p2 - after.p2) < 0;
}

int main(int argc, char* argv[])
{
    scanf("%d", &N);

    int cmd, p1, p2;
    for(int i=0;i<N;i++) {
        scanf("%d %d %d",&cmd, &p1, &p2);
        pool[i].p1 = p1; 
        pool[i].p2 = p2; 
        switch(cmd)
        {
        case 1:
            pool[i].on1 = 1; 
            pool[i].on2 = 1; 
            break;
        case 2:
            pool[i].on1 = 1; 
            pool[i].on2 = 0; 
            break;
        case 3:
            pool[i].on1 = 0; 
            pool[i].on2 = 1; 
            break;
        case 4:
            pool[i].on1 = 0; 
            pool[i].on2 = 0; 
            break;
        }
    }
    sort(pool, pool+N, comp);
    
    int ans = 0;
    for(int i=0;i<N;i++) {
        for(int j=i+1;j<N;j++) {
            if (i == j) continue;
            if (pool[i].p2 > pool[j].p1) {
                ans++;
            } else if (pool[i].p2 == pool[j].p1 && pool[i].on2 == 1 && pool[j].on1 == 1) {
                ans++;
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
#+END_SRC

** 문제 링크
- https://atcoder.jp/contests/abc207/tasks/abc207_c
