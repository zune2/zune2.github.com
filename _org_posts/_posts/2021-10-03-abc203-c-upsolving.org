#+HTML: ---
#+HTML: layout: post
#+HTML: title: abc203 C - Friends and Travel costs
#+HTML: tags: AtCoder
#+HTML: ---
#+OPTIONS: ^:nil

** C - Friends and Travel cost
- 0번에서 K만큼의 돈을 가지고 이동
- A번 노드에서 B만큼의 돈을 보충 가능
- 노드 하나 이동할 때, 1씩 비용 듬
- 얼마나 갈 수 있을까? 

** 접근하기
- 0번에서 A번 노드까지의 거리보다 현재 가진돈이 많거나 같아야 이동
- 마지막 노드에 왔을때, 돈이 남았으면, 돈 만큼 더 이동 가능
- 하나의 노드에서 여러번 돈을 보충할 수 있는 것에 주의

** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int N, K;

typedef struct Node {
    long long A;
    long long B;
} Node;

Node pool[200020];

bool cmp(Node& p1, Node& p2)
{
    return (p1.A < p2.A);
}

int main(int argc, char* argv[])
{
    scanf("%d %d", &N, &K);

    for(int i=0;i<N;i++) {
        scanf("%lld %lld", &pool[i].A, &pool[i].B);
    }
    sort(pool, pool+N, cmp);

    long long pos = 0;
    long long coin = K;
    for(int i=0;i<N;i++) {
        if (coin - (pool[i].A - pos) >= 0) {
            coin -= (pool[i].A - pos);
            pos += (pool[i].A - pos);
            coin += pool[i].B;
        } else {
            break;
        }
    }
    printf("%lld\n", pos + coin);
    return 0;
}
#+END_SRC

** 문제 링크
- https://atcoder.jp/contests/abc203/tasks/abc203_c
