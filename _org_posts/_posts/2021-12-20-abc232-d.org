#+HTML: ---
#+HTML: layout: post
#+HTML: title: D - Weak Takhashi
#+HTML: tags: AtCoder Graph
#+HTML: ---
#+OPTIONS: ^:nil

** TODO D - Weak Takahashi
- HxW 크기의 배열에 .빈공간과 #막힌곳이 있을때, 1,1에서 얼마나 많이 움직일 수 있는지 세기
** 접근하기
- BFS를 이용해서 풀이함
- dp style의 bottom up으로 풀이 가능할 것
** 코드1 - BFS
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

int H, W;
int map[110][110];
int visit[110][110];

typedef struct Node {
    int y;
    int x;
    int len;
} Node;

bool safe(int y, int x)
{
    return (0<=x && x<W) && (0<=y && y<H);
}

int main(int argc, char* argv[])
{
    scanf("%d %d", &H, &W);
    char str[110];
    for(int i=0;i<H;i++) {
        scanf("%s", str);        

        for(int j=0;str[j];j++) {
            if (str[j] == '.') {
                map[i][j] = 0;
            } else if (str[j] == '#') { 
                map[i][j] = 1;
            }
        }
    }

    queue<Node> q;
    q.push({0, 0, 1}); 
    visit[0][0] = 1;

    int ans = 0;
    while(!q.empty()) {
        Node cur = q.front(); q.pop();
        ans = cur.len;
        if (safe(cur.y, cur.x + 1) && map[cur.y][cur.x + 1] == 0 && visit[cur.y][cur.x + 1] == 0) {
            visit[cur.y][cur.x + 1] = 1;
            q.push({cur.y, cur.x + 1, cur.len+1});
        }

        if (safe(cur.y+1, cur.x) && map[cur.y + 1][cur.x] == 0 && visit[cur.y + 1][cur.x] == 0) {
            visit[cur.y + 1][cur.x] = 1; 
            q.push({cur.y+1, cur.x, cur.len+1});
        }
    }
    printf("%d\n", ans);
    return 0;
}
#+END_SRC

** TODO 코드2 - DP style?

** 문제 링크
- https://atcoder.jp/contests/abc232/tasks/abc232_d

