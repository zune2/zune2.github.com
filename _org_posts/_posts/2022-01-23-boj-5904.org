#+HTML: ---
#+HTML: title: BOJ 5904 Moo 게임
#+HTML: tag: 분할정복
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 5904 Moo 게임
- 생각을 많이 하게 만드는 문제

** 접근하기
#+BEGIN_EXAMPLE

Moo
Moo Moo o Moo
...

이렇게 확장되는 규칙에서 N이 주어질 때, N번째 문자 맞추기


1. 분할정복 style풀기 - recursive
2. iterative로 풀기

#+END_EXAMPLE

** 코드 - recursive style
#+BEGIN_SRC cpp
#include <bits/stdc++.h>

int N;
char str[4] = {'m', 'o', 'o', '\0'};

void f(int n, int k, int len)
{
    if (n<=3) {
        printf("%c\n", str[n-1]);
        return;
    }

    int new_len = len*2 + (3 + k);
    
    if (n > new_len) {
        f(n, k+1, new_len);
    } else { // n <= new_len
        if (n > len && n<= (len + k + 3)) {
            if (n - len == 1)
               printf("m\n"); 
            else
               printf("o\n"); 
            return ;
        } else {
            f(n - (len + k + 3), 1, 3);
        }   
    }
}

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    f(N, 1, 3);
    return 0;
}
#+END_SRC

** 코드 - iteratvie style
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
int N;

int main(int argc, char* argv[])
{
    scanf("%d", &N);

    int new_len = 3;
    int mid_len = 3;

    while(new_len < N) {
        new_len = new_len*2 + (++mid_len);
    }

    while(1) {
        int size = (new_len - mid_len) / 2;
        // 1st
        if (size >= N) {
            mid_len--;
            new_len = size;
        } else if (size + mid_len < N) {
            N = N - (size + mid_len);
            mid_len--;
            new_len = size;
        } else {
            N = N - size;
            break;
        }
        // 3rd
    }
    
    if (N == 1) 
        printf("m\n");
    else
        printf("o\n");
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/5904

** 풀이참고
- https://david0506.tistory.com/68
- https://bconfiden2.tistory.com/277
