#+HTML: ---
#+HTML: title: BOJ 9205 맥주 마시면서 걸어가기
#+HTML: tags: dfs 그래프
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 9205 맥주 마시면서 걸어가기
- 출발지점, 중간지점여러개, 도착지점을 갈 때, 각 점마다 1000이하의 비용만 이동가능
- 도착 가능한지 출력

** 접근하기
#+BEGIN_EXAMPLE
1. 집 -> 편의점1 -> 편의점2 -> ... -> 편의점N -> 목적지

2. 편의점 개수가 100개이므로, O(N^2)으로 순서대로 연결함 (distance가 1000이하인 경우)
   -> 인접 list를 구성함

3. dfs(0)하고 visit[N-1]이 true이면 목적지에 도착한 것임
#+END_EXAMPLE


** 코드 - dfs로 풀이
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;

int T;
int N;

typedef pair<int, int> Point;

#define ARR_CNT (100+2+10)
Point a[ARR_CNT];
int vis[ARR_CNT];
vector<int> G[ARR_CNT];

int distance(Point& p1, Point& p2)
{
    return abs(p1.first - p2.first) + abs(p1.second - p2.second);
}

void dfs(int num)
{
    vis[num] = 1;
    for(auto& next:G[num]) {
        if (!vis[next]) {
            dfs(next);
        }
    }
}

void solve()
{
    scanf("%d", &N);
    N = N + 2;
    for(int i=0;i<=N;i++) {
        vis[i] = 0;
        G[i].clear();
    }
    
    for(int i=0;i<N;i++) {
        scanf("%d %d", &a[i].first, &a[i].second);
    }

    // graph 경로를 구성
    for(int i=0;i<N-1;i++) {
        for(int j=i+1;j<N;j++) {
            if (distance(a[i], a[j]) <= 20*50) {
                G[i].push_back(j);
                G[j].push_back(i);
            }
        }        
    }
    dfs(0); // 0번이 상근이네 집
    if (vis[N-1] == true)
        printf("happy\n");
    else
        printf("sad\n");    
}

int main(int argc, char* argv[])
{
    scanf("%d", &T);
    for(int tc=1;tc<=T;tc++) {
        solve();
    }
    return 0;
}
#+END_SRC


** TODO 코드 - 플로이드 와샬
- 구글링 해볼 것

** 문제 링크
- https://www.acmicpc.net/problem/9205

** 풀이 참고 (아이디어)
- https://jaimemin.tistory.com/709
