#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 1761 정점들의 거리
#+HTML: tags: SparseTable
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 1761 정점들의 거리

** 접근하기
- Sparse table을 구성해서, LCA를 구하는 문제
#+BEGIN_EXAMPLE

Root에서 노드1사이의 거리 = a
Root에서 노드2사이의 거리 = b
Root에서 노드 1,2의 LCA사이의 거리 = lca

=> Tree에서 두 노드 사이의 거리 = a + b - 2 x lca

#+END_EXAMPLE
** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;
#define LOG_SIZE 16

int N;

int dp[LOG_SIZE+1][40040];

int visited[40040];
int dist[40040];
int depth[40040];

typedef struct Node {
	int num;
	int cost;
} Node;

vector<Node> G[40040];
int M;

void dfs(int idx, int d, int w)
{
	visited[idx] = 1;
	depth[idx] = d;
	dist[idx] = w;
	
	for(auto& o:G[idx]) {
		int next = o.num;
		int cost = o.cost;
		if (!visited[next]) {
			dp[0][next] = idx;
			dfs(next, d+1, w+cost);
		}
	} 
}

int LCA(int p1, int p2)
{
	if (depth[p1] < depth[p2]) {
		swap(p1, p2);
	}
	int diff = depth[p1] - depth[p2];

	for(int i=LOG_SIZE;i>=0;--i) {
		if (diff & (1 << i)) {
			p1 = dp[i][p1];
		}
	}

	if (p1 != p2) {
		for(int i=LOG_SIZE;i>=0;--i) {
			if (dp[i][p1] != dp[i][p2]) {
				p1 = dp[i][p1];
				p2 = dp[i][p2];
			}
		}		
		p1 = dp[0][p1];
	}
	return p1;
}

int main(int argc, char* argv[])
{
	freopen("input.txt", "r", stdin);
	scanf("%d", &N);
	int p1, p2, w;
	for(int i=0;i<N-1;i++) {
		scanf("%d %d %d", &p1, &p2, &w);
		G[p1].push_back({p2, w});
		G[p2].push_back({p1, w});
	}

	dfs(1, 0, 0); // dp[0][i] 채움
	
	// sparse table 채움
	for(int i=1;i<=LOG_SIZE;i++) {
		for(int j=1;j<=N;j++) {
			int tmp = dp[i-1][j];
			dp[i][j] = dp[i-1][tmp];
		}		
	}

	scanf("%d", &M);
	for(int i=0;i<M;i++) {
		scanf("%d %d", &p1, &p2);
		int lca = LCA(p1, p2);
		printf("%d\n", dist[p1]+dist[p2] - 2*dist[lca]);
	}
	return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/1761
** 풀이/해설참고
- https://justicehui.github.io/ps/2019/04/22/BOJ1761/
