#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 17435 합성함수와 쿼리
#+HTML: tags: SparseTable
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 17435 합성함수와 쿼리

** 접근하기
- dp table을 구성해서 N번 이동해서 찾을 것을 Log2(N)번 이동해서 찾는 방식
#+BEGIN_EXAMPLE
5
3 3 5 4 3
5
1 1         1에서 1(2)만큼 이동
2 1         1에서 10(2)만큼 이동
11 3        3에서 1101(2)만큼 이동
1000 4      4에서 1111101000(2)만큼 이동
5 1         5에서 101(2)만큼 이동

dp[k][v] : v에서 k번 이동하면 나오는 번호
----------------
     1 3 3 5 4 3
     2 5 5 3 4 5
     4 5 5 3 4 5
     8 5 5 3 4 5
    16 5 5 3 4 5
    32 5 5 3 4 5
    64 5 5 3 4 5
   128 5 5 3 4 5
   256 5 5 3 4 5
   512 5 5 3 4 5
  1024 5 5 3 4 5
  2048 5 5 3 4 5
  4096 5 5 3 4 5
  8192 5 5 3 4 5
 16384 5 5 3 4 5
 32768 5 5 3 4 5
 65536 5 5 3 4 5
131072 5 5 3 4 5
262144 5 5 3 4 5
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>

#define LOG_SIZE 18

int M;
int next[200020];
int dp[LOG_SIZE+1][200020];

int main(int argc, char* argv[])
{
    scanf("%d", &M);
    for(int i=1;i<=M;i++) {
        scanf("%d", &next[i]);
    }

    for(int i=1;i<=M;i++) {
        dp[0][i] = next[i];
    }

    for(int k=1;k<=LOG_SIZE;k++) {
        for(int i=1;i<=M;i++) {
            dp[k][i] = dp[k-1][dp[k-1][i]];
        }
    }

    for(int k=0;k<=LOG_SIZE;k++) {
        printf("%6lld ", 1ULL<<k);
        for(int i=1;i<=M;i++) {
            printf("%d ", dp[k][i]);
        }
        printf("\n");
    }

    int Q;
    int N, X;
    scanf("%d", &Q);
    for(int i=0;i<Q;i++) {
        scanf("%d %d", &N, &X);
        for(int j=LOG_SIZE;j>=0;j--) {
            if (N & (1<<j)) {
                X = dp[j][X];
            }
        }
        printf("%d\n", X);
    }
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/17435

** 풀이/해설참고
- https://namnamseo.tistory.com/entry/Sparse-Table
