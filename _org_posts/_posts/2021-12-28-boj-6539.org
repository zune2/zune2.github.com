#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 6359 만취한 상범
#+HTML: tags: DP 
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 6349 만취한 상범

** 접근하기
- N이 작으므로, O(N^2)으로 직접 풀어도 된다.
#+BEGIN_EXAMPLE
2
5
100

Case1)
5
  1 2 3 4 5
1 1 1 1 1 1
2 1 0 1 0 1
3 1 0 0 0 1
4 1 0 0 1 1
5 1 0 0 1 0   -> 2
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <cstdio>
int T;

void solve()
{
    int N;
    int a[101] = {0};
    scanf("%d", &N);

    for(int i=1;i<=N;i++){
        for(int j=i;j<=N;j=j+i){
            a[j] = a[j] ^ 1;
        }
    }

    int cnt = 0;
    for(int i=1;i<=N;i++){
        if (a[i]) cnt++;
    }
    printf("%d\n", cnt);
}

int main(int argc, char* argv[])
{
    scanf("%d", &T);
    for(int tc=1;tc<=T;tc++) {
        solve();
    }
    return 0;
}
#+END_SRC
** TODO 64 bit 연산
- 두개의 uint64 type을 이용해서 풀이해볼 것

** sqrt 풀이
#+BEGIN_SRC cpp
#include <cstdio>
#include <cmath>
using namespace std;

int T;

void solve()
{
    int N;
    scanf("%d", &N);
    printf("%d\n", (int)sqrt(N));
}

int main(int argc, char* argv[])
{
    freopen("input.txt", "r", stdin);
    scanf("%d", &T);
    for(int tc=1;tc<=T;tc++) {
        solve();
    }
    return 0;
}
#+END_SRC
- https://burningjeong.tistory.com/61
- 약수의 개수 성질 이용한 풀이
** STL bitset
#+BEGIN_SRC cpp
#include <cstdio>
#include <bitset>
using namespace std;

int T;

void solve()
{
    int N;
    bitset<101> a;

    scanf("%d", &N);

    for(int i=1;i<=N;i++){
        for(int j=i;j<=N;j=j+i){
            a[j] = a[j] ^ 1;
        }
    }

    int cnt = 0;
    for(int i=1;i<=N;i++){
        if (a[i]) cnt++;
    }
    printf("%d\n", cnt);
}

int main(int argc, char* argv[])
{
    freopen("input.txt", "r", stdin);
    scanf("%d", &T);
    for(int tc=1;tc<=T;tc++) {
        solve();
    }
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/6359
