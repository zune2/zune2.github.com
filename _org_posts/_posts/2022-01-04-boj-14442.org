#+HTML: ---
#+HTML: title: BOJ 14442 벽 부수고 이동하기 2
#+HTML: tags: bfs
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 14442
- NxM 맵이 주어질 때, K번 부수고, 0,0에서 N-1,M-1로 이동하는지 체크


** 접근하기
#+BEGIN_EXAMPLE
visit[y][x][cnt] : cnt번 부수고 이동함

현재 위치도 방문 안했을 때, 구동해야 함
--> visit[ny][nx][cnt] == 0

현재보다 다음에 한번 더 부수고 이동할 때도, 방문 안했어야 함
--> visit[ny][nx][cnt + 1] == 0
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;

int N, M, K;

#define SIZE 1010
int m[SIZE][SIZE];
int visited[SIZE][SIZE][11];

int dy[4] = {1, -1, 0, 0};
int dx[4] = {0, 0, 1, -1};

void dbg()
{
    for(int i=0;i<N;i++) {
        for(int j=0;j<M;j++) {
            printf("%d ", m[i][j]);
        }
        printf("\n");
    }
}

typedef struct Node {
    int x;
    int y;
    int cnt_broke;
    int dist;
} Node;

Node Start;

bool safe(int y, int x)
{
    //return (0<=x && x<M) && (0<=y && y<N);
    return (0<=x && x<N) && (0<=y && y<M);
}

int bfs()
{
    queue<Node> q;
    q.push({0, 0, 0, 1});
    visited[0][0][0] = 1;

    while(!q.empty()) {
        Node cur = q.front(); q.pop();    
        if (cur.x == N - 1 && cur.y == M -1) {
            return cur.dist;
        } 
        for(int i=0;i<4;i++) {
            int nx = cur.x + dx[i];
            int ny = cur.y + dy[i];
            int broke = cur.cnt_broke;
            int dist = cur.dist;

            if (safe(ny, nx) && !visited[nx][ny][broke]) {
                if (m[nx][ny] == 1) {
                    if (broke < K && !visited[nx][ny][broke+1]) {
                        visited[nx][ny][broke+1] = 1;
                        q.push({nx, ny, broke+1, dist+1});
                    }
                } else if (m[nx][ny] == 0) {
                    visited[nx][ny][broke] = 1;
                    q.push({nx, ny, broke, dist+1});
                }
            }
        }
    }
    return -1;
}

int main(int argc, char* argv[])
{
    scanf("%d %d %d", &N, &M, &K); 
    char str[1010];
    for(int i=0;i<N;i++) {
        scanf("%s", str);
        for(int j=0;str[j];j++) {
            m[i][j] = str[j] - '0';
        }
    }
    printf("%d\n", bfs());
    return 0;
}
#+END_SRC


** 문제 링크
- https://www.acmicpc.net/problem/14442
