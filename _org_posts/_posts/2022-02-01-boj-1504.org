#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 1504 특정한 최단경로
#+HTML: tags: 최단거리
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 1504 특정한 최단 경로
- 다익스트라 알고리즘으로 구함

** 접근하기
#+BEGIN_EXAMPLE
case1) 1 -> A -> B -> N

case2) 1 -> B -> A -> N

두 경우를 모두 다익스트라 알고리즘으로 나눈다.

// 다익스트라 1번
f(1, A)
f(1, B)

// 다익스트라 2번 - 양방향이므로 a_b == b_a 임
f(A, B)
f(A, N)
f(B, A)

// 다익스트라 3번
f(B, N)

#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;
#define INF 1e9

int N, E;
int A, B;

vector< pair<int, int> > G[801];
int d[801];

priority_queue < pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > pq;

void daik(int start)
{
    for(int i=0;i<=N;i++) {
        d[i] = INF;
    } 
    d[start] = 0; 
    pq.emplace(0, start);    // 시작점
    while(!pq.empty()) {
        int cost = pq.top().first; 
        int id = pq.top().second; 
        pq.pop();
        if (d[id] < cost) continue;         

        for(auto& i:G[id]) {
            int nid = i.second;       // id
            int ncost = i.first;      // cost
            if (d[nid] > cost + ncost) {
                d[nid] = cost + ncost;
                pq.emplace(d[nid], nid);
            }
        }
    } 
}

int main(int argc, char* argv[])
{
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    cin >> N >> E; 
    for(int i=0;i<E;i++) {
        int p1, p2, cost;
        cin >> p1 >> p2 >> cost;
        G[p1].push_back({cost, p2});
        G[p2].push_back({cost, p1});
    }
    cin >> A >> B; 
    daik(1);
    int s_a = d[A];
    int s_b = d[B];

    daik(A);
    int a_b = d[B];
    int b_a = d[B];
    int a_n = d[N];

    daik(B);
    int b_n = d[N];
    
    long long ans = INF;
    ans = min(ans, (long long)(s_a + a_b + b_n));    
    ans = min(ans, (long long)(s_b + b_a + a_n));    
    if ( a_b == INF || ans >= INF)
        cout << -1 << '\n';
    else
        cout << ans << '\n';
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/1504

