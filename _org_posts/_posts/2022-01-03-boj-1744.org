#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 1744 수 묶기
#+HTML: tags: 그리디
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 1744 수 묶기
- 수열에서 두 수를 묶어서 곱하거나, 묶지 않은 상태로 총합 구하기

** 접근하기
#+BEGIN_EXAMPLE
Case1
-1 0 1       -> 음수와 0이 만나면 소거됨

Case2
-9 -2 0 1    -> 음수 x 음수 = 양수  

Case3
1 3          ->  1 x 양수 < 1 + 양수 

max heap - 1보다 큰 수 저장 -> 2개씩 꺼내서 곱하고, 남은 건 더하기
min heap - 음의 정수 저장   -> 2개씩 꺼내서 곱하고, zero_cnt로 소거한 후,  남은 건 더하기(뺄셈효과)
zero_cnt - 0 개수 세기
one_cnt  - 1 개수 세기 -> 마지막에 더하기
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;

// 양수 priority queue
// 음수 priority queue
// zero_cnt
// one_cnt

priority_queue<int> plus_pq; // max heap
priority_queue < int, vector<int>, greater<int> > minus_pq; // min heap
int zero_cnt;
int one_cnt;

int N;
int main(int argc, char* argv[])
{
    scanf("%d", &N);

    zero_cnt = 0;
    one_cnt = 0;

    int ans = 0;    
    for(int i=0;i<N;i++) {
        int num;
        scanf("%d", &num);
        if (num == 0)
            zero_cnt += 1;
        else if (num == 1)
            one_cnt += 1;
        else if ( num > 1) {
            plus_pq.push(num);
            int ret = plus_pq.size();
            //printf("size : %d \n", ret);
        } else if ( num < 0) {
            minus_pq.push(num);
        }
    }

    while(minus_pq.size() >= 2) {
        int n1 = minus_pq.top(); minus_pq.pop();
        int n2 = minus_pq.top(); minus_pq.pop();
        ans += (n1*n2);
    }
    if (minus_pq.size() == 1) {
        if (zero_cnt > 0) {
            zero_cnt--;
        } else {
            int n1 = minus_pq.top(); minus_pq.pop();
            ans += n1;
        }
    }

    while(plus_pq.size() >= 2) {
        int n1 = plus_pq.top(); plus_pq.pop();
        int n2 = plus_pq.top(); plus_pq.pop();
         ans += (n1*n2);
    }
    if (plus_pq.size() == 1) {
        int n1 = plus_pq.top(); plus_pq.pop();
        ans += n1;
    }
    ans += one_cnt;

    printf("%d\n", ans);
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/1744

