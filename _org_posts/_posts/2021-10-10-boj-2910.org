#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 2910 빈도정렬
#+HTML: tags: STL
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 2910 빈도정렬
- 배열이 주어지고, 빈도순으로 정렬
- 빈도가 같다면 먼저 나온 것을 선택

** 접근하기
- STL map객체를 써서 배열값으로 index 룩업/cnt 룩업 할 수 있게 구성.
  - map을 쓸 수 없다면, 구현이 까다로웠을 듯.
- 구조체의 idx, cnt를 각각 업데이트
- cmp 함수대로 sort하면, 결과가 나옴

** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <map>
#include <algorithm>
using namespace std;

typedef struct Node {
    int num;
    int idx;
    int cnt;
} Node;

int N, C;
Node pool[1010];

bool cmp(Node& p1, Node& p2)
{
    if (p1.cnt == p2.cnt) {
        return p1.idx < p2.idx;
    } else {
        return p1.cnt > p2.cnt;
    }
}

int main(int argc, char* argv[])
{
    //freopen("input.txt", "r", stdin);
    map<int, int> mp;
    map<int, int> mp_idx;
    scanf("%d %d", &N, &C);

    for(int i=0;i<N;i++) {
        scanf("%d", &pool[i].num);
        mp[pool[i].num]++;
        if (mp_idx[pool[i].num] == 0) {
            mp_idx[pool[i].num] = i + 1;
        }
    } 
    for(int i=0;i<N;i++) {
        pool[i].cnt = mp[pool[i].num];
        pool[i].idx = mp_idx[pool[i].num];
    } 

    sort(pool, pool+N, cmp);

    for(int i=0;i<N;i++) {
        printf("%d ", pool[i].num);
    }
    printf("\n");
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/2910
