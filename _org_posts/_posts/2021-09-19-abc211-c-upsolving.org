#+HTML: ---
#+HTML: title: C - chokudai
#+HTML: tags: AtCoder DP
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** C - chokudai

** 접근하기
- 경우의 수를 구하는 DP 문제
#+BEGIN_EXAMPLE

dp[i][j] : S의 i번째 문자까지 str = "chokudai"의 j번째 문자까지를 만드는 경우의 수

dp[i+1][j+1] = dp[i][j+1] 
  
  (S[i] != S[j]이면, i문자일 때, j번째 문자를 선택X)

dp[i+1][j+1] = dp[i][j+1] + dp[i][j];

  (S[i] == S[j]이면, i문자일 때, 

     j문자를 선택X ==> dp[i][j+1] 이전 문자에서의 경우의 수
     j문자를 선택O ==> j일 때의 경우의 수를 더해준다.)
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <cstdio>

using namespace std;

char str[100010];
int dp[100010][9];

const char* T = "chokudai";
const int MOD = 1000000007;
    
int main(int argc, char* argv[])
{
    scanf("%s", str);
    int len = 0;
    for(;str[len];len++) {
        dp[len][0] = 1; 
    }

    for(int i=0;i<len;i++) {
        for(int j=0;j<8;j++) {
            if (str[i] != T[j]) {
                dp[i+1][j+1] = dp[i][j+1];
            } else {
                dp[i+1][j+1] = (dp[i][j+1] + dp[i][j]) % MOD;
            }
        }
    }
    printf("%d\n", dp[len][8]);
    return 0;
}
#+END_SRC


** 참고자료
- [[https://velog.io/@nala723/210706DP-%EB%B0%8F-%EA%B2%BD%EC%9A%B0%EC%9D%98-%EC%88%98%EC%97%90-%EB%8C%80%ED%95%B4][경우의 수]]
  - 합의 법칙 : 사건 A,B가 각각 일어날 경우의 수
  - 곱의 법칙 : 사건 A,B가 동시에 일어날 경우의 수

** 문제 링크
- https://atcoder.jp/contests/abc211/tasks/abc211_c
