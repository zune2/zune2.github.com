#+HTML: ---
#+HTML: title: BOJ 16194 카드 구매하기 2
#+HTML: tags: DP
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 16194
N개의 카드를 갖기 위해 지불해야 하는 최솟값
** 접근하기
#+BEGIN_EXAMPLE
4
1 5 6 7    --> 4


dp[k] = k장의 카드를 갖기 위해 지불해야 하는 최소값

dp[0] = 0

dp[1] = MIN(dp[1], dp[1-1] + a[1]) = 1,    dp[1] = 1
 
dp[2] = MIN(dp[2], dp[2-1] + a[1], 2 
                   dp[2-2] + a[2], 5       dp[2] = 2

dp[3] = MIN(dp[3], dp[3-1] + a[1], 3
                   dp[3-2] + a[2], 7
                   dp[3-2] + a[3], 8       dp[3] = 3 

dp[4] = MIN(dp[4], dp[4-1] + a[1], 4 
                   dp[4-2] + a[2], 7
                   dp[4-3] + a[3], 7
                   dp[4-4] + a[4], 7       dp[4] = 4

이중 루프 형태로 구성됨

점화식
dp[i] = min(dp[i], dp[i-j] + a[j]) 
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int N;

int a[1001];
int dp[1001];

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    for(int i=1;i<=N;i++) {
        scanf("%d", &a[i]);
    }

    for(int i=1;i<=N;i++)
        dp[i] = 987654321;

    for(int i=1;i<=N;i++) {
        for(int j=1;j<=i;j++) {
            dp[i] = min(dp[i], dp[i-j] + a[j]);
        }
    }
    printf("%d\n", dp[N]);
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/16194
