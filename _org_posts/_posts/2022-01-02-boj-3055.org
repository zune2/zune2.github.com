#+HTML: ---
#+HTML: title: BOJ 3055 탈출
#+HTML: tags: bfs 그래프
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 3055 탈출
- 물이 계속 차오르고 있을때, 고슴도치가 물을 피해, S에서 D로 이동할 최소시간

** 접근하기
- BFS로 풀기. 물의 확장을 bfs로 탐색 water_map에 채우기
#+BEGIN_EXAMPLE
water    bebber
0 1 0    3 0 0
3 2 1    2 1 0
4 0 2    1 0 1

- 목적지는 water[y][x] = 0 상태
- water[ny][nx] > bebber[y][x] + 1
   -> 이동할 좌표가 물이 찬 시간 > 비버의 현재시간 + 1  (이 조건을 생각해내는 것이 중요)
#+END_EXAMPLE


** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <queue>
using namespace std;

int R, C;

#define MAX_H 51
#define MAX_W 51

char map[MAX_H][MAX_H];
int water[MAX_H][MAX_H];
int bebber[MAX_H][MAX_H];

typedef struct Node
{
    int y;
    int x;
} Node;

queue<Node> water_q;

Node start;
Node dest;

int dy[4] = {1, -1, 0, 0};
int dx[4] = {0, 0, 1, -1};

bool safe(int y, int x)
{
    return (0<=x && x < C) && (0<=y && y < R);
}

void bfs_water()
{
    while(!water_q.empty()) {
        Node cur = water_q.front(); water_q.pop();

        for(int i=0;i<4;i++) {
            int ny = cur.y + dy[i];    
            int nx = cur.x + dx[i];
            
            if (safe(ny, nx) && !water[ny][nx] && map[ny][nx] == '.') {
                water[ny][nx] = water[cur.y][cur.x] + 1;
                water_q.push({ny, nx});
            }
        }
    }
}

void bfs_bebber()
{
    queue<Node> q;
    q.push(start);

    while(!q.empty()) {
        Node cur = q.front(); q.pop();

        for(int i=0;i<4;i++) {
            int ny = cur.y + dy[i];
            int nx = cur.x + dx[i];

            if (safe(ny, nx) && !bebber[ny][nx] && (map[ny][nx] == '.' || map[ny][nx] == 'D')) {
                
                if (water[ny][nx] == 0) {
                    bebber[ny][nx] = bebber[cur.y][cur.x] + 1;
                    q.push({ny, nx});
                } else if (water[ny][nx] > bebber[cur.y][cur.x] + 1) {
                    bebber[ny][nx] = bebber[cur.y][cur.x] + 1;
                    q.push({ny, nx});
                }
            } 
        }
    }
}

int main(int argc, char* argv[])
{
    freopen("input4.txt", "r", stdin);
    scanf("%d %d", &R, &C);
    char str[51];
    for(int i=0;i<R;i++) {
        scanf("%s", str);
        for(int j=0;str[j];j++) {
            map[i][j] = str[j];
            if (str[j] == '*') {
                water_q.push({i,j});        
            } else if (str[j] == 'S') {
                start.y = i;
                start.x = j;
                //printf("i:%d j:%d \n", i, j);
            } else if (str[j] == 'D') {
                dest.y = i;
                dest.x = j;
            }
        }
    }
    bfs_water();
#if 0
    for(int i=0;i<R;i++) {
        for(int j=0;j<C;j++) {
            printf("%d ", water[i][j]);
        }        
        printf("\n");
    }
#endif

    bfs_bebber();
#if 0    
    for(int i=0;i<R;i++) {
        for(int j=0;j<C;j++) {
            printf("%d ", bebber[i][j]);
        }        
        printf("\n");
    }
#endif    
    if (bebber[dest.y][dest.x] == 0) {
        printf("KAKTUS\n");
    } else {
        printf("%d\n", bebber[dest.y][dest.x]);
    }
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/3055


** 풀이참고/해설참고
- https://yabmoons.tistory.com/66
