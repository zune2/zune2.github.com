#+HTML: ---
#+HTML: layout: post
#+HTML: title: D - Sum of Maximum Weights
#+HTML: tags: AtCoder
#+HTML: ---
#+OPTIONS: ^:nil

** D - Sum of Maximum Weights

** 접근하기
- Union Find에서 연결된 집합의 크기를 count할 수 있어야 함
  - 배열을 하나 더 선언해서 count하는 방법
  - Weighted Union Find를 이용하는 방법

#+BEGIN_EXAMPLE
3
1 2 10
2 3 20
#+END_EXAMPLE

- f(1,2) = 10
- f(2,3) = 20
- f(1,3) = 20 : 10 -> 20이면 가장 큰 값을 고름

- 문제 나온 수학식의 의미 : 모든 쌍을 다 찾아보라
#+BEGIN_SRC cpp
for(int i=1;i<=N-1) {
    for(int j=i+1;j<=N;j++) {
         f(i, j);
    }
}
#+END_SRC

** 코드 - Weighted Union Find를 이용하기
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int N;

typedef struct Node {
    int u;
    int v;
    int w;
} Node;
Node pool[200020];

int p[200020];

int Find(int num)
{
    if(p[num] < 0) return num;
    return p[num] = Find(p[num]);
}

void Union(int a, int b)
{
    a = Find(a);
    b = Find(b);

    if (a == b) return;

    if (p[a] <= p[b]) {
        p[a] += p[b];    
        p[b] = a;
    } else {
        p[b] += p[a];    
        p[a] = b;
    }
}

bool cmp(Node& p1, Node& p2)
{
    return (p1.w < p2.w);
}

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    for(int i=0;i<=N;i++) p[i] = -1;

    for(register int i=0;i<N-1;i++) {
        scanf("%d %d %d", &pool[i].u, &pool[i].v, &pool[i].w);
    }
    sort(pool, pool+(N-1), cmp);

    long long ans = 0;
    for(register int i=0;i<N-1;i++) {
        ans += (long long)pool[i].w * p[Find(pool[i].u)] * p[Find(pool[i].v)];
        Union(pool[i].u, pool[i].v);
    }
    printf("%lld\n", ans);
    return 0;
} 
#+END_SRC

** 문제 링크/참고자료
- https://atcoder.jp/contests/abc214/tasks/abc214_d
- [[https://travelbeeee.tistory.com/369][Weighted Union Find]]
