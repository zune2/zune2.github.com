#+HTML: ---
#+HTML: title: BOJ 2213 트리의 독립집합
#+HTML: tags: DP dfs Tree
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 2213 트리의 독립집합
- tree 구조에서 DP를 적용하는 문제 

** 접근하기
#+BEGIN_EXAMPLE
                 1 3 5 7을 선택하면 
    1            10 + 40 + 20 + 70 = 140
    |
    2
   / \
  3   6 
  |   |
  4   7
  |
  5

#+END_EXAMPLE


** 코드
#+BEGIN_SRC cpp
i#include <bits/stdc++.h>

using namespace std;

int N;
int a[10010];
int done[10010];
int dp[10010][2];
vector<int> G[10010];	// 인접리스트
vector<int> ans;

void dfs(int num)
{
    done[num] = 1;
    dp[num][0] = 0;	// 독립 X
    dp[num][1] = a[num];// 독립 O

    for(auto& next:G[num]) {
        if (!done[next]) {
            dfs(next);
            dp[num][1] += dp[next][0];			// 독립 -> 다음은 일반
            dp[num][0] += max(dp[next][0], dp[next][1]);// 일반 -> 다음은 독립/일반
        }
    }
}

// path를 출력하기
void walk(int num, int prev) 
{
    if (dp[num][1] > dp[num][0] && !done[prev]) {
        done[num] = 1;
        ans.push_back(num);
    }

    for(auto& next:G[num]) {
        if (next != prev) {
            walk(next, num);
        }
    }
}

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    for(int i=1;i<=N;i++) {
        scanf("%d", &a[i]);
    }

    for(int i=0;i<N-1;i++) {
        int p1, p2;
        scanf("%d %d", &p1, &p2);
        G[p1].push_back(p2);
        G[p2].push_back(p1);
    }
    dfs(1);		// 1번을 root로 dfs로 dp table 채우기
    printf("%d\n", max(dp[1][0], dp[1][1]));
    for(int i=1;i<=N;i++) done[i] = 0;

    walk(1, 0);
    sort(ans.begin(), ans.end());
    for(auto o:ans) {
        printf("%d ", o);
    }
    printf("\n");
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/2213

** 풀이 참고
- https://kth990303.tistory.com/158
