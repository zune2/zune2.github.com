#+HTML: ---
#+HTML: title: BOJ 13975 파일 합치기 3
#+HTML: tags: 그리디
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 2213 트리의 독립집합
- 그리디 방법으로 문제의 성질을 파악하는 문제

** 접근하기
#+BEGIN_EXAMPLE
- 작은 값 두개씩 더하기를 반복하면, 최적임을 발견해야 한다.
- 쉽게 보이지 않았음.
- 값의 범위가 int를 넘을 수 있음. long long으로 변경

40 30 30 50

30 + 30 = 60  ......... (1)

40 60 50

40 + 50 = 90  ......... (2)

90 60 

90 60 = 150   ......... (3)

150        // 하나 남으면 종료

60 + 90 + 150 = 300

ans = 150
#+END_EXAMPLE


** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;

int T;
int N;

typedef long long ll;

void solve()
{
    priority_queue < ll, vector<ll>, greater<ll> > pq;
    ll num;
    scanf("%d", &N);
    for(int i=0;i<N;i++) {
        scanf("%lld", &num);
        pq.push(num);
    }

    long long sum = 0;
    while((int)pq.size() >= 2){
        ll n1 = pq.top(); pq.pop();
        ll n2 = pq.top(); pq.pop();
        sum += n1+n2;
        pq.push(n1+n2);
    }
    printf("%lld\n", sum);
}

int main(int argc, char* argv[])
{
    scanf("%d", &T);
    for(int tc=1;tc<=T;tc++) {
        solve();
    }
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/13975
