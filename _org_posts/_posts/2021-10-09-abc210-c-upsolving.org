#+HTML: ---
#+HTML: title: abc210 C - Colorful Candies
#+HTML: tags: AtCoder
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** C - Colorful Candies
- N개의 캔디가 주어질 때, 각 요소는 캔디의 색을 의미
- 최대한 다른 색깔로 K개 고를 때, 가능한 숫자

** 접근하기
- N의 범위가 30만이내, K를 범위로 잡고 다 찾아보면 된다.

** 코드 - hash를 구현해서 풀기
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;


#define HASH_SIZE 7701

int N;
int K;

typedef struct Node
{
    int num;
    int cnt;
    Node* next;
} Node;

int a[300010];
int idx;
Node pool[300010];
Node* table[HASH_SIZE];

Node* CreateNode(int num)
{
    Node* ptr = &pool[idx++];
    ptr->num = num;
    ptr->cnt = 1;
    ptr->next = NULL;
    return ptr;
}

int HASH(int num)
{
    return num%HASH_SIZE;
}

void hash_add(Node* ptr)
{
    int key = HASH(ptr->num);
    ptr->next = table[key];
    table[key] = ptr;
}

Node* hash_find(int num)
{
    int key = HASH(num);
    Node* ptr = table[key];
    while(ptr) {
        if (ptr->num == num) return ptr;
        ptr = ptr->next;
    }
    return NULL;
}

Node* hash_remove(int num)
{
    int key = HASH(num);
    Node* ptr = table[key];
    Node* prev = NULL;
    while(ptr) {
        if (ptr->num == num) {
            if (prev == NULL) {
                table[key] = table[key]->next;
            } else {
                Node* todel = ptr;
                prev->next = ptr->next;
                return todel;
            }
        }
        prev = ptr;
        ptr = ptr->next;
    }
    return NULL;
}

int main(int argc, char* argv[])
{
    idx = 0;
    scanf("%d %d", &N, &K);
    int ans = 0;

    for(int i=0;i<N;i++) {
        scanf("%d", &a[i]);
    } 

    int maxv = 0;
    for(int i=0;i<K;i++) {
        int val = a[i];
        Node* ptr = hash_find(val);
        if (ptr != NULL) {
            ptr->cnt += 1;
        } else {
            Node* obj = CreateNode(val); 
            hash_add(obj);
            ans += 1;
        }
    }
    maxv = max(maxv, ans);

    for(int i=K;i<N;i++) {
        int val = a[i];
        Node* ptr = hash_find(val);
        if (ptr != NULL) {
            ptr->cnt += 1;
        } else {
            Node* obj = CreateNode(val); 
            hash_add(obj);
            ans += 1;
        }

        int val2 = a[i-K];
        ptr = hash_find(val2);
        if (ptr != NULL) {
            ptr->cnt -= 1;
            if (ptr->cnt == 0) {
                ans -= 1;
                hash_remove(val2);
            }
        }
        maxv = max(maxv, ans);
    }
    printf("%d\n", maxv);
    return 0;
}
#+END_SRC

** 코드 - STL map 이용
- STL map을 잘 쓰기
  - key에 값 갱신
  - int, int로 map객체 만들기
  - erase로 노드 지우기
  - size로 count하기

#+BEGIN_SRC cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;

int N, K;
map< int, int > mp; // int key로 int value를 룩업하는 배열
int a[300010];

int main(int argc, char* argv[])
{
    scanf("%d %d", &N, &K);
    
    for(int i=0;i<N;i++) {
        scanf("%d", &a[i]);
    }

    // 1번째 주기를 시작
    for(int i=0;i<K;i++) {
        mp[a[i]] += 1; // 처음 K만큼 룩업배열 채우기
    }
    int ans = mp.size(); // size가 개수  1 1 2 라면 2가 됨, 1 2 3이면 3이 됨

    for(int i=K;i<N;i++) { // 두번째 주기를 시작
        mp[a[i]]++;     
        mp[a[i-K]]--;      // i-K : 이전 주기의 시작부터

        if(mp[a[i-K]] == 0) mp.erase(a[i-K]); // 값이 0이면, 노드를 삭제
        ans = max(ans, (int)mp.size());       // size가 크면 ans 갱신
    }
    printf("%d\n", ans); 
    return 0;
}
#+END_SRC
** 문제 링크
- https://atcoder.jp/contests/abc200/tasks/abc200_d

