#+HTML: ---
#+HTML: title: abc231 E - Minimal payments
#+HTML: tags: DP dfs
#+HTML: ---
#+OPTIONS: ^:nil

** E - Minimal payments

** 접근하기
#+BEGIN_EXAMPLE
X = 87
A = (1,10,100)

100 - 87 = 13     // 100내기(1), 13받기
10                // 10받기(1)
1
1
1                // 3받기(3)

총 5개가 답
#+END_EXAMPLE
** 코드 - 반복문 풀이
#+BEGIN_SRC cpp
#include <cstdio>

typedef long long ll;

int N;
ll x;
ll a[65];

int main(int argc, char* argv[])
{
    scanf("%d %lld", &N, &x);
    for(int i=1;i<=N;i++) {
        scanf("%lld", &a[i]);
    } 

    ll ans = 0;
    for(int i=N;i>=1;i--)
    {
        ll k = x%a[i];     // 87
        ll r = a[i]-k;   // 13
        if (k-r < a[i-1]) {
            ans += x/a[i];
            x = k;
        } else {
            ans += x/a[i] + 1;
            x = r;
        }
    } 
    printf("%lld\n", ans);
    return 0;
}
#+END_SRC
** 코드 - dfs이용
#+BEGIN_SRC cpp
#include <cstdio>
typedef long long ll;

int N;
ll x;
ll a[65];

ll dfs(int idx, ll x)
{
    if (idx == 1) return x;
   
    ll   cnt = x / a[idx];         // 현재yen 몇개드는지
    ll case1 = x % a[idx];         // 87 % 100 = 87
    ll case2 = a[idx] - case1;     // 100 - 87 = 13

    if (case1 - case2 < a[idx-1])       // 이 식을 생각하기 어려움
        return dfs(idx-1, case1) + cnt;
    else
        return dfs(idx-1, case2) + cnt + 1;
}

int main(int argc, char* argv[])
{
    scanf("%d %lld", &N, &x);
    for(int i=1;i<=N;i++) {
        scanf("%lld", &a[i]);
    } 

    ll ret = dfs(N, x);
    printf("%lld\n", ret);
    return 0;
}
#+END_SRC

** TODO 코드 - DP풀이
** 문제 링크
- https://atcoder.jp/contests/abc231/tasks/abc231_e
