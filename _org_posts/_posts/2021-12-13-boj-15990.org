#+HTML: ---
#+HTML: title: BOJ 16194 1,2,3 더하기 5
#+HTML: tags: DP 2차원DP
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 16194 1,2,3 더하기 5
- 1,2,3 을 이용해서 정수 N을 만드는 경우의 수를 구함
- 같은 수를 두번 이상 사용하면 안된다는 조건이 있음
** 접근하기
#+BEGIN_EXAMPLE

점화식 아이디어

dp[숫자][1로끝나는경우]
dp[숫자][2로끝나는경우]
dp[숫자][3로끝나는경우]


1을 만드는 경우 1
dp[1][1] = 1
dp[1][2] = 0
dp[1][3] = 0

2를 만드는 경우 1
dp[2][1] = 0
dp[2][2] = 1
dp[2][3] = 0


3을 만드는 경우 3
1 + 1 + 1     dp[3][1] = 1
1 + 2         dp[3][2] = 1
3             dp[3][3] = 1

dp[7][1] = dp[6][2] + dp[6][3]
dp[7][2] = dp[5][1] + dp[5][3]
dp[7][3] = dp[4][1] + dp[4][2]
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
// https://jdselectron.tistory.com/71
#include <cstdio>
using namespace std;

#define MOD 1000000009

int T;
int N;
unsigned int dp[100010][3];  // 10억씩 3번 더하는 경우가 있음 - uint나 long long

int main(int argc, char* argv[])
{
    scanf("%d", &T);

 //   dp[0][1] = 0; 
 //   dp[0][2] = 0; 
 //   dp[0][3] = 0; 

    dp[1][1] = 1; 
 //   dp[1][2] = 0; 
 //   dp[1][3] = 0; 

 //   dp[2][1] = 0; 
    dp[2][2] = 1; 
 //   dp[2][3] = 0; 

    dp[3][1] = 1; 
    dp[3][2] = 1; 
    dp[3][3] = 1; 

    for(int i=4;i<=100000;i++) {
        dp[i][1] = (dp[i-1][2]%MOD + dp[i-1][3]%MOD)%MOD; 
        dp[i][2] = (dp[i-2][1]%MOD + dp[i-2][3]%MOD)%MOD;
        dp[i][3] = (dp[i-3][1]%MOD + dp[i-3][2]%MOD)%MOD;
    }

    while(T--) {
        int num;
        scanf("%d", &num);
        printf("%u\n", (dp[num][1]%MOD + dp[num][2]%MOD + dp[num][3]%MOD)%MOD);
    }

    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/15990

** 풀이/설명 참고
- [[https://velog.io/@jkh9615/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-15990-1-2-3-%EB%8D%94%ED%95%98%EA%B8%B0-5-Java][velog.io/@jkh9615]]
