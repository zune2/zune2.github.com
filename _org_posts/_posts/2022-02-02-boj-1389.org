#+HTML: ---
#+HTML: title: BOJ 1389 케빈 베이컨의 6단계 법칙
#+HTML: tags: 최단거리
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 1389 케빈 베이컨의 6단계 법칙
- BFS로 최단거리 -> 깊이

** 접근하기
#+BEGIN_EXAMPLE
N이 100 

1~N만큼 BFS를 구동해서, 찾는다.
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;
#define FASTIO ios_base::sync_with_stdio(false); cin.tie(NULL);
typedef long long ll;

int N, M;
typedef struct Node
{
    int id;
    int dist;
} Node;

vector<Node> G[101];

int bfs(int start)
{
    int vis[101] = {0, };    
    int dp[101] = {0, };    
    queue<Node> q;
    q.push({start, 0});
    vis[start] = 1;
    dp[start] = 0;

    while(!q.empty()) {
        Node cur = q.front(); q.pop();
        for(auto& o : G[cur.id]) {
            int nid = o.id;
            if (vis[nid] == 0) {
                vis[nid] = 1;
                dp[nid] = cur.dist +1;
                q.push({nid, cur.dist +1}); 
            } 
        }
    }

    int sum = 0;
    for(int i=1;i<=N;i++) {
        sum += dp[i];
    }
    return sum;
}


int main(int argc, char* argv[])
{
    FASTIO;
    //freopen("input.txt", "r", stdin);
    cin >> N >> M;
    int p1, p2;
    for(int i=0;i<M;i++) {
        cin >> p1 >> p2;
        G[p1].push_back({p2, 0});
        G[p2].push_back({p1, 0});
    }

    int val = 987654321;
    int ans = -1;
    for(int i=1;i<=N;i++) {
        int ret = bfs(i);
        if (val > ret) {
            val = ret;
            ans = i;
        }
    }
    cout << ans << '\n';
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/1389
