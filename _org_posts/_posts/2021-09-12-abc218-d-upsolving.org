#+HTML: ---
#+HTML: title: D - Rectangles
#+HTML: tags: AtCoder
#+HTML: toc: true
#+HTML: toc_sticky: true
#+HTML: ---
#+OPTIONS: ^:nil

** D - Rectangles
- 조건에 맞는 사각형의 개수를 구하는 문제

** 접근하기
- 사각형의 성질을 알아야 풀 수 있는 문제
- N <= 2000이므로, 2000*2000=40000000, 4백만으로 이중 for loop까지는 가능할 것.
- Editorial에서는 sort 후 binsearch를 통해 최적화함

** 코드
#+BEGIN_SRC cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int N;

typedef struct Node {
    int y;
    int x;
} Node;

Node a[2020];

bool comp(Node& p1, Node& p2) // sort에 사용되는 compare
{
    if (p1.x == p2.x)
    {
        return (p1.y < p2.y);
    } else {
        return (p1.x < p2.x);
    }
}

bool comp2(Node p1, Node p2) // binary search에 사용되는 compare
{
    if (p1.x == p2.x)
    {
        return (p1.y < p2.y);
    } else {
        return (p1.x < p2.x);
    }
}

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    for(int i=0;i<N;i++) {
        scanf("%d %d", &a[i].x, &a[i].y);
    }
    sort(a, a+N, comp);
    
    int cnt = 0;
    for(int i=0;i<N;i++) {
        for(int j=i+1;j<N;j++) {
            if (a[i].x < a[j].x && a[i].y < a[j].y) {
                Node tmp1;
                tmp1.x = a[i].x;
                tmp1.y = a[j].y;
                bool cond1 = binary_search(a, a+N, tmp1, comp2);

                Node tmp2;
                tmp2.x = a[j].x;
                tmp2.y = a[i].y;
                bool cond2 = binary_search(a, a+N, tmp2, comp2);
                
                if (cond1 && cond2)
                    cnt++;
            }
        }
    }
    printf("%d\n", cnt);
    return 0;
}
#+END_SRC

- 181ms 걸림

** TODO 최적 풀이 분석
- 20ms 이내의 최적 풀이가 있음

** 주의할 점
- STL pair를 쓰지 않을 때, compare함수가 first, second값을 모두 compare해줘야 한다.

** 문제 링크
- https://atcoder.jp/contests/abc218/tasks/abc218_d

