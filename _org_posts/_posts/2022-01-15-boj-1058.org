#+HTML: ---
#+HTML: layout: post
#+HTML: title: BOJ 1058 친구
#+HTML: tags: dfs
#+HTML: ---
#+OPTIONS: ^:nil

** BOJ 1058 친구
- 곧바로 친구관계이거나, 하나 멀리 친구인 관계를 모두 세는 문제

** 접근하기
#+BEGIN_EXAMPLE
- dfs는 visit 배열에서 한번 갔던 곳을 체크함

   1 --> 2 --> 3 관계일 때

   1 --> 2            1번

   1 --> 2 --> 3      2번

   visit 배열
   1 2 3
   1 1 1       3일 때, 1은 2,3과 친구관계를 의미 3 - 1 = 2
#+END_EXAMPLE

** 코드
#+BEGIN_SRC cpp
#include <bits/stdc++.h>
using namespace std;

int N;
char str[52];
vector<int> G[52];
int visited[52];

int ans = 0;

void dfs(int num, int dep) {

    if (dep > 2) return;
    visited[num] = 1;
    
    for(auto& next: G[num]) {
        dfs(next, dep + 1);
    }
}

int main(int argc, char* argv[])
{
    scanf("%d", &N);
    for(int i=0;i<N;i++) {
        scanf("%s", str);
        for(int j=0;j<N;j++) {
            if (str[j] == 'Y') {
                G[i].push_back(j);
            }
        }
    }

    for(int i=0;i<N;i++) {
        for(int j=0;j<N;j++)
            visited[j] = 0;
        int cnt = 0;
        dfs(i, 0);
        for(int j=0;j<N;j++) {
            if (visited[j]) cnt += 1;
        }
        ans = max(ans, cnt);
    }
    printf("%d\n", ans-1);
    return 0;
}
#+END_SRC

** 문제 링크
- https://www.acmicpc.net/problem/1058
